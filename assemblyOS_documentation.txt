1.asm
;Content of 1.asm
; Bootloader: Initializes the system and loads the kernel

BITS 16  ; Use 16-bit mode for bootloader
org 0x7C00

; Set up a stack
mov ax, 0x9000
mov ss, ax
mov sp, 0xFFFF

; Set up segments
mov ax, 0x07C0
mov ds, ax
mov es, ax

; Print a message
mov si, hello_msg
call print_string

; Load the kernel
mov bx, 0x0000   ; Kernel segment
mov dh, 0x00     ; Track
mov ch, 0x00     ; Head
mov cl, 0x02     ; Sector

mov ah, 0x02     ; BIOS function to read sectors
mov al, 0x01     ; Number of sectors to read
int 0x13

jmp 0x0000:0x7E00  ; Jump to the kernel

hello_msg db 'Bootloader loaded successfully!', 0

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

times 510-($-$$) db 0  ; Pad the boot sector
dw 0xAA55             ; Boot signature


2.asm
;Content of 2.asm
; Kernel Entry Point

BITS 32
section .text
global kernel_entry

kernel_entry:
    ; Set up the stack
    cli                     ; Clear interrupts
    mov ax, 0x10            ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x90000        ; Set stack pointer

    ; Initialize the GDT (Global Descriptor Table)
    call initialize_gdt

    ; Initialize the IDT (Interrupt Descriptor Table)
    call initialize_idt

    ; Initialize paging
    call initialize_paging

    ; Kernel main loop
hang:
    hlt                     ; Halt CPU until next interrupt
    jmp hang

initialize_gdt:
    ; Your GDT initialization code here
    ret

initialize_idt:
    ; Your IDT initialization code here
    ret

initialize_paging:
    ; Your paging initialization code here
    ret

section .data
    ; Kernel data section


3.asm
;Content of 3.asm
; Memory Manager: Handles memory allocation and management

BITS 64
section .bss
align 16
page_directory:
    resb 4096  ; Page directory (4 KB aligned)
page_table:
    resb 4096  ; Page table (4 KB aligned)

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize paging
    call setup_paging

    ; Print a message indicating memory manager is running
    mov si, mm_msg
    call print_string

    ; Halt the CPU (infinite loop)
    hlt

mm_msg db 'Memory Manager initialized!', 0

setup_paging:
    ; Load the address of the page directory into CR3
    lea rax, [page_directory]
    mov cr3, rax

    ; Enable paging (set the PG bit in CR0)
    mov eax, cr0
    or eax, 0x80000000  ; Set PG bit
    mov cr0, eax

    ret

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


4.asm
;Content of 4.asm
; Interrupt Descriptor Table (IDT): Manages hardware interrupts

BITS 64
section .bss
align 16
idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the IDT
    call setup_idt

    ; Enable interrupts
    sti

    ; Print a message indicating IDT is set up
    mov si, idt_msg
    call print_string

    ; Halt the CPU (infinite loop)
    hlt

idt_msg db 'IDT initialized!', 0

setup_idt:
    ; Load the address of the IDT into the IDTR
    lidt [idt_ptr]

    ; Set up a basic interrupt handler for interrupt 0x20 (IRQ0)
    lea rax, [isr0]
    mov [idt + 0x20 * 16 + 0], ax  ; Offset bits 0-15
    mov [idt + 0x20 * 16 + 6], ax  ; Offset bits 16-31
    mov byte [idt + 0x20 * 16 + 5], 0x8E  ; Present, DPL 0, 32-bit interrupt gate

    ret

isr0:
    ; Basic interrupt handler for IRQ0 (timer interrupt)
    pusha
    cli

    ; Acknowledge the interrupt
    mov al, 0x20
    out 0x20, al

    ; Print a message (for testing purposes)
    mov si, isr_msg
    call print_string

    sti
    popa
    iret

isr_msg db 'Timer interrupt!', 0

idt_ptr:
    dw idt_end - idt - 1
    dq idt

idt_end:


5.asm
;Content of 5.asm
; Global Descriptor Table (GDT): Defines memory segments

BITS 64
section .bss
align 16
gdt:
    dq 0x0000000000000000  ; Null segment
    dq 0x00A09A000000FFFF  ; Code segment
    dq 0x00A092000000FFFF  ; Data segment
    dq 0x0000000000000000  ; TSS (low)
    dq 0x0000000000000000  ; TSS (high)

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the GDT
    call setup_gdt

    ; Print a message indicating GDT is set up
    mov si, gdt_msg
    call print_string

    ; Halt the CPU (infinite loop)
    hlt

gdt_msg db 'GDT initialized!', 0

setup_gdt:
    ; Load the address of the GDT into the GDTR
    lgdt [gdt_ptr]

    ; Reload segment registers
    mov ax, 0x10  ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    jmp 0x08:flush_cs  ; Code segment selector

flush_cs:
    ; Return to continue execution after reloading CS
    ret

gdt_ptr:
    dw gdt_end - gdt - 1
    dq gdt

gdt_end:


6.asm
;Content of 6.asm
; Task Scheduler: Manages task switching

BITS 64
section .bss
align 16
task1_stack:
    resb 4096  ; Stack for task 1
task2_stack:
    resb 4096  ; Stack for task 2

current_task:
    resq 1  ; Stores the current task

section .text
global _start

_start:
    ; Set up the stack for the main task
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the task scheduler
    call setup_scheduler

    ; Print a message indicating the scheduler is running
    mov si, scheduler_msg
    call print_string

    ; Start the first task
    call switch_to_task1

    ; Halt the CPU (infinite loop)
    hlt

scheduler_msg db 'Task Scheduler initialized!', 0

setup_scheduler:
    ; Initialize the current task
    mov qword [current_task], 1
    ret

switch_to_task1:
    ; Save the current task state (assuming main task state is saved elsewhere)
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push rsp

    ; Load the task 1 stack
    lea rsp, [task1_stack + 4096]

    ; Set up the task 1 environment
    call task1

    ; Restore the saved task state
    pop rsp
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax

    ret

switch_to_task2:
    ; Save the current task state (assuming main task state is saved elsewhere)
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push rsp

    ; Load the task 2 stack
    lea rsp, [task2_stack + 4096]

    ; Set up the task 2 environment
    call task2

    ; Restore the saved task state
    pop rsp
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax

    ret

task1:
    ; Task 1 code
    mov si, task1_msg
    call print_string

    ; Simulate task execution with a loop
    .loop1:
        nop
        nop
        nop
        jmp .loop1

task2:
    ; Task 2 code
    mov si, task2_msg
    call print_string

    ; Simulate task execution with a loop
    .loop2:
        nop
        nop
        nop
        jmp .loop2

task1_msg db 'Task 1 running!', 0
task2_msg db 'Task 2 running!', 0

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


7.asm
;Content of 7.asm
; System Call Interface: Allows user programs to request kernel services

BITS 64
section .bss
align 16
syscall_table:
    dq syscall_print    ; System call 0: print a message
    ; Additional system calls can be added here

section .text
global _start
extern user_program

_start:
    ; Set up the stack for the main task
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the system call interface
    call setup_syscall_interface

    ; Print a message indicating the system call interface is running
    mov si, syscall_msg
    call print_string

    ; Halt the CPU (infinite loop)
    hlt

syscall_msg db 'System Call Interface initialized!', 0

setup_syscall_interface:
    ; Set up the IDT entry for the system call interrupt (int 0x80)
    lea rax, [isr_syscall]
    mov [idt + 0x80 * 16 + 0], ax  ; Offset bits 0-15
    mov [idt + 0x80 * 16 + 6], ax  ; Offset bits 16-31
    mov byte [idt + 0x80 * 16 + 5], 0x8E  ; Present, DPL 0, 32-bit interrupt gate

    ; Load the IDT
    lidt [idt_ptr]
    ret

isr_syscall:
    pusha
    cli

    ; Get the system call number from RAX
    mov rax, [rsp + 8 * 8]

    ; Get the address of the system call handler from the table
    shl rax, 3
    lea rbx, [syscall_table]
    add rbx, rax
    call qword [rbx]

    sti
    popa
    iret

syscall_print:
    ; System call handler for printing a message
    mov si, syscall_print_msg
    call print_string
    ret

syscall_print_msg db 'System call print executed!', 0

idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

idt_ptr:
    dw idt_end - idt - 1
    dq idt

idt_end:

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


8.asm
;Content of 8.asm
; Page Table Initialization: Sets up virtual memory paging

BITS 64
section .bss
align 4096
pml4_table:
    resq 512  ; PML4 table (Page Map Level 4)

pdpt_table:
    resq 512  ; PDPT (Page Directory Pointer Table)

pd_table:
    resq 512  ; Page Directory Table

pt_table:
    resq 512  ; Page Table

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize page tables
    call setup_paging

    ; Print a message indicating paging is enabled
    mov si, paging_msg
    call print_string

    ; Halt the CPU (infinite loop)
    hlt

paging_msg db 'Paging enabled!', 0

setup_paging:
    ; Clear all page tables
    xor rax, rax
    mov rdi, pml4_table
    mov rcx, 512
    rep stosq

    mov rdi, pdpt_table
    mov rcx, 512
    rep stosq

    mov rdi, pd_table
    mov rcx, 512
    rep stosq

    mov rdi, pt_table
    mov rcx, 512
    rep stosq

    ; Set up identity mapping for the first 2 MB
    ; Map virtual address 0x00000000 to physical address 0x00000000
    ; PML4
    mov rax, pdpt_table | 0x3
    mov [pml4_table], rax

    ; PDPT
    mov rax, pd_table | 0x3
    mov [pdpt_table], rax

    ; Page Directory
    mov rax, pt_table | 0x3
    mov [pd_table], rax

    ; Page Table
    mov rax, 0x00000000 | 0x83  ; Present, Read/Write, 2 MB page
    mov [pt_table], rax

    ; Load the address of the PML4 table into CR3
    lea rax, [pml4_table]
    mov cr3, rax

    ; Enable paging by setting the PG bit in CR0
    mov eax, cr0
    or eax, 0x80000000  ; Set PG bit
    mov cr0, eax

    ; Enable the PAE bit in CR4
    mov eax, cr4
    or eax, 0x00000020  ; Set PAE bit
    mov cr4, eax

    ret

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


9.asm
;Content of 9.asm
; Kernel Panic Handler: Handles fatal kernel errors

BITS 64
section .bss
align 16
idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

section .data
idt_ptr:
    dw idt_end - idt - 1
    dq idt

section .text
global _start
extern trigger_panic

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the IDT
    call setup_idt

    ; Print a message indicating the kernel is running
    mov si, kernel_msg
    call print_string

    ; Simulate a kernel panic (for demonstration purposes)
    call trigger_panic

    ; Halt the CPU (infinite loop)
    hlt

kernel_msg db 'Kernel running. Ready to handle panic.', 0

trigger_panic:
    ; Simulate a kernel panic by invoking the panic handler
    int 0x21
    ret

panic_handler:
    pusha
    cli

    ; Print the kernel panic message
    mov si, panic_msg
    call print_string

    ; Optionally, log some diagnostic information here
    ; For example, you can save the state of registers or memory locations

    ; Halt the CPU
    hlt

panic_msg db 'KERNEL PANIC: System halted!', 0

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

setup_idt:
    ; Set up the IDT entry for the kernel panic interrupt (int 0x21)
    lea rax, [panic_handler]
    mov word [idt + 0x21 * 16 + 0], ax  ; Offset bits 0-15
    mov word [idt + 0x21 * 16 + 6], 0x08  ; Kernel code segment selector
    mov byte [idt + 0x21 * 16 + 5], 0x8E  ; Present, DPL 0, 64-bit interrupt gate
    shr rax, 16
    mov word [idt + 0x21 * 16 + 8], ax  ; Offset bits 16-31
    mov dword [idt + 0x21 * 16 + 12], 0  ; Reserved

    ; Load the IDT
    lidt [idt_ptr]
    ret

idt_end:


10.asm
;Content of 10.asm
; Basic I/O System: Manages basic input/output operations

BITS 64
section .bss
align 16
kbd_buffer:
    resb 256  ; Keyboard input buffer

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the IDT
    call setup_idt

    ; Enable interrupts
    sti

    ; Print a message indicating the system is running
    mov si, sys_msg
    call print_string

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

sys_msg db 'System running. Basic I/O initialized.', 0

; Keyboard interrupt handler (IRQ1)
kbd_handler:
    pusha
    cli

    ; Read the scancode from the keyboard controller
    in al, 0x60
    mov [kbd_buffer], al

    ; Print the scancode for demonstration purposes
    mov si, kbd_msg
    call print_string

    ; Acknowledge the interrupt
    mov al, 0x20
    out 0x20, al

    sti
    popa
    iret

kbd_msg db 'Key pressed! Scancode: ', 0

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

setup_idt:
    ; Set up the IDT entry for the keyboard interrupt (IRQ1, int 0x21)
    lea rax, [kbd_handler]
    mov word [idt + 0x21 * 16 + 0], ax  ; Offset bits 0-15
    mov word [idt + 0x21 * 16 + 6], 0x08  ; Kernel code segment selector
    mov byte [idt + 0x21 * 16 + 5], 0x8E  ; Present, DPL 0, 64-bit interrupt gate
    shr rax, 16
    mov word [idt + 0x21 * 16 + 8], ax  ; Offset bits 16-31
    mov dword [idt + 0x21 * 16 + 12], 0  ; Reserved

    ; Load the IDT
    lidt [idt_ptr]
    ret

section .bss
align 16
idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

idt_ptr:
    dw idt_end - idt - 1
    dq idt

idt_end:


11.asm
;Content of 11.asm
; Keyboard Driver: Manages keyboard input

BITS 64
section .bss
align 16
kbd_buffer:
    resb 256  ; Keyboard input buffer
kbd_index:
    resb 1    ; Index for the buffer

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the IDT
    call setup_idt

    ; Enable interrupts
    sti

    ; Print a message indicating the keyboard driver is running
    mov si, kbd_driver_msg
    call print_string

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

kbd_driver_msg db 'Keyboard Driver initialized.', 0

; Keyboard interrupt handler (IRQ1)
kbd_handler:
    pusha
    cli

    ; Read the scancode from the keyboard controller
    in al, 0x60

    ; Store the scancode in the keyboard buffer
    mov [kbd_buffer + kbd_index], al
    inc byte [kbd_index]

    ; Convert scancode to ASCII and print for demonstration purposes
    call scancode_to_ascii
    mov si, kbd_msg
    call print_string
    mov al, [kbd_buffer + kbd_index - 1]
    call print_char

    ; Acknowledge the interrupt
    mov al, 0x20
    out 0x20, al

    sti
    popa
    iret

kbd_msg db 'Key pressed: ', 0

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

scancode_to_ascii:
    ; Example: Simple US QWERTY keyboard map for demonstration
    movzx eax, byte [kbd_buffer + kbd_index - 1]
    cmp eax, 0x02  ; '1'
    je .key_1
    cmp eax, 0x03  ; '2'
    je .key_2
    cmp eax, 0x1E  ; 'a'
    je .key_a
    cmp eax, 0x30  ; 'b'
    je .key_b
    jmp .unknown

.key_1:
    mov al, '1'
    jmp .done

.key_2:
    mov al, '2'
    jmp .done

.key_a:
    mov al, 'a'
    jmp .done

.key_b:
    mov al, 'b'
    jmp .done

.unknown:
    mov al, '?'

.done:
    ret

setup_idt:
    ; Set up the IDT entry for the keyboard interrupt (IRQ1, int 0x21)
    lea rax, [kbd_handler]
    mov word [idt + 0x21 * 16 + 0], ax  ; Offset bits 0-15
    mov word [idt + 0x21 * 16 + 6], 0x08  ; Kernel code segment selector
    mov byte [idt + 0x21 * 16 + 5], 0x8E  ; Present, DPL 0, 64-bit interrupt gate
    shr rax, 16
    mov word [idt + 0x21 * 16 + 8], ax  ; Offset bits 16-31
    mov dword [idt + 0x21 * 16 + 12], 0  ; Reserved

    ; Load the IDT
    lidt [idt_ptr]
    ret

section .bss
align 16
idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

idt_ptr:
    dw idt_end - idt - 1
    dq idt

idt_end:


12.asm
;Content of 12.asm
; Mouse Driver: Manages mouse input

BITS 64
section .bss
align 16
mouse_buffer:
    resb 256  ; Mouse input buffer
mouse_index:
    resb 1    ; Index for the buffer
mouse_packet:
    resb 3    ; Mouse data packet

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the IDT
    call setup_idt

    ; Enable mouse
    call enable_mouse

    ; Enable interrupts
    sti

    ; Print a message indicating the mouse driver is running
    mov si, mouse_driver_msg
    call print_string

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

mouse_driver_msg db 'Mouse Driver initialized.', 0

; Mouse interrupt handler (IRQ12)
mouse_handler:
    pusha
    cli

    ; Read the byte from the mouse data port
    in al, 0x60

    ; Store the byte in the mouse packet buffer
    mov [mouse_packet + mouse_index], al
    inc byte [mouse_index]
    cmp byte [mouse_index], 3
    jne .done

    ; Reset the buffer index
    xor byte [mouse_index], byte [mouse_index]

    ; Process the mouse packet
    call process_mouse_packet

.done:
    ; Acknowledge the interrupt
    mov al, 0x20
    out 0xA0, al  ; Acknowledge the secondary PIC
    out 0x20, al  ; Acknowledge the primary PIC

    sti
    popa
    iret

process_mouse_packet:
    ; Process the 3-byte mouse packet
    ; Mouse packet format:
    ; byte 0: [Y sign, X sign, Y overflow, X overflow, 1, Middle Btn, Right Btn, Left Btn]
    ; byte 1: X movement
    ; byte 2: Y movement

    ; For demonstration, print the packet bytes
    mov si, packet_msg
    call print_string

    movzx eax, byte [mouse_packet]
    call print_hex

    mov si, space
    call print_string

    movzx eax, byte [mouse_packet + 1]
    call print_hex

    mov si, space
    call print_string

    movzx eax, byte [mouse_packet + 2]
    call print_hex

    mov si, newline
    call print_string

    ret

packet_msg db 'Mouse packet: ', 0
space db ' ', 0
newline db 0x0D, 0x0A, 0

; Print a hexadecimal value
print_hex:
    push rbx
    push rcx
    push rdx

    mov rbx, rax
    mov rcx, 4  ; Number of hex digits to print

    .print_loop:
        rol rbx, 4
        mov al, bl
        and al, 0x0F
        cmp al, 10
        jl .num
        add al, 'A' - 10
        jmp .print

    .num:
        add al, '0'

    .print:
        call print_char
        loop .print_loop

    pop rdx
    pop rcx
    pop rbx
    ret

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

; Print a string
print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

setup_idt:
    ; Set up the IDT entry for the mouse interrupt (IRQ12, int 0x2C)
    lea rax, [mouse_handler]
    mov word [idt + 0x2C * 16 + 0], ax  ; Offset bits 0-15
    mov word [idt + 0x2C * 16 + 6], 0x08  ; Kernel code segment selector
    mov byte [idt + 0x2C * 16 + 5], 0x8E  ; Present, DPL 0, 64-bit interrupt gate
    shr rax, 16
    mov word [idt + 0x2C * 16 + 8], ax  ; Offset bits 16-31
    mov dword [idt + 0x2C * 16 + 12], 0  ; Reserved

    ; Load the IDT
    lidt [idt_ptr]
    ret

enable_mouse:
    ; Enable the auxiliary mouse device
    mov al, 0xA8
    out 0x64, al
    call mouse_wait
    ; Enable the interrupts
    mov al, 0x20
    out 0x64, al
    call mouse_wait
    mov al, 0x47
    out 0x60, al
    call mouse_wait
    ret

mouse_wait:
    ; Wait for the mouse controller to be ready
    .wait:
        in al, 0x64
        test al, 0x02
        jnz .wait
    ret

section .bss
align 16
idt:
    resb 256 * 16  ; IDT with 256 entries, each 16 bytes

idt_ptr:
    dw idt_end - idt - 1
    dq idt

idt_end:


13.asm
;Content of 13.asm
; Display Driver: Manages video output

BITS 64
section .bss

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the display driver
    call setup_display

    ; Print a message indicating the display driver is running
    mov si, display_driver_msg
    call print_string

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

display_driver_msg db 'Display Driver initialized.', 0

; Setup display
setup_display:
    ; Set video mode to 80x25 text mode (BIOS function 0x00 of int 0x10)
    mov ax, 0x0003
    int 0x10
    ret

; Print a single character at the current cursor position
print_char:
    mov ah, 0x0E
    int 0x10
    ret

; Print a string at the current cursor position
print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

; Move the cursor to a specific position
move_cursor:
    ; Input: BX = row, DX = column
    mov ah, 0x02
    mov bh, 0x00
    int 0x10
    ret

; Clear the screen
clear_screen:
    ; Scroll the entire screen up by 25 lines to clear it (BIOS function 0x06 of int 0x10)
    mov ah, 0x06
    mov al, 0
    mov bh, 0x07
    mov cx, 0
    mov dx, 0x184F
    int 0x10
    ret


14.asm
;Content of 14.asm
; Disk Driver: Manages hard disk operations

BITS 64
section .bss
align 16
buffer:
    resb 512  ; Buffer for disk data

section .data
drives_info:
    db 0      ; Number of drives detected

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the disk driver
    call setup_disk_driver

    ; Print a message indicating the disk driver is running
    mov si, disk_driver_msg
    call print_string

    ; Read a sector from the first disk
    mov bx, buffer       ; Buffer to store data
    mov dl, 0x80         ; Drive number (0x80 for first hard disk)
    mov dh, 0            ; Head
    mov ch, 0            ; Cylinder
    mov cl, 2            ; Sector number (start from 1, so 2 is the second sector)
    call read_sector

    ; Print the first byte of the buffer as a test
    mov al, [buffer]
    call print_char

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

disk_driver_msg db 'Disk Driver initialized.', 0

; Read a sector from the disk
read_sector:
    ; Input: BX = buffer, DL = drive, DH = head, CH = cylinder, CL = sector
    push bx
    push dx
    push cx

    ; Set up disk read parameters
    mov ah, 0x02       ; BIOS function to read sectors
    mov al, 1          ; Number of sectors to read
    int 0x13           ; BIOS interrupt for disk services

    ; Check for errors
    jc .error

    ; Restore registers and return
    pop cx
    pop dx
    pop bx
    ret

.error:
    ; Handle read error (for simplicity, we'll just print an error message and halt)
    mov si, read_error_msg
    call print_string
    hlt

read_error_msg db 'Disk read error!', 0

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

; Print a string
print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret

setup_disk_driver:
    ; Detect available drives
    mov ah, 0x00       ; BIOS function to reset disk system
    int 0x13           ; BIOS interrupt for disk services
    jc .error          ; Jump if there is an error

    ; Detect hard disks
    mov dl, 0x80       ; Start with the first hard disk (0x80)
    call detect_drive
    jnc .next_drive

    ; No drives detected
    mov si, no_drives_msg
    call print_string
    hlt

.next_drive:
    inc byte [drives_info]  ; Increment the number of drives detected
    ; Check for more drives if necessary
    ; Add logic for detecting additional drives if needed

    ret

detect_drive:
    ; Check if a drive exists
    mov ah, 0x15       ; BIOS function to get drive type
    int 0x13           ; BIOS interrupt for disk services
    jc .no_drive       ; Jump if there is an error
    test ah, ah        ; Check if drive type is non-zero
    jnz .drive_exists

.no_drive:
    stc                ; Set carry flag to indicate no drive
    ret

.drive_exists:
    clc                ; Clear carry flag to indicate drive exists
    ret

no_drives_msg db 'No drives detected!', 0


15.asm
;Content of 15.asm
; Network Driver: Manages network interface operations

BITS 64
section .bss
align 16
rx_buffer:
    resb 2048  ; Buffer for received data
tx_buffer:
    resb 2048  ; Buffer for data to be transmitted

section .data
net_driver_msg db 'Network Driver initialized.', 0

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the network driver
    call setup_network_driver

    ; Print a message indicating the network driver is running
    mov si, net_driver_msg
    call print_string

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

; Network Interface Initialization
setup_network_driver:
    ; Any necessary network interface initialization code goes here
    ; For example, setting up the network card, configuring MAC address, etc.
    ; This is highly hardware-specific and would typically involve writing to
    ; the network card's I/O ports or memory-mapped registers.

    ; Placeholder for hardware-specific initialization
    ; Initialize the network card (this is just a template and must be filled with actual initialization code)
    ; Example: Configure MAC address, initialize buffers, set up DMA, etc.

    ; Initialize Network Interface
    ; Note: This is hardware specific and typically involves accessing network card registers
    ; Assuming a generic network card initialization sequence for demonstration

    ; Reset network card
    ; out dx, al ; (example) write to I/O port of network card to reset

    ; Configure MAC address
    ; mov al, [mac_address]
    ; out dx, al ; (example) write MAC address bytes to I/O port

    ; Initialize RX and TX buffers
    ; out dx, [rx_buffer]
    ; out dx, [tx_buffer]

    ; Enable network card
    ; out dx, al ; (example) write to enable network card

    ret

; Send Data
send_data:
    ; Input: BX = buffer, CX = length
    ; Sends the data in the buffer over the network
    ; This is highly hardware-specific and would typically involve writing to
    ; the network card's I/O ports or memory-mapped registers.

    ; Send data to network interface
    ; Placeholder for hardware-specific send operation
    ; out dx, [bx] ; (example) write data to I/O port of network card

    ; Wait for transmission to complete
    ; Placeholder for checking transmission status
    ; in al, dx ; (example) read status from I/O port of network card
    ; test al, 0x01
    ; jz .send_complete

    ; .send_complete:
    ret

; Receive Data
receive_data:
    ; Output: BX = buffer, CX = length
    ; Receives data from the network into the buffer
    ; This is highly hardware-specific and would typically involve reading from
    ; the network card's I/O ports or memory-mapped registers.

    ; Receive data from network interface
    ; Placeholder for hardware-specific receive operation
    ; in dx, [rx_buffer] ; (example) read data from I/O port of network card

    ; Check for received data
    ; Placeholder for checking reception status
    ; in al, dx ; (example) read status from I/O port of network card
    ; test al, 0x01
    ; jz .receive_complete

    ; Copy received data to buffer
    ; rep movsb ; copy data from rx_buffer to user buffer

    ; .receive_complete:
    ret

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

; Print a string
print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


16.asm
;Content of 16.asm
; USB Driver: Manages USB device interactions

BITS 64
section .bss
align 16
usb_buffer:
    resb 2048  ; Buffer for USB data

section .data
usb_driver_msg db 'USB Driver initialized.', 0
usb_device_detected_msg db 'USB device detected.', 0
usb_no_device_msg db 'No USB device detected.', 0

section .text
global _start

_start:
    ; Set up the stack
    mov ax, 0x9000
    mov ss, ax
    mov sp, 0xFFFF

    ; Set up segments
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; Initialize the USB driver
    call setup_usb_driver

    ; Print a message indicating the USB driver is running
    mov si, usb_driver_msg
    call print_string

    ; Detect USB devices
    call detect_usb_device

    ; Main loop
    .main_loop:
        hlt
        jmp .main_loop

; Setup USB Driver
setup_usb_driver:
    ; Initialize the USB controller
    ; This typically involves hardware-specific operations such as setting up
    ; the USB controller, configuring endpoints, etc.

    ; Example: Reset the USB controller, configure endpoints, enable interrupts, etc.
    ; Note: These operations are hardware-specific and require the correct
    ; I/O port addresses and control commands for the USB controller.

    ; Reset USB controller
    ; mov dx, USB_CONTROL_PORT
    ; mov al, USB_RESET_COMMAND
    ; out dx, al

    ; Configure USB controller
    ; mov al, USB_CONFIG_DATA
    ; out dx, al

    ; Enable USB controller
    ; mov al, USB_ENABLE_COMMAND
    ; out dx, al

    ret

; USB Data Transfer
usb_transfer:
    ; Input: BX = buffer, CX = length, DX = endpoint
    ; Performs a data transfer over USB
    ; This is highly hardware-specific and would typically involve writing to
    ; the USB controller's I/O ports or memory-mapped registers.

    ; Example: Write data to the USB endpoint
    ; mov dx, USB_DATA_PORT
    ; rep outsb

    ; Wait for transfer to complete
    ; in al, USB_STATUS_PORT
    ; test al, USB_TRANSFER_COMPLETE
    ; jz .usb_transfer_complete

    ; .usb_transfer_complete:
    ret

; USB Device Detection
detect_usb_device:
    ; Detect connected USB devices
    ; This is highly hardware-specific and would typically involve reading from
    ; the USB controller's I/O ports or memory-mapped registers.

    ; Example: Check the USB status register for connected devices
    ; in al, USB_STATUS_PORT
    ; test al, USB_DEVICE_CONNECTED
    ; jz .no_device

    ; Device detected
    mov si, usb_device_detected_msg
    call print_string
    jmp .device_detected

.no_device:
    mov si, usb_no_device_msg
    call print_string

.device_detected:
    ret

; Print a single character
print_char:
    mov ah, 0x0E
    int 0x10
    ret

; Print a string
print_string:
    mov ah, 0x0E
.repeat:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .repeat
.done:
    ret


17.asm
;Content of 17.asm
section .bss
    sound_state resb 1

section .data
    freq dw 1193180 / 440 ; Frequency for the beep (440Hz, standard A)

section .text
global _start

_start:
    ; Save initial state
    cli
    push eax
    push ebx
    push ecx
    push edx

    ; Initialize PIT for sound generation
    mov al, 0xB6           ; Set the command byte
    out 0x43, al           ; Send command to PIT control port

    ; Set frequency
    mov eax, [freq]        ; Frequency value
    out 0x42, al           ; Send low byte to channel 2 data port
    mov al, ah
    out 0x42, al           ; Send high byte to channel 2 data port

    ; Enable the speaker
    in al, 0x61            ; Read current state of port 0x61
    or al, 0x03            ; Set bits 0 and 1 to enable the speaker
    out 0x61, al           ; Write back to port 0x61

    ; Store sound state as active
    mov byte [sound_state], 1

    ; Generate sound for a while
    call delay

    ; Disable the speaker
    in al, 0x61            ; Read current state of port 0x61
    and al, 0xFC           ; Clear bits 0 and 1 to disable the speaker
    out 0x61, al           ; Write back to port 0x61

    ; Store sound state as inactive
    mov byte [sound_state], 0

    ; Restore state
    pop edx
    pop ecx
    pop ebx
    pop eax
    sti

    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

delay:
    ; Simple delay loop
    mov ecx, 10000000
.loop:
    loop .loop
    ret


18.asm
;Content of 18.asm
section .bss
    pci_device_count resb 1

section .data
    pci_config_address equ 0xCF8
    pci_config_data equ 0xCFC

section .text
global _start

_start:
    ; Initialize PCI device count
    xor eax, eax
    mov [pci_device_count], al

    ; Scan all buses, devices, and functions
    mov ecx, 0x00    ; Bus number
.next_bus:
    mov edx, 0x00    ; Device number
.next_device:
    mov esi, 0x00    ; Function number
.next_function:
    ; Construct the PCI configuration address
    mov eax, ecx
    shl eax, 16
    or eax, edx
    shl eax, 11
    or eax, esi
    shl eax, 8
    or eax, 0x80000000 ; Enable bit
    mov edi, eax

    ; Read the vendor ID
    out dx, eax
    mov eax, pci_config_address
    mov edx, pci_config_data
    in eax, dx

    ; Check if vendor ID is valid
    cmp ax, 0xFFFF
    je .next_function_check

    ; Increment the PCI device count
    mov al, [pci_device_count]
    inc al
    mov [pci_device_count], al

.next_function_check:
    inc esi
    cmp esi, 0x08
    jne .next_function

    inc edx
    cmp edx, 0x20
    jne .next_device

    inc ecx
    cmp ecx, 0x100
    jne .next_bus

    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Auxiliary functions and labels can be added here if needed


19.asm
;Content of 19.asm
section .data
    PM1a_CNT_BLK equ 0x4004  ; Example ACPI PM1a control block address
    ACPI_PWR_STATE_STR db 'Power State: ', 0
    SLEEP_MSG db 'Entering sleep mode...', 0

section .bss
    power_state resb 1

section .text
global _start

_start:
    ; Initialize power state
    xor eax, eax
    mov [power_state], al

    ; Read power state
    in eax, PM1a_CNT_BLK
    shr eax, 10             ; Shift right to get SLP_TYP bits
    and eax, 0x07           ; Mask to get only the SLP_TYP field
    mov [power_state], al

    ; Print power state
    mov esi, ACPI_PWR_STATE_STR
    call print_string
    mov al, [power_state]
    add al, '0'             ; Convert to ASCII
    mov [power_state], al
    mov esi, power_state
    call print_string

    ; Enter sleep mode if power state is 1 (example condition)
    cmp byte [power_state], '1'
    jne .skip_sleep

    ; Print sleep message
    mov esi, SLEEP_MSG
    call print_string

    ; Set system to sleep mode (example: S3 state)
    mov eax, 0x1C04         ; SLP_EN + SLP_TYP (S3)
    out PM1a_CNT_BLK, eax

.skip_sleep:
    ; Exit
    mov eax, 60             ; syscall number for exit
    xor edi, edi            ; exit code 0
    syscall

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


20.asm
;Content of 20.asm
section .data
    bios_version_str db 'BIOS Version: ', 0
    error_msg db 'BIOS Read Error', 0

section .bss
    bios_version resb 32

section .text
global _start

_start:
    ; Initialize BIOS data area address for BIOS version
    mov edx, 0xF0000       ; Base address of BIOS (segment F000h)
    mov ecx, 0xFFFF        ; Size to search

    ; Call BIOS function to get BIOS version
    call get_bios_version

    ; Check if BIOS version was found
    cmp byte [bios_version], 0
    je .error

    ; Print BIOS version
    mov esi, bios_version_str
    call print_string
    mov esi, bios_version
    call print_string

    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

.error:
    ; Print error message and exit
    mov esi, error_msg
    call print_string
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

get_bios_version:
    ; Search for BIOS version string in BIOS data area
    mov esi, edx           ; Start address of BIOS
    mov edi, bios_version  ; Destination for BIOS version string
    cld                    ; Clear direction flag for string operations

    ; Search loop
    .search:
        lodsb              ; Load byte from [esi] into al
        cmp al, 'B'        ; Check for 'B'
        jne .next          ; Not 'B', continue searching
        ; Check for "BIOS"
        mov al, byte [esi]
        cmp al, 'I'
        jne .next
        mov al, byte [esi+1]
        cmp al, 'O'
        jne .next
        mov al, byte [esi+2]
        cmp al, 'S'
        jne .next
        ; Found "BIOS", copy version string
        mov ecx, 32        ; Max length of BIOS version string
        rep movsb          ; Copy string
        jmp .done

    .next:
        inc esi
        loop .search

    ; No BIOS version found
    xor eax, eax
    stosb                  ; Store null terminator
    .done:
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


21.asm
;Content of 21.asm
section .data
    floppy_base         equ 0x3F0   ; Base I/O port address for the floppy disk controller
    boot_sector_lba     equ 0         ; LBA of the boot sector
    sector_size         equ 512      ; Size of a sector in bytes

    read_error_msg      db 'Read Error', 0
    success_msg         db 'Read Successful', 0

section .bss
    buffer resb sector_size   ; Buffer to store the sector data

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read the boot sector
    mov eax, boot_sector_lba
    call read_sector

    ; Check if the read was successful
    cmp eax, 0
    jne .read_error

    ; Print success message
    mov esi, success_msg
    call print_string
    jmp .done

.read_error:
    ; Print read error message
    mov esi, read_error_msg
    call print_string

.done:
    ; Exit
    mov eax, 60           ; syscall number for exit
    xor edi, edi          ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


22.asm
;Content of 22.asm
section .data
    floppy_base         equ 0x3F0   ; Base I/O port address for the floppy disk controller
    boot_sector_lba     equ 0         ; LBA of the boot sector
    sector_size         equ 512      ; Size of a sector in bytes
    file_name           db 'TEST.TXT', 0

    read_error_msg      db 'Read Error', 0
    write_error_msg     db 'Write Error', 0
    success_msg         db 'Operation Successful', 0

section .bss
    buffer resb sector_size   ; Buffer to store the sector data
    file_content resb sector_size ; Buffer for file content

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read a file
    call read_file
    cmp eax, 0
    jne .read_error

    ; Write a file
    call write_file
    cmp eax, 0
    jne .write_error

    ; Print success message
    mov esi, success_msg
    call print_string
    jmp .done

.read_error:
    ; Print read error message
    mov esi, read_error_msg
    call print_string
    jmp .done

.write_error:
    ; Print write error message
    mov esi, write_error_msg
    call print_string
    jmp .done

.done:
    ; Exit
    mov eax, 60           ; syscall number for exit
    xor edi, edi          ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a file from the floppy disk
read_file:
    ; Locate the file (simplified for demonstration)
    ; Assume the file is in the root directory and starts at sector 19

    mov eax, 19            ; Sector number of the file
    call read_sector

    ; Check for errors
    cmp eax, 0
    jne .error

    ; Copy file content to buffer
    mov esi, buffer
    mov edi, file_content
    mov ecx, sector_size
    rep movsb

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to write a file to the floppy disk
write_file:
    ; Assume the file is in the root directory and starts at sector 19

    mov eax, 19            ; Sector number to write to
    mov esi, file_content
    mov edi, buffer
    mov ecx, sector_size
    rep movsb

    call write_sector

    ; Check for errors
    cmp eax, 0
    jne .error

    ; Successful write
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to write a sector to the floppy disk
write_sector:
    ; Set up the DMA for floppy write
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x4A          ; Single transfer, write, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC5          ; Write sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to write
    out dx, al

    ; Wait for the write to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful write
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


23.asm
;Content of 23.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    root_dir_lba        equ 19          ; LBA of the root directory in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    dir_entry_size      equ 32          ; Size of a directory entry in bytes

    read_error_msg      db 'Read Error', 0
    success_msg         db 'Directory Listing:', 0
    newline             db 13, 10, 0    ; Newline characters

section .bss
    buffer resb sector_size   ; Buffer to store the sector data

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read the root directory
    mov eax, root_dir_lba
    call read_sector
    cmp eax, 0
    jne .read_error

    ; Print directory listing
    mov esi, success_msg
    call print_string

    mov esi, buffer
    mov ecx, sector_size / dir_entry_size
.next_entry:
    call print_dir_entry
    add esi, dir_entry_size
    loop .next_entry

    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

.read_error:
    ; Print read error message
    mov esi, read_error_msg
    call print_string
    jmp .done

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to print a directory entry
print_dir_entry:
    ; Check if the entry is valid
    cmp byte [esi], 0
    je .done
    cmp byte [esi], 0xE5
    je .done
    cmp byte [esi + 11], 0x0F  ; Check for long file name
    je .done

    ; Print the file name (8 bytes) and extension (3 bytes)
    mov ecx, 8
.print_name:
    lodsb
    cmp al, ' '
    je .skip_space
    call print_char
.skip_space:
    loop .print_name
    mov al, '.'
    call print_char
    mov ecx, 3
.print_ext:
    lodsb
    cmp al, ' '
    je .skip_space_ext
    call print_char
.skip_space_ext:
    loop .print_ext

    ; Print newline
    mov esi, newline
    call print_string

.done:
    ret

print_char:
    mov ah, 0x0E
    int 0x10
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    call print_char
    jmp print_string
.done:
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret


24.asm
;Content of 24.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    boot_sector_lba     equ 0           ; LBA of the boot sector in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    fat12_signature     db 'FAT12', 0

    mount_error_msg     db 'Mount Error', 0
    mount_success_msg   db 'Mount Successful', 0

section .bss
    buffer resb sector_size   ; Buffer to store the sector data

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read the boot sector
    mov eax, boot_sector_lba
    call read_sector
    cmp eax, 0
    jne .mount_error

    ; Verify the FAT12 signature
    mov esi, buffer
    add esi, 54             ; Offset to FAT12 signature in boot sector
    mov edi, fat12_signature
    mov ecx, 5              ; Length of FAT12 signature
    repe cmpsb
    jne .mount_error

    ; Print mount success message
    mov esi, mount_success_msg
    call print_string
    jmp .done

.mount_error:
    ; Print mount error message
    mov esi, mount_error_msg
    call print_string

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


25.asm
;Content of 25.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    root_dir_lba        equ 19          ; LBA of the root directory in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    dir_entry_size      equ 32          ; Size of a directory entry in bytes
    file_name           db 'TEST    TXT', 0 ; 11-byte file name (8.3 format)

    permission_error_msg db 'Permission Denied', 0
    permission_success_msg db 'Permission Granted', 0

section .bss
    buffer resb sector_size   ; Buffer to store the sector data
    permissions resb 1        ; Buffer to store file permissions

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read the root directory
    mov eax, root_dir_lba
    call read_sector
    cmp eax, 0
    jne .permission_error

    ; Check file permissions
    mov esi, buffer
    mov ecx, sector_size / dir_entry_size
    mov edi, file_name
    call check_permissions
    cmp eax, 0
    jne .permission_error

    ; Print permission granted message
    mov esi, permission_success_msg
    call print_string
    jmp .done

.permission_error:
    ; Print permission error message
    mov esi, permission_error_msg
    call print_string

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to check file permissions
check_permissions:
    ; Iterate through directory entries
    .next_entry:
        cmp byte [esi], 0
        je .not_found
        cmp byte [esi], 0xE5
        je .skip_entry
        cmp byte [esi + 11], 0x0F  ; Check for long file name
        je .skip_entry

        ; Compare file name
        mov ecx, 11
        repe cmpsb
        jne .skip_entry

        ; File found, check permissions
        ; Assuming file attribute byte is at offset 0x0B (simplified)
        mov al, [esi + 11]
        mov [permissions], al

        ; Check read permission (example: read permission if not read-only)
        test al, 0x01
        jz .found  ; No read-only attribute, permission granted

        ; Otherwise, permission denied
        mov eax, 1
        ret

    .skip_entry:
        add esi, dir_entry_size
        loop .next_entry

    .not_found:
        ; File not found, permission denied
        mov eax, 1
        ret

    .found:
        ; Permission granted
        xor eax, eax
        ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


26.asm
;Content of 26.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    boot_sector_lba     equ 0           ; LBA of the boot sector in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    cache_size          equ 512         ; Size of the cache in bytes

    cache_hit_msg       db 'Cache Hit', 0
    cache_miss_msg      db 'Cache Miss', 0
    read_error_msg      db 'Read Error', 0

section .bss
    cache resb cache_size   ; Cache buffer to store a sector
    cache_lba resd 1        ; LBA of the cached sector

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Example: Read sector 1 and cache it
    mov eax, 1              ; Sector number to read
    call read_and_cache_sector
    cmp eax, 0
    jne .read_error

    ; Example: Access sector 1 (should hit the cache)
    mov eax, 1
    call access_sector
    cmp eax, 0
    je .cache_hit

    ; Print cache miss message
    mov esi, cache_miss_msg
    call print_string
    jmp .done

.cache_hit:
    ; Print cache hit message
    mov esi, cache_hit_msg
    call print_string
    jmp .done

.read_error:
    ; Print read error message
    mov esi, read_error_msg
    call print_string

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read and cache a sector from the floppy disk
read_and_cache_sector:
    ; Read the sector into the cache
    mov [cache_lba], eax
    call read_sector_to_cache
    cmp eax, 0
    jne .error

    ; Successful read and cache
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to access a sector, using the cache if possible
access_sector:
    ; Check if the sector is in the cache
    cmp [cache_lba], eax
    je .hit

    ; Cache miss, read the sector
    call read_and_cache_sector
    cmp eax, 0
    jne .error

    ; Cache miss but read successful
    xor eax, eax
    inc eax
    ret

.hit:
    ; Cache hit
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to read a sector from the floppy disk to the cache
read_sector_to_cache:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, cache
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


27.asm
;Content of 27.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    root_dir_lba        equ 19          ; LBA of the root directory in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    dir_entry_size      equ 32          ; Size of a directory entry in bytes
    file_name           db 'TEST    TXT', 0 ; 11-byte file name (8.3 format)

    lock_error_msg      db 'File Locked', 0
    unlock_error_msg    db 'File Unlock Failed', 0
    lock_success_msg    db 'File Locked Successfully', 0
    unlock_success_msg  db 'File Unlocked Successfully', 0
    read_error_msg      db 'Read Error', 0
    not_found_msg       db 'File Not Found', 0

section .bss
    buffer resb sector_size   ; Buffer to store the sector data
    lock_state resb 1         ; Buffer to store lock state (0: unlocked, 1: locked)

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Example: Lock the file
    call lock_file
    cmp eax, 0
    jne .lock_error

    ; Perform file operations here
    ; ...

    ; Example: Unlock the file
    call unlock_file
    cmp eax, 0
    jne .unlock_error

    ; Print lock success message
    mov esi, lock_success_msg
    call print_string
    jmp .done

.lock_error:
    ; Print lock error message
    mov esi, lock_error_msg
    call print_string
    jmp .done

.unlock_error:
    ; Print unlock error message
    mov esi, unlock_error_msg
    call print_string
    jmp .done

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to lock a file
lock_file:
    ; Check if the file is already locked
    cmp byte [lock_state], 1
    je .locked

    ; Read the root directory
    mov eax, root_dir_lba
    call read_sector
    cmp eax, 0
    jne .error

    ; Find the file and lock it
    mov esi, buffer
    mov ecx, sector_size / dir_entry_size
    mov edi, file_name
    call find_file
    cmp eax, 0
    jne .error

    ; Set lock state
    mov byte [lock_state], 1
    xor eax, eax
    ret

.locked:
    ; File is already locked
    mov eax, 1
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to unlock a file
unlock_file:
    ; Check if the file is locked
    cmp byte [lock_state], 0
    je .not_locked

    ; Clear lock state
    mov byte [lock_state], 0
    xor eax, eax
    ret

.not_locked:
    ; File is not locked
    mov eax, 1
    ret

; Function to find a file in the root directory
find_file:
    ; Iterate through directory entries
    .next_entry:
        cmp byte [esi], 0
        je .not_found
        cmp byte [esi], 0xE5
        je .skip_entry
        cmp byte [esi + 11], 0x0F  ; Check for long file name
        je .skip_entry

        ; Compare file name
        mov ecx, 11
        repe cmpsb
        jne .skip_entry

        ; File found
        xor eax, eax
        ret

    .skip_entry:
        add esi, dir_entry_size
        loop .next_entry

    .not_found:
        ; File not found
        mov eax, 1
        ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


28.asm
;Content of 28.asm
section .data
    floppy_base         equ 0x3F0       ; Base I/O port address for the floppy disk controller
    root_dir_lba        equ 19          ; LBA of the root directory in FAT12
    sector_size         equ 512         ; Size of a sector in bytes
    dir_entry_size      equ 32          ; Size of a directory entry in bytes
    file_name           db 'TEST    TXT', 0 ; 11-byte file name (8.3 format)

    read_error_msg      db 'Read Error', 0
    not_found_msg       db 'File Not Found', 0
    success_msg         db 'File Metadata:', 0
    newline             db 13, 10, 0    ; Newline characters

section .bss
    buffer resb sector_size   ; Buffer to store the sector data

section .text
global _start

_start:
    ; Initialize the floppy disk controller
    call init_floppy

    ; Read the root directory
    mov eax, root_dir_lba
    call read_sector
    cmp eax, 0
    jne .read_error

    ; Find the file and display its metadata
    mov esi, buffer
    mov ecx, sector_size / dir_entry_size
    mov edi, file_name
    call find_file
    cmp eax, 0
    jne .not_found

    ; Print success message
    mov esi, success_msg
    call print_string

    ; Print file metadata
    call print_file_metadata

    ; Exit
    jmp .done

.read_error:
    ; Print read error message
    mov esi, read_error_msg
    call print_string
    jmp .done

.not_found:
    ; Print file not found message
    mov esi, not_found_msg
    call print_string
    jmp .done

.done:
    ; Exit
    mov eax, 60            ; syscall number for exit
    xor edi, edi           ; exit code 0
    syscall

; Function to initialize the floppy disk controller
init_floppy:
    ; Reset the controller
    mov dx, floppy_base + 2
    out dx, al
    call delay

    ; Initialize the controller (simplified)
    mov al, 0x07           ; Set transfer rate to 500 Kbps
    mov dx, floppy_base
    out dx, al

    ret

; Function to read a sector from the floppy disk
read_sector:
    ; Set up the DMA for floppy read
    mov dx, 0x0C          ; DMA channel 2
    mov al, 0x46          ; Single transfer, read, address increment
    out dx, al
    mov dx, 0x04          ; DMA base address
    mov eax, buffer
    out dx, al
    shr eax, 8
    mov dx, 0x81
    out dx, al
    mov dx, 0x0A          ; DMA mask register
    mov al, 0x02          ; Unmask channel 2
    out dx, al

    ; Set up the floppy controller command
    mov al, 0xC6          ; Read sector command
    mov dx, floppy_base
    out dx, al
    mov al, 0x00          ; Head and drive number
    out dx, al
    mov al, 0x01          ; Cylinder number
    out dx, al
    mov al, 0x01          ; Sector number
    out dx, al
    mov al, 0x02          ; Number of sectors to read
    out dx, al

    ; Wait for the read to complete
    call delay

    ; Check for errors
    in al, dx
    and al, 0xC0
    cmp al, 0
    jne .error

    ; Successful read
    xor eax, eax
    ret

.error:
    ; Indicate error
    mov eax, 1
    ret

; Function to find a file in the root directory
find_file:
    ; Iterate through directory entries
    .next_entry:
        cmp byte [esi], 0
        je .not_found
        cmp byte [esi], 0xE5
        je .skip_entry
        cmp byte [esi + 11], 0x0F  ; Check for long file name
        je .skip_entry

        ; Compare file name
        mov ecx, 11
        repe cmpsb
        jne .skip_entry

        ; File found
        xor eax, eax
        ret

    .skip_entry:
        add esi, dir_entry_size
        loop .next_entry

    .not_found:
        ; File not found
        mov eax, 1
        ret

; Function to print file metadata
print_file_metadata:
    ; Print file size
    mov esi, buffer
    add esi, 28            ; Offset to file size in directory entry
    mov eax, [esi]
    call print_number
    call print_newline

    ; Print creation date and time
    mov esi, buffer
    add esi, 16            ; Offset to creation date and time in directory entry
    mov ax, [esi]
    call print_date
    call print_newline

    ; Print last access date
    mov esi, buffer
    add esi, 18            ; Offset to last access date in directory entry
    mov ax, [esi]
    call print_date
    call print_newline

    ; Print last modified date and time
    mov esi, buffer
    add esi, 24            ; Offset to last modified date and time in directory entry
    mov ax, [esi]
    call print_date
    call print_newline

    ; Print file attributes
    mov esi, buffer
    add esi, 11            ; Offset to file attributes in directory entry
    mov al, [esi]
    call print_attributes
    call print_newline

    ret

; Function to print a number (eax) to the screen
print_number:
    ; Convert number to string and print it
    mov esi, buffer
    call number_to_string
    call print_string
    ret

; Function to convert a number (eax) to a string
number_to_string:
    mov edi, buffer
    add edi, sector_size   ; Start at the end of the buffer
    mov byte [edi], 0      ; Null-terminate the string
    dec edi

    .convert:
        mov edx, 0
        div dword 10
        add dl, '0'
        mov [edi], dl
        dec edi
        test eax, eax
        jnz .convert

    inc edi
    mov esi, edi
    ret

; Function to print a date (ax) to the screen
print_date:
    ; Convert and print the date
    mov esi, buffer
    call date_to_string
    call print_string
    ret

; Function to convert a date (ax) to a string
date_to_string:
    ; Convert the date to a string (simplified)
    ; Assuming the date is stored in the format: YYYYYYYMMMMDDDDD
    mov edi, buffer
    add edi, sector_size   ; Start at the end of the buffer
    mov byte [edi], 0      ; Null-terminate the string
    dec edi

    mov ecx, 5             ; Day (5 bits)
    and ax, 0x1F
    call number_to_string
    mov [edi], ' '
    dec edi

    shr ax, 5
    mov ecx, 4             ; Month (4 bits)
    and ax, 0xF
    call number_to_string
    mov [edi], ' '
    dec edi

    shr ax, 4
    mov ecx, 7             ; Year (7 bits)
    add ax, 1980           ; FAT date is stored as offset from 1980
    call number_to_string

    inc edi
    mov esi, edi
    ret

; Function to print file attributes (al) to the screen
print_attributes:
    ; Print the file attributes (simplified)
    test al, 0x01
    jz .no_readonly
    mov esi, readonly_msg
    call print_string
.no_readonly:
    test al, 0x02
    jz .no_hidden
    mov esi, hidden_msg
    call print_string
.no_hidden:
    test al, 0x04
    jz .no_system
    mov esi, system_msg
    call print_string
.no_system:
    test al, 0x10
    jz .no_directory
    mov esi, directory_msg
    call print_string
.no_directory:
    test al, 0x20
    jz .no_archive
    mov esi, archive_msg
    call print_string
.no_archive:
    ret

; Function to print a newline
print_newline:
    mov esi, newline
    call print_string
    ret

delay:
    ; Simple delay loop
    mov ecx, 100000
.loop:
    loop .loop
    ret

print_string:
    lodsb
    cmp al, 0
    je .done
    mov ah, 0x0E
    int 0x10
    jmp print_string
.done:
    ret


29.asm
;Content of 29.asm
section .data
    disk_path db '/dev/sda', 0
    fs_type db 'ext4', 0

section .bss
    format_command resb 100

section .text
    global _start

_start:
    ; Prepare the format command: "mkfs.ext4 /dev/sda"
    mov rdi, format_command
    mov rsi, 'mkfs.'
    call strcpy
    add rdi, rsi
    mov rsi, fs_type
    call strcpy
    add rdi, rsi
    mov rsi, ' '
    stosb
    mov rsi, disk_path
    call strcpy

    ; Execute the format command
    mov rdi, format_command
    call execute_command

    ; Exit the program
    mov rax, 60         ; sys_exit
    xor rdi, rdi        ; exit code 0
    syscall

; strcpy function
strcpy:
    lodsb
    stosb
    test al, al
    jnz strcpy
    ret

; execute_command function
execute_command:
    mov rax, 59         ; sys_execve
    mov rdi, format_command
    lea rsi, [rel argv]
    xor rdx, rdx
    syscall
    ret

section .data
argv:
    dq format_command
    dq 0


30.asm
;Content of 30.asm
section .data
    input_file db 'input.txt', 0
    output_file db 'output.txt', 0
    compress_command db 'gzip -c input.txt > output.txt', 0

section .bss
    buffer resb 256

section .text
    global _start

_start:
    ; Prepare the compress command: "gzip -c input.txt > output.txt"
    mov rdi, buffer
    mov rsi, compress_command
    call strcpy

    ; Execute the compress command
    mov rdi, buffer
    call execute_command

    ; Exit the program
    mov rax, 60         ; sys_exit
    xor rdi, rdi        ; exit code 0
    syscall

; strcpy function
strcpy:
    lodsb
    stosb
    test al, al
    jnz strcpy
    ret

; execute_command function
execute_command:
    mov rax, 59         ; sys_execve
    mov rdi, buffer
    lea rsi, [rel argv]
    xor rdx, rdx
    syscall
    ret

section .data
argv:
    dq buffer
    dq 0


31.asm
;Content of 31.asm
section .data
    msg db 'Hello, Text Mode Display!', 0x0A, 0
    len equ $ - msg

section .bss

section .text
    global _start

_start:
    ; Write the message to the terminal
    mov rax, 1          ; sys_write
    mov rdi, 1          ; file descriptor (stdout)
    mov rsi, msg        ; message to write
    mov rdx, len        ; message length
    syscall

    ; Exit the program
    mov rax, 60         ; sys_exit
    xor rdi, rdi        ; exit code 0
    syscall


32.asm
;Content of 32.asm
section .data
    vbe_mode db 0x117  ; VBE mode for 1024x768 resolution with 32-bit color

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                     ; Disable interrupts
    lgdt [gdt_descriptor]   ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax            ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h             ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h           ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to a specific color (e.g., black)
    mov edi, 0xA0000       ; Video memory address
    mov ecx, 1024*768      ; Screen size
    mov eax, 0x00000000    ; Color (black)
    rep stosd

    ; Loop indefinitely
hang:
    hlt
    jmp hang

gdt_start:
    dd 0x00000000        ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF        ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF        ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


33.asm
;Content of 33.asm
section .data
    vbe_mode db 0x117               ; VBE mode for 1024x768 resolution with 32-bit color
    win_x equ 100                   ; Window X position
    win_y equ 100                   ; Window Y position
    win_width equ 400               ; Window width
    win_height equ 300              ; Window height
    win_color equ 0x00FF00FF        ; Window color (ARGB)

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                             ; Disable interrupts
    lgdt [gdt_descriptor]           ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax                    ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h                     ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h                   ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to black
    mov edi, 0xA0000                ; Video memory address
    mov ecx, 1024 * 768             ; Screen size
    mov eax, 0x00000000             ; Color (black)
    rep stosd

    ; Draw the window
    call draw_window

    ; Loop indefinitely
hang:
    hlt
    jmp hang

draw_window:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the window in video memory
    add edi, win_y * 1024 * 4       ; Move to the correct row
    add edi, win_x * 4              ; Move to the correct column

    ; Draw the window row by row
    mov ecx, win_height             ; Number of rows
draw_row:
    push ecx
    mov ecx, win_width              ; Number of columns
    mov eax, win_color              ; Window color
draw_pixel:
    stosd                          ; Write the pixel
    loop draw_pixel                ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - win_width) * 4 ; Move to the start of the next row
    loop draw_row
    ret

gdt_start:
    dd 0x00000000                   ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF                   ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF                   ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


34.asm
;Content of 34.asm
section .data
    vbe_mode db 0x117               ; VBE mode for 1024x768 resolution with 32-bit color
    desktop_bg_color equ 0x1E90FF   ; Desktop background color (DodgerBlue)

    win_x equ 100                   ; Window X position
    win_y equ 100                   ; Window Y position
    win_width equ 400               ; Window width
    win_height equ 300              ; Window height
    win_color equ 0x00FF00FF        ; Window color (ARGB)

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                             ; Disable interrupts
    lgdt [gdt_descriptor]           ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax                    ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h                     ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h                   ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to the desktop background color
    mov edi, 0xA0000                ; Video memory address
    mov ecx, 1024 * 768             ; Screen size
    mov eax, desktop_bg_color       ; Desktop background color
    rep stosd

    ; Draw the window
    call draw_window

    ; Loop indefinitely
hang:
    hlt
    jmp hang

draw_window:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the window in video memory
    add edi, win_y * 1024 * 4       ; Move to the correct row
    add edi, win_x * 4              ; Move to the correct column

    ; Draw the window row by row
    mov ecx, win_height             ; Number of rows
draw_row:
    push ecx
    mov ecx, win_width              ; Number of columns
    mov eax, win_color              ; Window color
draw_pixel:
    stosd                          ; Write the pixel
    loop draw_pixel                ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - win_width) * 4 ; Move to the start of the next row
    loop draw_row
    ret

gdt_start:
    dd 0x00000000                   ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF                   ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF                   ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


35.asm
;Content of 35.asm
section .data
    vbe_mode db 0x117               ; VBE mode for 1024x768 resolution with 32-bit color
    desktop_bg_color equ 0x1E90FF   ; Desktop background color (DodgerBlue)
    taskbar_color equ 0x000000FF    ; Taskbar color (Black)
    start_menu_color equ 0x00FF00FF ; Start Menu color (Green)

    taskbar_height equ 40           ; Height of the taskbar
    start_menu_width equ 200        ; Width of the start menu
    start_menu_height equ 300       ; Height of the start menu

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                             ; Disable interrupts
    lgdt [gdt_descriptor]           ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax                    ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h                     ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h                   ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to the desktop background color
    mov edi, 0xA0000                ; Video memory address
    mov ecx, 1024 * 768             ; Screen size
    mov eax, desktop_bg_color       ; Desktop background color
    rep stosd

    ; Draw the taskbar
    call draw_taskbar

    ; Draw the start menu
    call draw_start_menu

    ; Loop indefinitely
hang:
    hlt
    jmp hang

draw_taskbar:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the taskbar in video memory
    add edi, (768 - taskbar_height) * 1024 * 4

    ; Draw the taskbar row by row
    mov ecx, taskbar_height         ; Number of rows
draw_taskbar_row:
    push ecx
    mov ecx, 1024                   ; Number of columns
    mov eax, taskbar_color          ; Taskbar color
draw_taskbar_pixel:
    stosd                          ; Write the pixel
    loop draw_taskbar_pixel         ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - 1024) * 4      ; Move to the start of the next row
    loop draw_taskbar_row
    ret

draw_start_menu:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the start menu in video memory
    add edi, (768 - taskbar_height - start_menu_height) * 1024 * 4

    ; Draw the start menu row by row
    mov ecx, start_menu_height      ; Number of rows
draw_start_menu_row:
    push ecx
    mov ecx, start_menu_width       ; Number of columns
    mov eax, start_menu_color       ; Start menu color
draw_start_menu_pixel:
    stosd                          ; Write the pixel
    loop draw_start_menu_pixel      ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - start_menu_width) * 4 ; Move to the start of the next row
    loop draw_start_menu_row
    ret

gdt_start:
    dd 0x00000000                   ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF                   ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF                   ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


36.asm
;Content of 36.asm
section .data
    vbe_mode db 0x117               ; VBE mode for 1024x768 resolution with 32-bit color
    desktop_bg_color equ 0x1E90FF   ; Desktop background color (DodgerBlue)
    dialog_bg_color equ 0xFFFFFFFF  ; Dialog box background color (White)
    dialog_border_color equ 0x000000FF ; Dialog box border color (Black)

    dialog_x equ 200                ; Dialog X position
    dialog_y equ 200                ; Dialog Y position
    dialog_width equ 400            ; Dialog width
    dialog_height equ 200           ; Dialog height
    dialog_border_width equ 2       ; Dialog border width

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                             ; Disable interrupts
    lgdt [gdt_descriptor]           ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax                    ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h                     ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h                   ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to the desktop background color
    mov edi, 0xA0000                ; Video memory address
    mov ecx, 1024 * 768             ; Screen size
    mov eax, desktop_bg_color       ; Desktop background color
    rep stosd

    ; Draw the dialog box
    call draw_dialog_box

    ; Loop indefinitely
hang:
    hlt
    jmp hang

draw_dialog_box:
    ; Draw the dialog box background
    call draw_rect

    ; Draw the dialog box border
    mov edi, 0xA0000                ; Video memory address
    call draw_border
    ret

draw_rect:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the dialog box in video memory
    add edi, dialog_y * 1024 * 4       ; Move to the correct row
    add edi, dialog_x * 4              ; Move to the correct column

    ; Draw the dialog box row by row
    mov ecx, dialog_height             ; Number of rows
draw_rect_row:
    push ecx
    mov ecx, dialog_width              ; Number of columns
    mov eax, dialog_bg_color           ; Dialog box background color
draw_rect_pixel:
    stosd                             ; Write the pixel
    loop draw_rect_pixel              ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - dialog_width) * 4 ; Move to the start of the next row
    loop draw_rect_row
    ret

draw_border:
    ; Draw top border
    mov ecx, dialog_border_width
    call draw_rect

    ; Draw bottom border
    mov edi, 0xA0000
    add edi, (dialog_y + dialog_height - dialog_border_width) * 1024 * 4
    add edi, dialog_x * 4
    mov ecx, dialog_border_width
    call draw_rect

    ; Draw left border
    mov edi, 0xA0000
    add edi, dialog_y * 1024 * 4
    add edi, dialog_x * 4
    mov ecx, dialog_height
draw_border_left_row:
    push ecx
    mov ecx, dialog_border_width
    mov eax, dialog_border_color
draw_border_left_pixel:
    stosd
    loop draw_border_left_pixel
    pop ecx
    add edi, (1024 - dialog_border_width) * 4
    loop draw_border_left_row

    ; Draw right border
    mov edi, 0xA0000
    add edi, dialog_y * 1024 * 4
    add edi, (dialog_x + dialog_width - dialog_border_width) * 4
    mov ecx, dialog_height
draw_border_right_row:
    push ecx
    mov ecx, dialog_border_width
    mov eax, dialog_border_color
draw_border_right_pixel:
    stosd
    loop draw_border_right_pixel
    pop ecx
    add edi, (1024 - dialog_border_width) * 4
    loop draw_border_right_row
    ret

gdt_start:
    dd 0x00000000                   ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF                   ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF                   ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


37.asm
;Content of 37.asm
section .data
    vbe_mode db 0x117               ; VBE mode for 1024x768 resolution with 32-bit color
    desktop_bg_color equ 0x1E90FF   ; Desktop background color (DodgerBlue)

    icon_x equ 100                  ; Icon X position
    icon_y equ 100                  ; Icon Y position
    icon_width equ 32               ; Icon width
    icon_height equ 32              ; Icon height
    icon_color equ 0xFF0000FF       ; Icon color (ARGB, red)

section .bss

section .text
    global _start

_start:
    ; Switch to protected mode (assuming we start in real mode)
    ; Set up the GDT
    cli                             ; Disable interrupts
    lgdt [gdt_descriptor]           ; Load GDT
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax                    ; Enable protected mode

    ; Jump to protected mode code
    jmp 08h:protected_mode

[bits 32]
protected_mode:
    ; Set up a stack
    mov ax, 10h                     ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, stack_space + stack_size

    ; Set up VBE mode
    mov ax, 4F02h                   ; VESA Set Mode
    mov bx, [vbe_mode]
    int 10h

    ; Clear the screen to the desktop background color
    mov edi, 0xA0000                ; Video memory address
    mov ecx, 1024 * 768             ; Screen size
    mov eax, desktop_bg_color       ; Desktop background color
    rep stosd

    ; Draw the icon
    call draw_icon

    ; Loop indefinitely
hang:
    hlt
    jmp hang

draw_icon:
    ; Set up EDI to point to video memory
    mov edi, 0xA0000

    ; Calculate the start of the icon in video memory
    add edi, icon_y * 1024 * 4       ; Move to the correct row
    add edi, icon_x * 4              ; Move to the correct column

    ; Draw the icon row by row
    mov ecx, icon_height             ; Number of rows
draw_icon_row:
    push ecx
    mov ecx, icon_width              ; Number of columns
    mov eax, icon_color              ; Icon color
draw_icon_pixel:
    stosd                           ; Write the pixel
    loop draw_icon_pixel            ; Draw the next pixel

    ; Move to the next row
    pop ecx
    add edi, (1024 - icon_width) * 4 ; Move to the start of the next row
    loop draw_icon_row
    ret

gdt_start:
    dd 0x00000000                   ; Null descriptor
    dd 0x00000000
    dd 0x0000FFFF                   ; Code segment descriptor
    dd 0x00CF9A00
    dd 0x0000FFFF                   ; Data segment descriptor
    dd 0x00CF9200
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

section .bss
stack_space resb 4096
stack_size equ $ - stack_space


38.asm
;Content of 38.asm
section .data
    ; Cursor data
    cursor_shape db 0x0F, 0x0E, 0x0C, 0x08, 0x00  ; Example cursor shape
    cursor_pos_x dd 10  ; Initial X position
    cursor_pos_y dd 10  ; Initial Y position

section .bss
    temp_x resb 4
    temp_y resb 4

section .text
    global _start

_start:
    ; Initialize cursor position
    mov eax, [cursor_pos_x]
    mov [temp_x], eax
    mov eax, [cursor_pos_y]
    mov [temp_y], eax

    ; Main loop
main_loop:
    ; Read mouse input (This is a placeholder. In a real system, you would read hardware registers or use an OS API)
    call read_mouse_input

    ; Update cursor position
    mov eax, [temp_x]
    add eax, 1  ; Move cursor right (example)
    mov [cursor_pos_x], eax
    mov eax, [temp_y]
    add eax, 1  ; Move cursor down (example)
    mov [cursor_pos_y], eax

    ; Render cursor
    call render_cursor

    ; Loop
    jmp main_loop

read_mouse_input:
    ; Placeholder for reading mouse input
    ; This should update temp_x and temp_y based on actual mouse movement
    ret

render_cursor:
    ; Placeholder for rendering the cursor on the screen
    ; In a real system, this would write to the framebuffer or use an OS API
    ret


39.asm
;Content of 39.asm
section .data
    font_data db 0x3C, 0x42, 0xA9, 0x85, 0xA9, 0x42, 0x3C, 0x00  ; Example font data for a character (8x8 bitmap)
    text_message db 'Hello', 0  ; Text to render
    text_length equ $ - text_message  ; Length of the text message

    screen_width equ 80  ; Screen width in characters
    screen_height equ 25  ; Screen height in characters

section .bss
    screen resb screen_width * screen_height  ; Screen buffer

section .text
    global _start

_start:
    ; Initialize screen buffer
    call clear_screen

    ; Render text message
    mov esi, text_message
    mov ecx, text_length
    mov edi, 0  ; Start at screen position 0
render_loop:
    lodsb  ; Load character from message
    call render_character
    add edi, 8  ; Move to the next character position
    loop render_loop

    ; End program (infinite loop)
hang:
    jmp hang

clear_screen:
    ; Clear screen buffer
    mov edi, screen
    mov ecx, screen_width * screen_height
    xor eax, eax
    rep stosb
    ret

render_character:
    ; Render a single character from font_data
    ; Input: AL = character to render, EDI = screen position
    ; This is a simplified example that renders a fixed 8x8 font
    push eax
    push edi
    mov ebx, eax  ; Character code
    mov esi, font_data
    add esi, ebx
    mov ecx, 8  ; 8 rows
render_row:
    lodsb
    mov ah, al
    mov al, 8  ; 8 pixels
render_pixel:
    shl ah, 1
    jc draw_pixel
    inc edi
    loop render_pixel
    add edi, screen_width - 8  ; Move to the next row
    loop render_row
    pop edi
    pop eax
    ret

draw_pixel:
    ; Draw a single pixel (set bit in the screen buffer)
    or byte [screen + edi], 1
    inc edi
    dec al
    jnz render_pixel
    ret


40.asm
;Content of 40.asm
section .data
    clipboard db 256 dup(0)  ; Clipboard buffer (256 bytes)
    message db 'Copied to clipboard!', 0

section .bss
    input_buffer resb 256  ; Input buffer for clipboard operations

section .text
    global _start

_start:
    ; Display initial message
    mov rsi, message
    call print_string

    ; Main loop
main_loop:
    ; Wait for input
    call read_input
    ; Copy input to clipboard
    call copy_to_clipboard
    ; Display clipboard content
    call display_clipboard
    ; Loop
    jmp main_loop

; Routine to print a null-terminated string
print_string:
    ; Input: RSI = address of string
    mov rax, 1  ; sys_write
    mov rdi, 1  ; file descriptor (stdout)
    mov rdx, 256
print_char:
    lodsb
    test al, al
    jz end_print
    syscall
    loop print_char
end_print:
    ret

; Routine to read input into the input buffer
read_input:
    ; Input: None
    ; Output: Input stored in input_buffer
    mov rax, 0  ; sys_read
    mov rdi, 0  ; file descriptor (stdin)
    mov rsi, input_buffer
    mov rdx, 256
    syscall
    ret

; Routine to copy input buffer to clipboard
copy_to_clipboard:
    ; Input: input_buffer contains the data to copy
    ; Output: clipboard updated with new data
    mov rsi, input_buffer
    mov rdi, clipboard
    mov rcx, 256
    rep movsb
    ret

; Routine to display the clipboard content
display_clipboard:
    ; Input: clipboard contains the data to display
    mov rsi, clipboard
    call print_string
    ret


41.asm
;Content of 41.asm
section .data
    ip_version db 4            ; IP version (IPv4)
    header_length db 5         ; Header length (5 * 4 = 20 bytes)
    tos db 0                   ; Type of Service
    total_length dw 0          ; Total length (to be filled later)
    identification dw 0        ; Identification
    flags_and_offset dw 0      ; Flags and Fragment Offset
    ttl db 64                  ; Time to Live
    protocol db 6              ; Protocol (6 for TCP)
    header_checksum dw 0       ; Header checksum (to be calculated later)
    source_ip dd 0             ; Source IP address (to be filled later)
    dest_ip dd 0               ; Destination IP address (to be filled later)

section .bss
    buffer resb 4096           ; Buffer for packet data

section .text
    global _start

_start:
    ; Initialize the IP header
    mov rsi, buffer
    mov al, [ip_version]
    shl al, 4
    or al, [header_length]
    stosb
    mov al, [tos]
    stosb
    xor rax, rax
    stosw
    stosw
    stosw
    stosb
    mov al, [ttl]
    stosb
    mov al, [protocol]
    stosb
    xor rax, rax
    stosw
    stosd
    stosd

    ; Calculate the IP header checksum
    mov rcx, 10
    xor rax, rax
    mov rsi, buffer
    .checksum_loop:
        lodsw
        add ax, [rsi-2]
        loop .checksum_loop
    add ax, ax
    not ax
    mov [buffer + 10], ax

    ; Here would be the additional code for TCP and data payload
    ; This example only initializes the IP header

    ; Exit program (Linux syscall exit)
    mov rax, 60
    xor rdi, rdi
    syscall


42.asm
;Content of 42.asm
section .data
    ; Strings for interface and IP address
    interface db "eth0", 0       ; Network interface name
    ip_address db "192.168.1.100", 0 ; IP address to assign

    ; Commands for setting IP address and bringing up the interface
    cmd_set_ip db "/sbin/ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up", 0
    cmd_up_interface db "/sbin/ifconfig eth0 up", 0

section .bss

section .text
    global _start

_start:
    ; Set IP address
    mov rax, 59                ; syscall: execve
    lea rdi, [rel cmd_set_ip]  ; filename
    lea rsi, [rel cmd_args]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall

    ; Bring up the network interface
    mov rax, 59                ; syscall: execve
    lea rdi, [rel cmd_up_interface] ; filename
    lea rsi, [rel cmd_args]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

section .rodata
cmd_args:
    dq cmd_set_ip
    dq 0
    dq cmd_up_interface
    dq 0


43.asm
;Content of 43.asm
section .data
    dhcp_request db 0x01, 0x01, 0x06, 0x00   ; DHCP Discover Message Type
    xid db 0x39, 0x03, 0xF3, 0x26            ; Transaction ID
    secs db 0x00, 0x00                       ; Seconds elapsed
    flags db 0x00, 0x00                      ; Flags
    ciaddr db 0x00, 0x00, 0x00, 0x00         ; Client IP address
    yiaddr db 0x00, 0x00, 0x00, 0x00         ; 'Your' IP address
    siaddr db 0x00, 0x00, 0x00, 0x00         ; Server IP address
    giaddr db 0x00, 0x00, 0x00, 0x00         ; Gateway IP address
    chaddr db 0x00, 0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ; Client hardware address
    sname db 64 dup(0)                       ; Server name
    file db 128 dup(0)                       ; Boot file name
    options db 0x63, 0x82, 0x53, 0x63, 0x35, 0x01, 0x01, 0x37, 0x03, 0x01, 0x03, 0x06, 0xff ; Options

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Create socket
    mov rax, 41                ; syscall: socket
    mov rdi, 2                 ; domain: AF_INET
    mov rsi, 2                 ; type: SOCK_DGRAM
    mov rdx, 17                ; protocol: IPPROTO_UDP
    syscall

    ; Store socket file descriptor
    mov rdi, rax

    ; Bind socket
    mov rax, 49                ; syscall: bind
    mov rsi, rsp               ; address
    mov word [rsp], 2          ; sin_family: AF_INET
    mov word [rsp+2], 68       ; sin_port: htons(68)
    mov dword [rsp+4], 0       ; sin_addr: INADDR_ANY
    mov dword [rsp+8], 0       ; zero padding
    mov rdx, 16                ; address length
    syscall

    ; Send DHCP Discover message
    mov rax, 44                ; syscall: sendto
    mov rsi, dhcp_request      ; message
    mov rdx, 236               ; message length
    mov rcx, rsp               ; address
    mov word [rsp], 2          ; sin_family: AF_INET
    mov word [rsp+2], 67       ; sin_port: htons(67)
    mov dword [rsp+4], 0xFFFFFFFF ; sin_addr: 255.255.255.255
    mov dword [rsp+8], 0       ; zero padding
    mov r8, 16                 ; address length
    mov r10, 0                 ; flags
    syscall

    ; Receive DHCP Offer message
    mov rax, 45                ; syscall: recvfrom
    mov rsi, buffer            ; buffer
    mov rdx, 4096              ; buffer length
    mov rcx, rsp               ; address
    mov r8, 16                 ; address length
    mov r10, 0                 ; flags
    syscall

    ; Here we would parse the DHCP Offer message and send DHCP Request, then wait for DHCP Ack
    ; For brevity, this example stops after receiving the DHCP Offer

    ; Close socket
    mov rax, 3                 ; syscall: close
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall


44.asm
;Content of 44.asm
section .data
    domain db "example.com", 0
    dns_server_ip db "8.8.8.8", 0          ; Google's public DNS server
    query_id dw 0x1234                      ; Random identifier for the DNS query
    dns_header db 0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    dns_question db 0x07, 'e', 'x', 'a', 'm', 'p', 'l', 'e', 0x03, 'c', 'o', 'm', 0x00, 0x00, 0x01, 0x00, 0x01

section .bss
    buffer resb 512           ; Buffer for DNS query and response
    recv_buffer resb 512      ; Buffer for receiving the response

section .text
    global _start

_start:
    ; Create socket
    mov rax, 41                ; syscall: socket
    mov rdi, 2                 ; domain: AF_INET
    mov rsi, 2                 ; type: SOCK_DGRAM
    mov rdx, 17                ; protocol: IPPROTO_UDP
    syscall

    ; Store socket file descriptor
    mov rdi, rax

    ; Construct DNS query
    mov rsi, buffer
    mov rdx, dns_header
    mov rcx, 12                ; DNS header size
    rep movsb

    mov rsi, dns_question
    mov rcx, 17                ; DNS question size
    rep movsb

    ; Send DNS query
    mov rax, 44                ; syscall: sendto
    mov rsi, buffer            ; message
    mov rdx, 29                ; message length (12 + 17)
    mov rcx, rsp               ; address
    mov word [rsp], 2          ; sin_family: AF_INET
    mov word [rsp+2], 53       ; sin_port: htons(53)
    mov dword [rsp+4], 0x08080808 ; sin_addr: 8.8.8.8
    mov dword [rsp+8], 0       ; zero padding
    mov r8, 16                 ; address length
    mov r10, 0                 ; flags
    syscall

    ; Receive DNS response
    mov rax, 45                ; syscall: recvfrom
    mov rsi, recv_buffer       ; buffer
    mov rdx, 512               ; buffer length
    mov rcx, rsp               ; address
    mov r8, 16                 ; address length
    mov r10, 0                 ; flags
    syscall

    ; Here we would parse the DNS response to extract the IP address
    ; For brevity, this example stops after receiving the DNS response

    ; Close socket
    mov rax, 3                 ; syscall: close
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall


45.asm
;Content of 45.asm
section .data
    host db "example.com", 0
    request db "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n", 0
    ip_address db "93.184.216.34", 0 ; Example.com's IP address

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Create socket
    mov rax, 41                ; syscall: socket
    mov rdi, 2                 ; domain: AF_INET
    mov rsi, 1                 ; type: SOCK_STREAM
    mov rdx, 6                 ; protocol: IPPROTO_TCP
    syscall

    ; Store socket file descriptor
    mov rdi, rax

    ; Set up sockaddr_in structure for connect
    mov rax, 0x0200007f        ; sin_family: AF_INET, sin_port: htons(80), sin_addr: 127.0.0.1 (loopback)
    mov [rsp+16], rax
    mov word [rsp+16], 2       ; sin_family: AF_INET
    mov word [rsp+18], 0x5000  ; sin_port: htons(80)
    mov dword [rsp+20], 0x22d8b85d ; sin_addr: 93.184.216.34 (example.com)

    ; Connect to the server
    mov rax, 42                ; syscall: connect
    mov rsi, rsp               ; address
    add rsi, 16
    mov rdx, 16                ; address length
    syscall

    ; Send HTTP GET request
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel request]     ; message
    mov rdx, 44                ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive HTTP response
    mov rax, 45                ; syscall: recvfrom
    lea rsi, [rel buffer]      ; buffer
    mov rdx, 4096              ; buffer length
    xor r10, r10               ; flags
    syscall

    ; Print the received response
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel buffer]      ; buffer
    syscall

    ; Close socket
    mov rax, 3                 ; syscall: close
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall


46.asm
;Content of 46.asm
section .data
    server_ip db "93.184.216.34", 0 ; Example.com's IP address for FTP server
    port dw 21                      ; FTP control port
    user db "USER anonymous\r\n", 0
    pass db "PASS anonymous\r\n", 0
    list_command db "LIST\r\n", 0
    quit_command db "QUIT\r\n", 0

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Create socket
    mov rax, 41                ; syscall: socket
    mov rdi, 2                 ; domain: AF_INET
    mov rsi, 1                 ; type: SOCK_STREAM
    mov rdx, 6                 ; protocol: IPPROTO_TCP
    syscall

    ; Store socket file descriptor
    mov rdi, rax

    ; Set up sockaddr_in structure for connect
    mov rax, 0x02000015        ; sin_family: AF_INET, sin_port: htons(21), sin_addr: 127.0.0.1 (loopback)
    mov [rsp+16], rax
    mov word [rsp+16], 2       ; sin_family: AF_INET
    mov word [rsp+18], 0x1500  ; sin_port: htons(21)
    mov dword [rsp+20], 0x22d8b85d ; sin_addr: 93.184.216.34 (example.com)

    ; Connect to the FTP server
    mov rax, 42                ; syscall: connect
    mov rsi, rsp               ; address
    add rsi, 16
    mov rdx, 16                ; address length
    syscall

    ; Send USER command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel user]        ; message
    mov rdx, 17                ; message length
    xor r10, r10               ; flags
    syscall

    ; Send PASS command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel pass]        ; message
    mov rdx, 20                ; message length
    xor r10, r10               ; flags
    syscall

    ; Send LIST command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel list_command]; message
    mov rdx, 6                 ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive FTP response
    mov rax, 45                ; syscall: recvfrom
    lea rsi, [rel buffer]      ; buffer
    mov rdx, 4096              ; buffer length
    xor r10, r10               ; flags
    syscall

    ; Print the received response
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel buffer]      ; buffer
    syscall

    ; Send QUIT command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel quit_command]; message
    mov rdx, 6                 ; message length
    xor r10, r10               ; flags
    syscall

    ; Close socket
    mov rax, 3                 ; syscall: close
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall


47.asm
;Content of 47.asm
section .data
    smtp_server_ip db "93.184.216.34", 0 ; Example SMTP server IP
    port dw 25                           ; SMTP port
    helo_command db "HELO example.com\r\n", 0
    mail_from db "MAIL FROM:<example@example.com>\r\n", 0
    rcpt_to db "RCPT TO:<recipient@example.com>\r\n", 0
    data_command db "DATA\r\n", 0
    email_body db "Subject: Test Email\r\n\r\nThis is a test email.\r\n.\r\n", 0
    quit_command db "QUIT\r\n", 0

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Create socket
    mov rax, 41                ; syscall: socket
    mov rdi, 2                 ; domain: AF_INET
    mov rsi, 1                 ; type: SOCK_STREAM
    mov rdx, 6                 ; protocol: IPPROTO_TCP
    syscall

    ; Store socket file descriptor
    mov rdi, rax

    ; Set up sockaddr_in structure for connect
    mov rax, 0x02000019        ; sin_family: AF_INET, sin_port: htons(25), sin_addr: 127.0.0.1 (loopback)
    mov [rsp+16], rax
    mov word [rsp+16], 2       ; sin_family: AF_INET
    mov word [rsp+18], 0x1900  ; sin_port: htons(25)
    mov dword [rsp+20], 0x22d8b85d ; sin_addr: 93.184.216.34 (example.com)

    ; Connect to the SMTP server
    mov rax, 42                ; syscall: connect
    mov rsi, rsp               ; address
    add rsi, 16
    mov rdx, 16                ; address length
    syscall

    ; Send HELO command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel helo_command] ; message
    mov rdx, 18                ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive server response
    call recv_response

    ; Send MAIL FROM command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel mail_from]   ; message
    mov rdx, 27                ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive server response
    call recv_response

    ; Send RCPT TO command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel rcpt_to]     ; message
    mov rdx, 29                ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive server response
    call recv_response

    ; Send DATA command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel data_command] ; message
    mov rdx, 6                 ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive server response
    call recv_response

    ; Send email body
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel email_body]  ; message
    mov rdx, 41                ; message length
    xor r10, r10               ; flags
    syscall

    ; Receive server response
    call recv_response

    ; Send QUIT command
    mov rax, 44                ; syscall: sendto
    lea rsi, [rel quit_command]; message
    mov rdx, 6                 ; message length
    xor r10, r10               ; flags
    syscall

    ; Close socket
    mov rax, 3                 ; syscall: close
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

recv_response:
    ; Receive server response
    mov rax, 45                ; syscall: recvfrom
    lea rsi, [rel buffer]      ; buffer
    mov rdx, 4096              ; buffer length
    xor r10, r10               ; flags
    syscall
    ret


48.asm
;Content of 48.asm
section .data
    firewall_rule db "iptables -A INPUT -p tcp --dport 22 -j ACCEPT", 0
    rule_len equ $-firewall_rule

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Open /dev/null for redirection
    mov rax, 2                 ; syscall: open
    lea rdi, [rel dev_null]    ; filename
    mov rsi, 0                 ; flags: O_RDONLY
    syscall
    mov rbx, rax               ; store file descriptor

    ; Redirect stdout to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 1                 ; new file descriptor
    syscall

    ; Redirect stderr to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 2                 ; new file descriptor
    syscall

    ; Close /dev/null file descriptor
    mov rax, 3                 ; syscall: close
    mov rdi, rbx               ; file descriptor
    syscall

    ; Execute the firewall rule
    mov rax, 59                ; syscall: execve
    lea rdi, [rel shell]       ; filename
    lea rsi, [rel cmd_argv]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

section .rodata
shell db "/bin/sh", 0
cmd_argv dq shell, shell_command, 0
shell_command db "-c", 0
dev_null db "/dev/null", 0


49.asm
;Content of 49.asm
section .data
    rule_add db "iptables -A INPUT -p tcp --dport 80 -j ACCEPT", 0
    rule_del db "iptables -D INPUT -p tcp --dport 80 -j ACCEPT", 0
    dev_null db "/dev/null", 0

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Open /dev/null for redirection
    mov rax, 2                 ; syscall: open
    lea rdi, [rel dev_null]    ; filename
    mov rsi, 0                 ; flags: O_RDONLY
    syscall
    mov rbx, rax               ; store file descriptor

    ; Redirect stdout to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 1                 ; new file descriptor
    syscall

    ; Redirect stderr to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 2                 ; new file descriptor
    syscall

    ; Close /dev/null file descriptor
    mov rax, 3                 ; syscall: close
    mov rdi, rbx               ; file descriptor
    syscall

    ; Add firewall rule
    lea rdi, [rel rule_add]
    call exec_command

    ; Simulate a delay or operation here
    ; For the sake of this example, we'll add a small loop to simulate processing
    mov rcx, 1000000000
delay_loop:
    loop delay_loop

    ; Delete firewall rule
    lea rdi, [rel rule_del]
    call exec_command

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

exec_command:
    ; Prepare to execute a shell command
    mov rax, 59                ; syscall: execve
    lea rsi, [rel cmd_argv]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall
    ret

section .rodata
shell db "/bin/sh", 0
cmd_argv dq shell, shell_command, 0
shell_command db "-c", 0


50.asm
;Content of 50.asm
section .data
    ping_command db "ping -c 4 example.com", 0
    traceroute_command db "traceroute example.com", 0
    dev_null db "/dev/null", 0

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Open /dev/null for redirection
    mov rax, 2                 ; syscall: open
    lea rdi, [rel dev_null]    ; filename
    mov rsi, 0                 ; flags: O_RDONLY
    syscall
    mov rbx, rax               ; store file descriptor

    ; Redirect stdout to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 1                 ; new file descriptor
    syscall

    ; Redirect stderr to /dev/null
    mov rax, 33                ; syscall: dup2
    mov rdi, rbx               ; old file descriptor
    mov rsi, 2                 ; new file descriptor
    syscall

    ; Close /dev/null file descriptor
    mov rax, 3                 ; syscall: close
    mov rdi, rbx               ; file descriptor
    syscall

    ; Execute ping command
    lea rdi, [rel ping_command]
    call exec_command

    ; Execute traceroute command
    lea rdi, [rel traceroute_command]
    call exec_command

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

exec_command:
    ; Prepare to execute a shell command
    mov rax, 59                ; syscall: execve
    lea rsi, [rel cmd_argv]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall
    ret

section .rodata
shell db "/bin/sh", 0
cmd_argv dq shell, shell_command, 0
shell_command db "-c", 0


51.asm
;Content of 51.asm
section .data
    ps_command db "ps -aux", 0
    kill_command db "kill -9 ", 0
    pid db "1234", 0 ; Placeholder PID, to be replaced with actual PID

section .bss
    buffer resb 4096           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Display running processes
    lea rdi, [rel ps_command]
    call exec_command

    ; Simulate a delay or operation here
    ; For the sake of this example, we'll add a small loop to simulate processing
    mov rcx, 1000000000
delay_loop:
    loop delay_loop

    ; Kill a specific process
    lea rdi, [rel kill_command]
    call exec_command_with_pid

    ; Exit the program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

exec_command:
    ; Prepare to execute a shell command
    mov rax, 59                ; syscall: execve
    lea rsi, [rel cmd_argv]    ; argv
    xor rdx, rdx               ; envp (NULL)
    syscall
    ret

exec_command_with_pid:
    ; Prepare the full kill command
    lea rsi, [rel kill_command]
    mov rcx, 6 + 4             ; Length of "kill -9 " plus length of PID
    mov rdi, rsi
    mov rsi, pid
    rep movsb

    ; Prepare to execute the kill command
    lea rdi, [rel kill_command]
    call exec_command
    ret

section .rodata
shell db "/bin/sh", 0
cmd_argv dq shell, shell_command, 0
shell_command db "-c", 0


52.asm
;Content of 52.asm
section .data
    thread_func_message db "Thread running...\n", 0
    thread_exit_message db "Thread exiting...\n", 0

section .bss
    stack resb 4096 * 2   ; Reserve stack space for two threads
    buffer resb 4096      ; Buffer for general use

section .text
    global _start

_start:
    ; Create a new thread
    mov rax, 56            ; syscall: clone
    mov rdi, rsp           ; stack pointer
    sub rdi, 4096          ; allocate stack for the new thread
    mov rsi, 0x202000      ; flags: CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD
    mov rdx, thread_func   ; function to run
    xor r10, r10           ; newtls (NULL)
    xor r8, r8             ; child_tidptr (NULL)
    xor r9, r9             ; parent_tidptr (NULL)
    syscall

    ; Simulate a delay in the main thread
    mov rcx, 1000000000
delay_loop:
    loop delay_loop

    ; Exit the main program
    mov rax, 60            ; syscall: exit
    xor rdi, rdi           ; status = 0
    syscall

thread_func:
    ; Print a message indicating the thread is running
    mov rax, 1             ; syscall: write
    mov rdi, 1             ; file descriptor: stdout
    lea rsi, [rel thread_func_message] ; message
    mov rdx, 16            ; message length
    syscall

    ; Simulate some work in the thread
    mov rcx, 500000000
thread_delay_loop:
    loop thread_delay_loop

    ; Print a message indicating the thread is exiting
    mov rax, 1             ; syscall: write
    mov rdi, 1             ; file descriptor: stdout
    lea rsi, [rel thread_exit_message] ; message
    mov rdx, 17            ; message length
    syscall

    ; Exit the thread
    mov rax, 60            ; syscall: exit
    xor rdi, rdi           ; status = 0
    syscall


53.asm
;Content of 53.asm
section .data
    message db "Hello from child process!", 0
    msg_len equ $-message

section .bss
    pipefd resq 2            ; Array to hold pipe file descriptors
    buffer resb 64           ; Buffer to receive the message

section .text
    global _start

_start:
    ; Create a pipe
    mov rax, 22              ; syscall: pipe
    lea rdi, [rel pipefd]    ; pipefd array
    syscall

    ; Fork the process
    mov rax, 57              ; syscall: fork
    syscall

    ; Check if we are in the child process
    test rax, rax
    jz child_process

    ; Parent process: close the read end of the pipe
    mov rdi, [pipefd]        ; read end
    mov rax, 3               ; syscall: close
    syscall

    ; Write a message to the pipe
    lea rsi, [rel message]   ; message
    mov rdx, msg_len         ; message length
    mov rdi, [pipefd+8]      ; write end
    mov rax, 1               ; syscall: write
    syscall

    ; Close the write end of the pipe
    mov rdi, [pipefd+8]      ; write end
    mov rax, 3               ; syscall: close
    syscall

    ; Wait for the child process to finish
    mov rax, 61              ; syscall: waitpid
    xor rdi, rdi             ; pid (0 means wait for any child)
    xor rsi, rsi             ; status (NULL)
    syscall

    ; Exit the parent process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall

child_process:
    ; Child process: close the write end of the pipe
    mov rdi, [pipefd+8]      ; write end
    mov rax, 3               ; syscall: close
    syscall

    ; Read the message from the pipe
    mov rdi, [pipefd]        ; read end
    lea rsi, [rel buffer]    ; buffer
    mov rdx, 64              ; buffer size
    mov rax, 0               ; syscall: read
    syscall

    ; Print the received message
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel buffer]    ; buffer
    syscall

    ; Close the read end of the pipe
    mov rdi, [pipefd]        ; read end
    mov rax, 3               ; syscall: close
    syscall

    ; Exit the child process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall


54.asm
;Content of 54.asm
section .data
    child_message db "Child process running with lower priority\n", 0
    child_msg_len equ $-child_message

    parent_message db "Parent process running with higher priority\n", 0
    parent_msg_len equ $-parent_message

section .text
    global _start

_start:
    ; Fork the process
    mov rax, 57              ; syscall: fork
    syscall

    ; Check if we are in the child process
    test rax, rax
    jz child_process

    ; Parent process: set higher priority (lower nice value)
    mov rax, 141             ; syscall: setpriority
    mov rdi, 0               ; which: PRIO_PROCESS
    xor rsi, rsi             ; who: current process
    mov rdx, -10             ; priority: -10 (higher priority)
    syscall

    ; Parent process: print message
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel parent_message] ; message
    mov rdx, parent_msg_len  ; message length
    syscall

    ; Wait for the child process to finish
    mov rax, 61              ; syscall: waitpid
    xor rdi, rdi             ; pid (0 means wait for any child)
    xor rsi, rsi             ; status (NULL)
    syscall

    ; Exit the parent process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall

child_process:
    ; Child process: set lower priority (higher nice value)
    mov rax, 141             ; syscall: setpriority
    mov rdi, 0               ; which: PRIO_PROCESS
    xor rsi, rsi             ; who: current process
    mov rdx, 10              ; priority: 10 (lower priority)
    syscall

    ; Child process: print message
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel child_message] ; message
    mov rdx, child_msg_len   ; message length
    syscall

    ; Exit the child process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall


55.asm
;Content of 55.asm
section .data
    shared_memory db "Shared memory content", 0
    shared_memory_len equ $-shared_memory

    parent_message db "Parent process accessing shared memory: ", 0
    parent_msg_len equ $-parent_message

    child_message db "Child process accessing shared memory: ", 0
    child_msg_len equ $-child_message

section .bss
    buffer resb 64           ; Buffer for receiving data

section .text
    global _start

_start:
    ; Create a pipe for IPC
    mov rax, 22              ; syscall: pipe
    lea rdi, [rel pipefd]    ; pipefd array
    syscall

    ; Fork the process
    mov rax, 57              ; syscall: fork
    syscall

    ; Check if we are in the child process
    test rax, rax
    jz child_process

    ; Parent process: close the read end of the pipe
    mov rdi, [pipefd]        ; read end
    mov rax, 3               ; syscall: close
    syscall

    ; Parent process: write to the shared memory
    lea rsi, [rel shared_memory] ; message
    mov rdx, shared_memory_len  ; message length
    mov rdi, [pipefd+8]      ; write end
    mov rax, 1               ; syscall: write
    syscall

    ; Parent process: print message
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel parent_message] ; message
    mov rdx, parent_msg_len  ; message length
    syscall

    ; Wait for the child process to finish
    mov rax, 61              ; syscall: waitpid
    xor rdi, rdi             ; pid (0 means wait for any child)
    xor rsi, rsi             ; status (NULL)
    syscall

    ; Close the write end of the pipe
    mov rdi, [pipefd+8]      ; write end
    mov rax, 3               ; syscall: close
    syscall

    ; Exit the parent process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall

child_process:
    ; Child process: close the write end of the pipe
    mov rdi, [pipefd+8]      ; write end
    mov rax, 3               ; syscall: close
    syscall

    ; Child process: read from the shared memory
    mov rdi, [pipefd]        ; read end
    lea rsi, [rel buffer]    ; buffer
    mov rdx, 64              ; buffer size
    mov rax, 0               ; syscall: read
    syscall

    ; Child process: print message
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel child_message] ; message
    mov rdx, child_msg_len   ; message length
    syscall

    ; Print the received shared memory content
    mov rax, 1               ; syscall: write
    mov rdi, 1               ; file descriptor: stdout
    lea rsi, [rel buffer]    ; buffer
    syscall

    ; Close the read end of the pipe
    mov rdi, [pipefd]        ; read end
    mov rax, 3               ; syscall: close
    syscall

    ; Exit the child process
    mov rax, 60              ; syscall: exit
    xor rdi, rdi             ; status = 0
    syscall


56.asm
;Content of 56.asm
section .data
    thread1_message db "Thread 1 running...\n", 0
    thread2_message db "Thread 2 running...\n", 0
    thread1_exit db "Thread 1 exiting...\n", 0
    thread2_exit db "Thread 2 exiting...\n", 0

section .bss
    mutex resb 1               ; Mutex for thread synchronization
    stack1 resb 4096           ; Stack for thread 1
    stack2 resb 4096           ; Stack for thread 2

section .text
    global _start

_start:
    ; Initialize the mutex to unlocked state
    mov byte [mutex], 0

    ; Create thread 1
    mov rax, 56                ; syscall: clone
    mov rdi, rsp               ; stack pointer
    sub rdi, 4096              ; allocate stack for the new thread
    mov rsi, 0x202000          ; flags: CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD
    mov rdx, thread1_func      ; function to run
    xor r10, r10               ; newtls (NULL)
    xor r8, r8                 ; child_tidptr (NULL)
    xor r9, r9                 ; parent_tidptr (NULL)
    syscall

    ; Create thread 2
    mov rax, 56                ; syscall: clone
    mov rdi, rsp               ; stack pointer
    sub rdi, 4096              ; allocate stack for the new thread
    mov rsi, 0x202000          ; flags: CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD
    mov rdx, thread2_func      ; function to run
    xor r10, r10               ; newtls (NULL)
    xor r8, r8                 ; child_tidptr (NULL)
    xor r9, r9                 ; parent_tidptr (NULL)
    syscall

    ; Main thread: simulate some work
    mov rcx, 1000000000
delay_loop:
    loop delay_loop

    ; Exit the main program
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

thread1_func:
    ; Thread 1: acquire the mutex
    call acquire_mutex

    ; Print thread 1 message
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel thread1_message] ; message
    mov rdx, 17                ; message length
    syscall

    ; Simulate some work
    mov rcx, 500000000
thread1_delay_loop:
    loop thread1_delay_loop

    ; Print thread 1 exit message
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel thread1_exit] ; message
    mov rdx, 18                ; message length
    syscall

    ; Release the mutex
    call release_mutex

    ; Exit thread 1
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

thread2_func:
    ; Thread 2: acquire the mutex
    call acquire_mutex

    ; Print thread 2 message
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel thread2_message] ; message
    mov rdx, 17                ; message length
    syscall

    ; Simulate some work
    mov rcx, 500000000
thread2_delay_loop:
    loop thread2_delay_loop

    ; Print thread 2 exit message
    mov rax, 1                 ; syscall: write
    mov rdi, 1                 ; file descriptor: stdout
    lea rsi, [rel thread2_exit] ; message
    mov rdx, 18                ; message length
    syscall

    ; Release the mutex
    call release_mutex

    ; Exit thread 2
    mov rax, 60                ; syscall: exit
    xor rdi, rdi               ; status = 0
    syscall

acquire_mutex:
    ; Spinlock to acquire the mutex
    spinlock:
        xchg al, [mutex]
        test al, al
        jnz spinlock
    ret

release_mutex:
    ; Release the mutex
    mov byte [mutex], 0
    ret


57.asm
;Content of 57.asm
section .data
    migrate_message db "Process migrated to another CPU\n", 0
    migrate_msg_len equ $-migrate_message

section .bss

section .text
    global _start

_start:
    ; Get the current CPU
    mov rax, 318              ; syscall: sched_getaffinity
    mov rdi, 0                ; pid (0 for calling process)
    mov rsi, 8                ; cpusetsize
    lea rdx, [rel cpuset]     ; mask
    syscall

    ; Print initial CPU affinity
    call print_cpu_affinity

    ; Set affinity to another CPU (CPU 1)
    mov rax, 203              ; syscall: sched_setaffinity
    mov rdi, 0                ; pid (0 for calling process)
    mov rsi, 8                ; cpusetsize
    lea rdx, [rel new_cpuset] ; mask
    syscall

    ; Print new CPU affinity
    call print_cpu_affinity

    ; Simulate some work
    mov rcx, 1000000000
work_loop:
    loop work_loop

    ; Exit the program
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

print_cpu_affinity:
    ; Print message indicating process migration
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel migrate_message] ; message
    mov rdx, migrate_msg_len  ; message length
    syscall
    ret

section .rodata
cpuset dq 1                   ; Initial CPU set (CPU 0)
new_cpuset dq 2               ; New CPU set (CPU 1)


58.asm
;Content of 58.asm
section .data
    suspension_message db "Process suspended\n", 0
    resumption_message db "Process resumed\n", 0

section .bss
    buffer resb 64            ; Buffer for receiving data

section .text
    global _start

_start:
    ; Fork the process
    mov rax, 57               ; syscall: fork
    syscall

    ; Check if we are in the child process
    test rax, rax
    jz child_process

    ; Parent process: simulate some work
    mov rcx, 1000000000
parent_work_loop:
    loop parent_work_loop

    ; Suspend the child process
    mov rax, 62               ; syscall: kill
    test rax, rax
    js suspend_error
    mov rdi, rax              ; PID of child
    mov rsi, 19               ; signal: SIGSTOP
    syscall

    ; Print suspension message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel suspension_message] ; message
    mov rdx, 17               ; message length
    syscall

    ; Simulate some delay
    mov rcx, 500000000
suspension_delay_loop:
    loop suspension_delay_loop

    ; Resume the child process
    mov rax, 62               ; syscall: kill
    mov rdi, rax              ; PID of child
    mov rsi, 18               ; signal: SIGCONT
    syscall

    ; Print resumption message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel resumption_message] ; message
    mov rdx, 16               ; message length
    syscall

    ; Wait for the child process to finish
    mov rax, 61               ; syscall: waitpid
    xor rdi, rdi              ; pid (0 means wait for any child)
    xor rsi, rsi              ; status (NULL)
    syscall

    ; Exit the parent process
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

child_process:
    ; Child process: simulate some work
    mov rcx, 1000000000
child_work_loop:
    loop child_work_loop

    ; Exit the child process
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

suspend_error:
    ; Print error message if suspension fails
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel suspension_message] ; message
    mov rdx, 24               ; message length
    syscall
    jmp _start


59.asm
;Content of 59.asm
section .data
    termination_message db "Child process terminated\n", 0
    child_message db "Child process running...\n", 0

section .bss
    buffer resb 64            ; Buffer for receiving data

section .text
    global _start

_start:
    ; Fork the process
    mov rax, 57               ; syscall: fork
    syscall

    ; Check if we are in the child process
    test rax, rax
    jz child_process

    ; Parent process: wait for the child process to finish
    mov rax, 61               ; syscall: waitpid
    xor rdi, rdi              ; pid (0 means wait for any child)
    xor rsi, rsi              ; status (NULL)
    syscall

    ; Print termination message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel termination_message] ; message
    mov rdx, 24               ; message length
    syscall

    ; Exit the parent process
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

child_process:
    ; Child process: print running message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel child_message] ; message
    mov rdx, 24               ; message length
    syscall

    ; Simulate some work
    mov rcx, 1000000000
child_work_loop:
    loop child_work_loop

    ; Exit the child process
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall


60.asm
;Content of 60.asm
section .data
    resource_allocation_message db "Resource allocated to process\n", 0
    resource_release_message db "Resource released from process\n", 0
    allocation_error_message db "Resource allocation failed\n", 0
    release_error_message db "Resource release failed\n", 0

section .bss
    buffer resb 64            ; Buffer for receiving data

section .text
    global _start

_start:
    ; Allocate resources (simulated by opening a file)
    mov rax, 2                ; syscall: open
    lea rdi, [rel file_name]  ; filename
    mov rsi, 577              ; flags: O_CREAT | O_RDWR
    mov rdx, 644              ; mode: S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
    syscall
    test rax, rax
    js allocation_error

    ; Store file descriptor
    mov rbx, rax

    ; Print resource allocation message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel resource_allocation_message] ; message
    mov rdx, 29               ; message length
    syscall

    ; Simulate some work with the allocated resource
    mov rcx, 1000000000
work_loop:
    loop work_loop

    ; Release resources (close the file)
    mov rax, 3                ; syscall: close
    mov rdi, rbx              ; file descriptor
    syscall
    test rax, rax
    js release_error

    ; Print resource release message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel resource_release_message] ; message
    mov rdx, 28               ; message length
    syscall

    ; Exit the program
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

allocation_error:
    ; Print allocation error message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel allocation_error_message] ; message
    mov rdx, 27               ; message length
    syscall
    jmp _start

release_error:
    ; Print release error message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel release_error_message] ; message
    mov rdx, 26               ; message length
    syscall
    jmp _start

section .rodata
file_name db "/tmp/resource_file", 0


61.asm
;Content of 61.asm
section .data
    username_prompt db "Enter username: ", 0
    password_prompt db "Enter password: ", 0
    login_success db "Login successful\n", 0
    login_failure db "Login failed\n", 0

    stored_username db "admin", 0
    stored_password db "password", 0

section .bss
    entered_username resb 32
    entered_password resb 32

section .text
    global _start

_start:
    ; Prompt for username
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel username_prompt] ; message
    mov rdx, 16               ; message length
    syscall

    ; Read username
    mov rax, 0                ; syscall: read
    mov rdi, 0                ; file descriptor: stdin
    lea rsi, [rel entered_username] ; buffer
    mov rdx, 32               ; buffer length
    syscall

    ; Prompt for password
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel password_prompt] ; message
    mov rdx, 16               ; message length
    syscall

    ; Read password
    mov rax, 0                ; syscall: read
    mov rdi, 0                ; file descriptor: stdin
    lea rsi, [rel entered_password] ; buffer
    mov rdx, 32               ; buffer length
    syscall

    ; Compare entered username with stored username
    lea rdi, [rel entered_username]
    lea rsi, [rel stored_username]
    call strcmp
    test rax, rax
    jnz login_fail

    ; Compare entered password with stored password
    lea rdi, [rel entered_password]
    lea rsi, [rel stored_password]
    call strcmp
    test rax, rax
    jnz login_fail

    ; Login successful
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel login_success] ; message
    mov rdx, 17               ; message length
    syscall
    jmp exit

login_fail:
    ; Login failed
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel login_failure] ; message
    mov rdx, 12               ; message length
    syscall

exit:
    ; Exit the program
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

strcmp:
    ; Compare two null-terminated strings
    xor rax, rax
    .compare_loop:
        lodsb
        scasb
        jne .not_equal
        test al, al
        jnz .compare_loop
        ret
    .not_equal:
        sub al, 1
        sbb rax, rax
        ret


62.asm
;Content of 62.asm
section .data
    file_name db "/tmp/secure_file", 0
    user_name db "admin", 0
    read_acl db "r--", 0
    write_acl db "-w-", 0
    exec_acl db "--x", 0
    access_granted db "Access granted\n", 0
    access_denied db "Access denied\n", 0

section .bss
    buffer resb 64
    user_buffer resb 32
    acl_buffer resb 32

section .text
    global _start

_start:
    ; Prompt for username
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel prompt_username] ; message
    mov rdx, prompt_username_len ; message length
    syscall

    ; Read username
    mov rax, 0                ; syscall: read
    mov rdi, 0                ; file descriptor: stdin
    lea rsi, [rel user_buffer] ; buffer
    mov rdx, 32               ; buffer length
    syscall

    ; Check if user is 'admin'
    lea rdi, [rel user_buffer]
    lea rsi, [rel user_name]
    call strcmp
    test rax, rax
    jnz access_denied

    ; Prompt for ACL type
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel prompt_acl] ; message
    mov rdx, prompt_acl_len   ; message length
    syscall

    ; Read ACL type
    mov rax, 0                ; syscall: read
    mov rdi, 0                ; file descriptor: stdin
    lea rsi, [rel acl_buffer] ; buffer
    mov rdx, 32               ; buffer length
    syscall

    ; Check ACL
    lea rdi, [rel acl_buffer]
    lea rsi, [rel read_acl]
    call strcmp
    test rax, rax
    jz grant_access

    lea rdi, [rel acl_buffer]
    lea rsi, [rel write_acl]
    call strcmp
    test rax, rax
    jz grant_access

    lea rdi, [rel acl_buffer]
    lea rsi, [rel exec_acl]
    call strcmp
    test rax, rax
    jz grant_access

access_denied:
    ; Print access denied message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel access_denied] ; message
    mov rdx, 14               ; message length
    syscall
    jmp exit

grant_access:
    ; Print access granted message
    mov rax, 1                ; syscall: write
    mov rdi, 1                ; file descriptor: stdout
    lea rsi, [rel access_granted] ; message
    mov rdx, 15               ; message length
    syscall

exit:
    ; Exit the program
    mov rax, 60               ; syscall: exit
    xor rdi, rdi              ; status = 0
    syscall

strcmp:
    ; Compare two null-terminated strings
    xor rax, rax
    .compare_loop:
        lodsb
        scasb
        jne .not_equal
        test al, al
        jnz .compare_loop
        ret
    .not_equal:
        sub al, 1
        sbb rax, rax
        ret

section .rodata
prompt_username db "Enter username: ", 0
prompt_username_len equ $-prompt_username
prompt_acl db "Enter ACL type (r--, -w-, --x): ", 0
prompt_acl_len equ $-prompt_acl


63.asm
;Content of 63.asm
section .data
    ; Define the key for encryption (simple Caesar cipher shift of 3)
    key db 3
    message db 'Hello, World!', 0  ; Null-terminated string

section .bss
    encrypted resb 256  ; Buffer for encrypted message
    decrypted resb 256  ; Buffer for decrypted message

section .text
    global _start

_start:
    ; Encrypt the message
    mov rsi, message     ; Source message
    mov rdi, encrypted   ; Destination for encrypted message
    call encrypt

    ; Decrypt the message
    mov rsi, encrypted   ; Source encrypted message
    mov rdi, decrypted   ; Destination for decrypted message
    call decrypt

    ; Exit the program
    mov eax, 60          ; syscall: exit
    xor edi, edi         ; status: 0
    syscall

encrypt:
    push rsi             ; Save rsi
    push rdi             ; Save rdi

    mov cl, [key]        ; Load the key

enc_loop:
    lodsb                ; Load byte from [rsi] into al
    test al, al          ; Check for null terminator
    jz enc_done          ; If null, end loop

    add al, cl           ; Encrypt the character
    stosb                ; Store the encrypted character in [rdi]
    jmp enc_loop

enc_done:
    stosb                ; Write the null terminator
    pop rdi              ; Restore rdi
    pop rsi              ; Restore rsi
    ret

decrypt:
    push rsi             ; Save rsi
    push rdi             ; Save rdi

    mov cl, [key]        ; Load the key

dec_loop:
    lodsb                ; Load byte from [rsi] into al
    test al, al          ; Check for null terminator
    jz dec_done          ; If null, end loop

    sub al, cl           ; Decrypt the character
    stosb                ; Store the decrypted character in [rdi]
    jmp dec_loop

dec_done:
    stosb                ; Write the null terminator
    pop rdi              ; Restore rdi
    pop rsi              ; Restore rsi
    ret


64.asm
;Content of 64.asm
section .data
    logfile db 'security.log', 0    ; Log file name
    logmsg db 'User login attempt', 10, 0  ; Log message with newline

section .bss
    fd resb 1  ; File descriptor

section .text
    global _start

_start:
    ; Open the log file for writing (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2          ; syscall: open
    mov rdi, logfile    ; filename
    mov esi, 2 | 64 | 1024 ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420        ; mode: 0644
    syscall
    mov [fd], al        ; Save the file descriptor

    ; Write the log message
    mov eax, 1          ; syscall: write
    mov rdi, [fd]       ; file descriptor
    mov rsi, logmsg     ; message to write
    mov edx, 18         ; message length
    syscall

    ; Close the log file
    mov eax, 3          ; syscall: close
    mov rdi, [fd]       ; file descriptor
    syscall

    ; Exit the program
    mov eax, 60         ; syscall: exit
    xor edi, edi        ; status: 0
    syscall


65.asm
;Content of 65.asm
section .data
    logfile db 'session.log', 0        ; Log file name
    loginmsg db 'User logged in: ', 0  ; Login message prefix
    logoutmsg db 'User logged out: ', 0 ; Logout message prefix
    timestamp db 32 dup(0)             ; Buffer for timestamp

section .bss
    fd resb 1            ; File descriptor
    msg resb 256         ; Buffer for log message

section .text
    extern time
    extern strftime
    extern localtime
    global _start

_start:
    ; Open the log file for writing (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, logfile        ; filename
    mov esi, 2 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], al            ; Save the file descriptor

    ; Get the current time
    call get_timestamp

    ; Log user login
    mov rsi, loginmsg       ; Login message prefix
    call log_event

    ; Simulate some delay (e.g., user session duration)
    mov eax, 162            ; syscall: nanosleep
    xor edi, edi            ; Use rsi and rdi as timespec struct
    syscall

    ; Get the current time again
    call get_timestamp

    ; Log user logout
    mov rsi, logoutmsg      ; Logout message prefix
    call log_event

    ; Close the log file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to log an event (prefix in rsi, timestamp in timestamp buffer)
log_event:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

    mov rdi, msg            ; Destination buffer for log message
    call strcpy             ; Copy prefix to msg

    mov rdi, msg            ; Append timestamp to msg
    call strcat

    mov eax, 1              ; syscall: write
    mov rdi, [fd]           ; file descriptor
    mov rsi, msg            ; message to write
    mov rdx, 256            ; message length (max)
    syscall

    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to get the current timestamp and store it in timestamp buffer
get_timestamp:
    sub rsp, 8              ; Align stack for call
    call time
    add rsp, 8              ; Restore stack

    sub rsp, 8              ; Align stack for call
    call localtime
    add rsp, 8              ; Restore stack

    mov rdi, timestamp      ; Destination buffer for formatted time
    call strftime
    ret

; Helper functions for string operations
strcpy:
    lodsb
    stosb
    test al, al
    jnz strcpy
    ret

strcat:
    lodsb
    stosb
    test al, al
    jnz strcat
    ret


66.asm
;Content of 66.asm
section .data
    salt db 's@lt1234', 0           ; Salt for hashing
    password db 'password123', 0    ; Example password (to be hashed)
    hashmsg db 'Password hash: ', 0 ; Message for displaying the hash
    inputmsg db 'Enter password: ', 0 ; Prompt for user input
    successmsg db 'Password match', 10, 0 ; Success message
    failmsg db 'Password mismatch', 10, 0 ; Failure message

section .bss
    hashed_password resb 64         ; Buffer for hashed password
    user_input resb 64              ; Buffer for user input
    user_input_hashed resb 64       ; Buffer for hashed user input

section .text
    extern printf
    extern scanf
    global _start

_start:
    ; Hash the password
    mov rsi, password
    mov rdi, hashed_password
    call hash_password

    ; Display the hashed password
    mov rsi, hashmsg
    call print_message
    mov rsi, hashed_password
    call print_message

    ; Prompt for user input
    mov rsi, inputmsg
    call print_message
    mov rdi, user_input
    call get_input

    ; Hash the user input
    mov rsi, user_input
    mov rdi, user_input_hashed
    call hash_password

    ; Verify the password
    mov rsi, hashed_password
    mov rdi, user_input_hashed
    call verify_password

    ; Exit the program
    mov eax, 60          ; syscall: exit
    xor edi, edi         ; status: 0
    syscall

; Function to hash a password (source in rsi, destination in rdi)
hash_password:
    ; Simple hashing function (XOR with salt)
    push rsi
    push rdi
    push rbx
    xor rcx, rcx

hash_loop:
    lodsb                ; Load byte from [rsi] into al
    test al, al          ; Check for null terminator
    jz hash_done         ; If null, end loop

    mov bl, [salt + rcx] ; Load salt byte
    xor al, bl           ; XOR password byte with salt byte
    stosb                ; Store hashed byte in [rdi]

    inc rcx              ; Increment salt index
    cmp byte [salt + rcx], 0 ; Check if end of salt
    jnz hash_loop        ; Loop if not end of salt

    xor rcx, rcx         ; Reset salt index to 0
    jmp hash_loop

hash_done:
    stosb                ; Write the null terminator
    pop rbx
    pop rdi
    pop rsi
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi             ; Save rsi
    mov rdi, rsi         ; Message to print
    xor eax, eax         ; Zero eax for syscall number
    call printf          ; Call printf
    pop rsi              ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi             ; Save rdi
    mov rsi, rdi         ; Buffer to store input
    mov rdi, user_input  ; Format string for scanf
    xor eax, eax         ; Zero eax for syscall number
    call scanf           ; Call scanf
    pop rdi              ; Restore rdi
    ret

; Function to verify password (hash1 in rsi, hash2 in rdi)
verify_password:
    push rsi
    push rdi

    mov rcx, 64          ; Compare 64 bytes
verify_loop:
    lodsb                ; Load byte from [rsi] into al
    scasb                ; Compare byte from [rdi] with al
    jne password_fail    ; If not equal, jump to fail
    loop verify_loop     ; Loop until all bytes are compared

    ; Password match
    mov rsi, successmsg
    call print_message
    jmp verify_done

password_fail:
    ; Password mismatch
    mov rsi, failmsg
    call print_message

verify_done:
    pop rdi
    pop rsi
    ret


67.asm
;Content of 67.asm
section .data
    filename db 'systemfile.txt', 0     ; File to check
    checksummsg db 'Checksum: ', 0      ; Message for displaying the checksum
    verifymessage db 'Verifying file...', 10, 0 ; Verification message
    successmsg db 'File is intact', 10, 0       ; Success message
    failmsg db 'File has been modified', 10, 0  ; Failure message

section .bss
    fd resb 1            ; File descriptor
    buffer resb 256      ; Buffer for reading file content
    checksum resd 1      ; Checksum value

section .text
    extern printf
    extern open
    extern read
    extern close
    global _start

_start:
    ; Open the file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file and compute checksum
    mov rsi, buffer
    call compute_checksum

    ; Display the computed checksum
    mov rsi, checksummsg
    call print_message
    mov eax, [checksum]
    call print_number

    ; Verify the file integrity
    mov rsi, verifymessage
    call print_message
    call verify_checksum

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to compute checksum (buffer in rsi)
compute_checksum:
    push rsi                ; Save rsi
    xor ecx, ecx            ; Initialize checksum to 0

checksum_loop:
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov edx, 256            ; number of bytes to read
    syscall
    test rax, rax           ; Check if end of file
    jz checksum_done        ; If end of file, exit loop

    mov rdi, rsi            ; Buffer to read into
    mov rcx, rax            ; Number of bytes read

add_checksum:
    lodsb                   ; Load byte from [rsi] into al
    add dword [checksum], eax ; Add byte value to checksum
    loop add_checksum       ; Loop for all bytes read

    jmp checksum_loop       ; Read more data

checksum_done:
    pop rsi                 ; Restore rsi
    ret

; Function to verify checksum
verify_checksum:
    ; Here we compare the current checksum with an expected value
    ; For simplicity, we assume the expected checksum is 12345
    mov eax, [checksum]
    cmp eax, 12345
    je checksum_match

    ; Checksum mismatch
    mov rsi, failmsg
    call print_message
    jmp verify_done

checksum_match:
    ; Checksum match
    mov rsi, successmsg
    call print_message

verify_done:
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi             ; Save rsi
    mov rdi, rsi         ; Message to print
    xor eax, eax         ; Zero eax for syscall number
    call printf          ; Call printf
    pop rsi              ; Restore rsi
    ret

; Function to print a number (number in eax)
print_number:
    ; Print the number in eax as a decimal
    push rax             ; Save rax
    push rdi             ; Save rdi

    ; Convert number to string
    mov rdi, buffer + 255
    mov byte [rdi], 0
print_number_loop:
    xor rdx, rdx
    mov ebx, 10
    div ebx
    add dl, '0'
    dec rdi
    mov [rdi], dl
    test eax, eax
    jnz print_number_loop

    ; Print the string
    mov rsi, rdi
    mov rdi, rsi
    xor eax, eax
    call printf

    pop rdi              ; Restore rdi
    pop rax              ; Restore rax
    ret


68.asm
;Content of 68.asm
section .data
    filename db 'scanfile.txt', 0       ; File to scan
    virus_signature db 'VIRUS', 0       ; Virus signature to look for
    sig_length equ $ - virus_signature  ; Length of the virus signature
    scanmsg db 'Scanning file...', 10, 0 ; Scanning message
    cleanmsg db 'File is clean', 10, 0   ; Clean file message
    infectedmsg db 'File is infected', 10, 0 ; Infected file message

section .bss
    fd resb 1            ; File descriptor
    buffer resb 256      ; Buffer for reading file content

section .text
    extern printf
    extern open
    extern read
    extern close
    global _start

_start:
    ; Open the file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Display scanning message
    mov rsi, scanmsg
    call print_message

    ; Read the file and scan for the virus signature
    mov rsi, buffer
    call scan_for_virus

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to scan for the virus signature (buffer in rsi)
scan_for_virus:
    push rsi                ; Save rsi
    push rdi                ; Save rdi
    push rbx                ; Save rbx

scan_loop:
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov edx, 256            ; number of bytes to read
    syscall
    test rax, rax           ; Check if end of file
    jz scan_done            ; If end of file, exit loop

    mov rcx, rax            ; Number of bytes read
    mov rdi, buffer         ; Buffer to scan

scan_bytes:
    mov rsi, virus_signature ; Virus signature to compare
    mov rbx, sig_length     ; Length of the virus signature
    repe cmpsb              ; Compare signature with buffer
    je virus_detected       ; If match, jump to virus detected
    inc rdi                 ; Move to next byte in buffer
    loop scan_bytes         ; Loop for all bytes read

    jmp scan_loop           ; Read more data

virus_detected:
    ; Virus detected
    mov rsi, infectedmsg
    call print_message
    jmp scan_done

scan_done:
    ; No virus detected
    mov rsi, cleanmsg
    call print_message

    pop rbx                ; Restore rbx
    pop rdi                ; Restore rdi
    pop rsi                ; Restore rsi
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi             ; Save rsi
    mov rdi, rsi         ; Message to print
    xor eax, eax         ; Zero eax for syscall number
    call printf          ; Call printf
    pop rsi              ; Restore rsi
    ret


69.asm
;Content of 69.asm
section .data
    logfile db 'firewall.log', 0          ; Log file name
    addmsg db 'Add rule: ', 0             ; Add rule message
    removemsg db 'Remove rule: ', 0       ; Remove rule message
    successmsg db 'Rule applied successfully', 10, 0 ; Success message
    inputmsg db 'Enter rule: ', 0         ; Prompt for user input

section .bss
    fd resb 1             ; File descriptor
    rule resb 256         ; Buffer for rule input
    logmsg resb 256       ; Buffer for log message

section .text
    extern printf
    extern scanf
    extern open
    extern write
    extern close
    global _start

_start:
    ; Open the log file for writing (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, logfile        ; filename
    mov esi, 2 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Prompt for user input to add or remove rule
    mov rsi, inputmsg
    call print_message
    mov rdi, rule           ; Buffer to store user input
    call get_input

    ; Determine action based on input (simple check for 'add' or 'remove')
    mov rsi, rule
    mov rdi, logmsg         ; Buffer for log message
    call determine_action

    ; Log the rule
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, logmsg         ; message to write
    mov rdx, 256            ; message length (max)
    syscall

    ; Apply the rule (placeholder, actual implementation depends on OS capabilities)
    mov rsi, successmsg
    call print_message

    ; Close the log file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to determine action based on user input (rule in rsi, logmsg in rdi)
determine_action:
    push rsi                ; Save rsi
    push rdi                ; Save rdi
    push rbx                ; Save rbx

    ; Check if the input starts with "add"
    mov rbx, rsi            ; Copy rule to rbx
    mov rcx, 3
    repe cmpsb              ; Compare first 3 bytes with "add"
    je add_rule

    ; Check if the input starts with "remove"
    mov rsi, rbx            ; Reset rsi to start of rule
    mov rcx, 6
    repe cmpsb              ; Compare first 6 bytes with "remove"
    je remove_rule

    ; Default action (invalid input)
    mov rsi, rule           ; Reset rsi to rule buffer
    mov rdi, rdi            ; Reset rdi to log message buffer
    call strcat             ; Append rule to log message

    jmp determine_done

add_rule:
    mov rsi, addmsg         ; Add rule message
    mov rdi, logmsg         ; Log message buffer
    call strcpy             ; Copy add message to log message
    mov rsi, rule           ; Rule buffer
    call strcat             ; Append rule to log message
    jmp determine_done

remove_rule:
    mov rsi, removemsg      ; Remove rule message
    mov rdi, logmsg         ; Log message buffer
    call strcpy             ; Copy remove message to log message
    mov rsi, rule           ; Rule buffer
    call strcat             ; Append rule to log message
    jmp determine_done

determine_done:
    pop rbx                 ; Restore rbx
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Helper functions for string operations
strcpy:
    lodsb
    stosb
    test al, al
    jnz strcpy
    ret

strcat:
    lodsb
    stosb
    test al, al
    jnz strcat
    ret


70.asm
;Content of 70.asm
section .data
    policyfile db 'security_policies.txt', 0 ; File to store security policies
    logfile db 'policy_manager.log', 0       ; Log file name
    addmsg db 'Add policy: ', 0              ; Add policy message
    removemsg db 'Remove policy: ', 0        ; Remove policy message
    listmsg db 'List policies', 10, 0        ; List policies message
    successmsg db 'Action completed successfully', 10, 0 ; Success message
    inputmsg db 'Enter policy: ', 0          ; Prompt for user input
    listallmsg db 'All policies:', 10, 0     ; Message for listing all policies

section .bss
    fd resb 1             ; File descriptor
    logfd resb 1          ; Log file descriptor
    buffer resb 256       ; Buffer for input and reading file
    logmsg resb 256       ; Buffer for log message

section .text
    extern printf
    extern scanf
    extern open
    extern write
    extern read
    extern close
    global _start

_start:
    ; Open the log file for writing (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, logfile        ; filename
    mov esi, 2 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [logfd], eax        ; Save the log file descriptor

    ; Prompt for user action
    mov rsi, inputmsg
    call print_message
    mov rdi, buffer         ; Buffer to store user input
    call get_input

    ; Determine action based on input (simple check for 'add', 'remove', or 'list')
    mov rsi, buffer
    mov rdi, logmsg         ; Buffer for log message
    call determine_action

    ; Log the action
    mov eax, 1              ; syscall: write
    mov edi, [logfd]        ; log file descriptor
    mov rsi, logmsg         ; message to write
    mov rdx, 256            ; message length (max)
    syscall

    ; Close the log file
    mov eax, 3              ; syscall: close
    mov rdi, [logfd]        ; log file descriptor
    syscall

    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to determine action based on user input (buffer in rsi, logmsg in rdi)
determine_action:
    push rsi                ; Save rsi
    push rdi                ; Save rdi
    push rbx                ; Save rbx

    ; Check if the input starts with "add"
    mov rbx, rsi            ; Copy buffer to rbx
    mov rcx, 3
    repe cmpsb              ; Compare first 3 bytes with "add"
    je add_policy

    ; Check if the input starts with "remove"
    mov rsi, rbx            ; Reset rsi to start of buffer
    mov rcx, 6
    repe cmpsb              ; Compare first 6 bytes with "remove"
    je remove_policy

    ; Check if the input starts with "list"
    mov rsi, rbx            ; Reset rsi to start of buffer
    mov rcx, 4
    repe cmpsb              ; Compare first 4 bytes with "list"
    je list_policies

    ; Default action (invalid input)
    mov rsi, buffer         ; Reset rsi to buffer
    mov rdi, rdi            ; Reset rdi to log message buffer
    call strcat             ; Append buffer to log message

    jmp determine_done

add_policy:
    mov rsi, addmsg         ; Add policy message
    mov rdi, logmsg         ; Log message buffer
    call strcpy             ; Copy add message to log message
    mov rsi, buffer         ; Buffer containing policy
    call strcat             ; Append policy to log message
    call add_policy_to_file ; Add policy to file
    jmp determine_done

remove_policy:
    mov rsi, removemsg      ; Remove policy message
    mov rdi, logmsg         ; Log message buffer
    call strcpy             ; Copy remove message to log message
    mov rsi, buffer         ; Buffer containing policy
    call strcat             ; Append policy to log message
    call remove_policy_from_file ; Remove policy from file
    jmp determine_done

list_policies:
    mov rsi, listmsg        ; List policies message
    mov rdi, logmsg         ; Log message buffer
    call strcpy             ; Copy list message to log message
    call list_policies_from_file ; List all policies from file
    jmp determine_done

determine_done:
    pop rbx                 ; Restore rbx
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to add policy to file
add_policy_to_file:
    ; Open the policy file for appending (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, policyfile     ; filename
    mov esi, 2 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Write the policy to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, buffer         ; policy to write
    mov rdx, 256            ; policy length (max)
    syscall

    ; Close the policy file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall
    ret

; Function to remove policy from file
remove_policy_from_file:
    ; Open the policy file for reading and writing (O_RDWR)
    mov eax, 2              ; syscall: open
    mov rdi, policyfile     ; filename
    mov esi, 2 | 1          ; flags: O_RDWR
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file and remove the policy (simple approach: overwrite with spaces)
    ; NOTE: This is a basic example. In a real implementation, you might read
    ; the entire file, modify the content, and write it back.
    mov rsi, buffer
    call remove_policy_in_buffer

    ; Write the modified buffer back to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, buffer         ; modified buffer
    mov rdx, 256            ; buffer length (max)
    syscall

    ; Close the policy file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall
    ret

; Function to list all policies from file
list_policies_from_file:
    ; Open the policy file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, policyfile     ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file and display its content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, buffer         ; buffer to read into
    mov rdx, 256            ; number of bytes to read
    syscall

    ; Display the policies
    mov rsi, listallmsg
    call print_message
    mov rsi, buffer
    call print_message

    ; Close the policy file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall
    ret

; Function to remove policy in buffer (simple approach: overwrite with spaces)
remove_policy_in_buffer:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

    ; Here you would implement logic to locate the policy in the buffer
    ; and overwrite it. This example just demonstrates the structure.
    ; In a real implementation, read the file into a buffer, modify it,
    ; and then write the buffer back to the file.

    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Helper functions for string operations
strcpy:
    lodsb
    stosb
    test al, al
    jnz strcpy
    ret

strcat:
    lodsb
    stosb
    test al, al
    jnz strcat
    ret


71.asm
;Content of 71.asm
section .data
    prompt db 'shell> ', 0               ; Command prompt
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    exit_cmd db 'exit', 0                ; Exit command
    buffer db 256 dup(0)                 ; Input buffer

section .bss

section .text
    extern printf
    extern scanf
    extern execve
    extern fork
    extern wait
    global _start

_start:
    ; Shell main loop
shell_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for exit command
    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_shell

    ; Execute the command
    mov rsi, buffer
    call execute_command

    jmp shell_loop

; Exit the shell
exit_shell:
    ; Exit the program
    mov eax, 60          ; syscall: exit
    xor edi, edi         ; status: 0
    syscall

; Function to execute a command (command in rsi)
execute_command:
    push rsi             ; Save rsi

    ; Fork the process
    mov eax, 57          ; syscall: fork
    syscall
    test eax, eax
    jnz wait_for_child   ; Parent process waits for child

    ; Child process executes the command
    mov rdi, rsi         ; Command to execute
    xor rsi, rsi         ; Arguments (none)
    xor rdx, rdx         ; Environment (none)
    call execve          ; Execute the command

    ; If execve fails, print unknown command message
    mov rsi, unknown_cmd
    call print_message

    ; Exit the child process
    mov eax, 60          ; syscall: exit
    xor edi, edi         ; status: 0
    syscall

wait_for_child:
    ; Parent process waits for the child to finish
    mov eax, 61          ; syscall: wait
    syscall
    pop rsi              ; Restore rsi
    ret

; Function to print a message (message in rsi)
print_message:
    push rsi             ; Save rsi
    mov rdi, rsi         ; Message to print
    xor eax, eax         ; Zero eax for syscall number
    call printf          ; Call printf
    pop rsi              ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi             ; Save rdi
    mov rsi, rdi         ; Buffer to store input
    xor eax, eax         ; Zero eax for syscall number
    call scanf           ; Call scanf
    pop rdi              ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi             ; Save rsi
    push rdi             ; Save rdi

strcmp_loop:
    lodsb                ; Load byte from [rsi] into al
    scasb                ; Compare byte from [rdi] with al
    jne strcmp_not_equal ; If not equal, jump to not equal
    test al, al          ; Check for null terminator
    jnz strcmp_loop      ; If not null, loop

strcmp_equal:
    xor eax, eax         ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1           ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi              ; Restore rdi
    pop rsi              ; Restore rsi
    ret


72.asm
;Content of 72.asm
section .data
    filename db 'editfile.txt', 0       ; File to edit
    prompt db 'editor> ', 0             ; Command prompt
    menu db 'Commands: read, write, append, delete, exit', 10, 0 ; Menu message
    readmsg db 'Reading file...', 10, 0 ; Read message
    writemsg db 'Enter text to write: ', 0 ; Write message
    appendmsg db 'Enter text to append: ', 0 ; Append message
    deletemsg db 'Deleting file content...', 10, 0 ; Delete message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    newline db 10, 0                    ; Newline character

section .bss
    fd resb 1              ; File descriptor
    text resb 256          ; Buffer for text input/output

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern write
    extern close
    extern unlink
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

editor_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, readmsg
    call strcmp
    je read_file

    mov rsi, buffer
    mov rdi, writemsg
    call strcmp
    je write_file

    mov rsi, buffer
    mov rdi, appendmsg
    call strcmp
    je append_file

    mov rsi, buffer
    mov rdi, deletemsg
    call strcmp
    je delete_file

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_editor

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp editor_loop

; Read file
read_file:
    ; Open the file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, text           ; buffer to read into
    mov rdx, 256            ; number of bytes to read
    syscall

    ; Print the file content
    mov rsi, text
    call print_message

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp editor_loop

; Write file
write_file:
    ; Open the file for writing (O_WRONLY | O_CREAT | O_TRUNC)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    mov esi, 1 | 64 | 512   ; flags: O_WRONLY | O_CREAT | O_TRUNC
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Prompt for text to write
    mov rsi, writemsg
    call print_message
    mov rdi, text           ; buffer to store input
    call get_input

    ; Write the text to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, text           ; buffer with text
    mov rdx, 256            ; number of bytes to write
    syscall

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp editor_loop

; Append to file
append_file:
    ; Open the file for appending (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    mov esi, 1 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Prompt for text to append
    mov rsi, appendmsg
    call print_message
    mov rdi, text           ; buffer to store input
    call get_input

    ; Write the text to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, text           ; buffer with text
    mov rdx, 256            ; number of bytes to write
    syscall

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp editor_loop

; Delete file content
delete_file:
    ; Unlink (delete) the file
    mov rdi, filename       ; filename
    call unlink

    mov rsi, deletemsg
    call print_message

    jmp editor_loop

; Exit the editor
exit_editor:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret


73.asm
;Content of 73.asm
section .data
    prompt db 'sysmon> ', 0             ; Command prompt
    menu db 'Commands: cpu, memory, exit', 10, 0 ; Menu message
    cpumsg db 'CPU Usage: ', 0          ; CPU usage message
    memmsg db 'Memory Usage: ', 0       ; Memory usage message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    newline db 10, 0                    ; Newline character

section .bss
    cpu_usage resb 8                    ; Buffer for CPU usage
    mem_usage resb 8                    ; Buffer for memory usage

section .text
    extern printf
    extern scanf
    extern sysinfo
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

sysmon_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, cpumsg
    call strcmp
    je show_cpu_usage

    mov rsi, buffer
    mov rdi, memmsg
    call strcmp
    je show_mem_usage

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_sysmon

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp sysmon_loop

; Show CPU usage
show_cpu_usage:
    ; Retrieve CPU usage (dummy value for illustration)
    ; In a real implementation, replace this with actual system call to retrieve CPU usage
    mov qword [cpu_usage], 20   ; Example CPU usage percentage

    ; Print CPU usage
    mov rsi, cpumsg
    call print_message
    mov rsi, cpu_usage
    call print_number

    jmp sysmon_loop

; Show memory usage
show_mem_usage:
    ; Retrieve memory usage (dummy value for illustration)
    ; In a real implementation, replace this with actual system call to retrieve memory usage
    mov qword [mem_usage], 4096 ; Example memory usage in MB

    ; Print memory usage
    mov rsi, memmsg
    call print_message
    mov rsi, mem_usage
    call print_number

    jmp sysmon_loop

; Exit the system monitor
exit_sysmon:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to print a number (number in rsi)
print_number:
    ; Convert number to string and print it
    mov rax, [rsi]          ; Load the number to print
    call itoa               ; Convert to string
    mov rsi, buffer         ; Buffer now contains the string
    call print_message
    ret

; Function to convert integer to ASCII (itoa)
itoa:
    push rdi                ; Save rdi
    mov rdi, buffer + 255   ; Point to the end of the buffer
    mov byte [rdi], 0       ; Null-terminate the string

itoa_loop:
    xor rdx, rdx
    mov rbx, 10
    div rbx                 ; Divide rax by 10
    add dl, '0'             ; Convert digit to ASCII
    dec rdi
    mov [rdi], dl           ; Store the digit
    test rax, rax           ; Check if rax is zero
    jnz itoa_loop           ; Repeat if not zero

    pop rdi                 ; Restore rdi
    ret


74.asm
;Content of 74.asm
section .data
    prompt db 'taskman> ', 0               ; Command prompt
    menu db 'Commands: list, kill [pid], exit', 10, 0 ; Menu message
    listmsg db 'Listing processes...', 10, 0 ; List processes message
    killmsg db 'Enter PID to kill: ', 0       ; Kill process message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                  ; Input buffer
    newline db 10, 0                      ; Newline character

section .bss
    pid resb 4                           ; Buffer for PID

section .text
    extern printf
    extern scanf
    extern fork
    extern execve
    extern kill
    extern wait
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

taskman_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, listmsg
    call strcmp
    je list_processes

    mov rsi, buffer
    mov rdi, killmsg
    call strcmp
    je kill_process

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_taskman

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp taskman_loop

; List processes
list_processes:
    ; For demonstration, we'll use a placeholder message
    ; In a real implementation, you would gather and list actual processes
    mov rsi, listmsg
    call print_message

    ; TODO: Implement actual process listing
    mov rsi, '1  bash', 10, 0
    call print_message
    mov rsi, '2  init', 10, 0
    call print_message
    mov rsi, '3  sshd', 10, 0
    call print_message

    jmp taskman_loop

; Kill process
kill_process:
    ; Prompt for PID to kill
    mov rsi, killmsg
    call print_message
    mov rdi, pid           ; Buffer to store input
    call get_input

    ; Convert PID string to integer
    mov rsi, pid
    call atoi
    mov edi, eax           ; Move PID to edi for syscall

    ; Kill the process
    mov eax, 62            ; syscall: kill
    xor esi, esi           ; signal: 0 (for demonstration purposes)
    syscall

    ; Check result
    test eax, eax
    js kill_failed

    ; Kill successful
    mov rsi, 'Process killed successfully', 10, 0
    call print_message
    jmp taskman_loop

kill_failed:
    mov rsi, 'Failed to kill process', 10, 0
    call print_message
    jmp taskman_loop

; Exit the task manager
exit_taskman:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to convert string to integer (ASCII to integer)
atoi:
    push rsi                ; Save rsi
    xor rax, rax            ; Clear rax (result)
    xor rcx, rcx            ; Clear rcx (multiplier)

atoi_loop:
    lodsb                   ; Load byte from [rsi] into al
    sub al, '0'             ; Convert ASCII to integer
    js atoi_done            ; If not a digit, done
    add rax, rcx            ; Add previous result
    mov rcx, 10             ; Set multiplier to 10
    mul rcx                 ; Multiply by 10
    add rax, rdx            ; Add current digit
    jmp atoi_loop           ; Repeat for next character

atoi_done:
    pop rsi                 ; Restore rsi
    ret


75.asm
;Content of 75.asm
section .data
    prompt db 'fileexplorer> ', 0       ; Command prompt
    menu db 'Commands: list, view [filename], exit', 10, 0 ; Menu message
    listmsg db 'Listing files...', 10, 0 ; List files message
    viewmsg db 'Enter filename to view: ', 0 ; View file message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    newline db 10, 0                    ; Newline character

section .bss
    filename resb 256                   ; Buffer for filename
    file_content resb 1024              ; Buffer for file content

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern close
    extern opendir
    extern readdir
    extern closedir
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

fileexplorer_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, listmsg
    call strcmp
    je list_files

    mov rsi, buffer
    mov rdi, viewmsg
    call strcmp
    je view_file

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_fileexplorer

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp fileexplorer_loop

; List files
list_files:
    ; Open the current directory
    mov rdi, '.'
    call opendir
    test rax, rax
    js list_failed
    mov rbx, rax

list_next_file:
    ; Read the next directory entry
    mov rdi, rbx
    call readdir
    test rax, rax
    jz list_done

    ; Print the file name
    mov rsi, rax
    call print_message
    jmp list_next_file

list_done:
    ; Close the directory
    mov rdi, rbx
    call closedir

    jmp fileexplorer_loop

list_failed:
    mov rsi, 'Failed to list files', 10, 0
    call print_message
    jmp fileexplorer_loop

; View file
view_file:
    ; Prompt for filename to view
    mov rsi, viewmsg
    call print_message
    mov rdi, filename           ; Buffer to store input
    call get_input

    ; Open the file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    test eax, eax
    js view_failed
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Print the file content
    mov rsi, file_content
    call print_message

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp fileexplorer_loop

view_failed:
    mov rsi, 'Failed to open file', 10, 0
    call print_message
    jmp fileexplorer_loop

; Exit the file explorer
exit_fileexplorer:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret


76.asm
;Content of 76.asm
section .data
    prompt db 'pkgman> ', 0            ; Command prompt
    menu db 'Commands: install [pkg], remove [pkg], list, exit', 10, 0 ; Menu message
    installmsg db 'Enter package to install: ', 0 ; Install package message
    removemsg db 'Enter package to remove: ', 0 ; Remove package message
    listmsg db 'Listing installed packages...', 10, 0 ; List packages message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    pkgfile db 'packages.txt', 0        ; File to store installed packages

section .bss
    fd resb 1              ; File descriptor
    package resb 256       ; Buffer for package name
    file_content resb 1024 ; Buffer for file content

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern write
    extern close
    extern unlink
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

pkgman_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, installmsg
    call strcmp
    je install_package

    mov rsi, buffer
    mov rdi, removemsg
    call strcmp
    je remove_package

    mov rsi, buffer
    mov rdi, listmsg
    call strcmp
    je list_packages

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_pkgman

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp pkgman_loop

; Install package
install_package:
    ; Prompt for package to install
    mov rsi, installmsg
    call print_message
    mov rdi, package           ; Buffer to store input
    call get_input

    ; Open the package file for appending (O_WRONLY | O_CREAT | O_APPEND)
    mov eax, 2              ; syscall: open
    mov rdi, pkgfile        ; filename
    mov esi, 2 | 64 | 1024  ; flags: O_WRONLY | O_CREAT | O_APPEND
    mov edx, 420            ; mode: 0644
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Write the package name to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, package        ; buffer with package name
    mov rdx, 256            ; number of bytes to write
    syscall

    ; Close the package file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp pkgman_loop

; Remove package
remove_package:
    ; Prompt for package to remove
    mov rsi, removemsg
    call print_message
    mov rdi, package           ; Buffer to store input
    call get_input

    ; Open the package file for reading and writing (O_RDWR)
    mov eax, 2              ; syscall: open
    mov rdi, pkgfile        ; filename
    mov esi, 2 | 1          ; flags: O_RDWR
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Remove the package name from the file content
    mov rsi, file_content
    mov rdi, package
    call remove_line

    ; Write the modified content back to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer with modified content
    mov rdx, 1024           ; number of bytes to write
    syscall

    ; Close the package file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp pkgman_loop

; List packages
list_packages:
    ; Open the package file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, pkgfile        ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Print the file content
    mov rsi, listmsg
    call print_message
    mov rsi, file_content
    call print_message

    ; Close the package file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp pkgman_loop

; Exit the package manager
exit_pkgman:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to remove a line containing the package name from the buffer
remove_line:
    push rsi                ; Save rsi
    push rdi                ; Save rdi
    push rbx                ; Save rbx

remove_line_loop:
    lodsb                   ; Load byte from [rsi] into al
    test al, al             ; Check for null terminator
    jz remove_line_done     ; If null, done
    cmp al, [rdi]           ; Compare with package name
    jne remove_line_continue ; If not equal, continue
    ; Overwrite the line with spaces
    mov rbx, rsi
    sub rbx, 1
remove_line_space:
    lodsb
    stosb
    cmp al, 10              ; Check for newline
    jnz remove_line_space

remove_line_continue:
    jmp remove_line_loop

remove_line_done:
    pop rbx                 ; Restore rbx
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret


77.asm
;Content of 77.asm
section .data
    prompt db 'config> ', 0             ; Command prompt
    menu db 'Commands: view, set [key] [value], exit', 10, 0 ; Menu message
    viewmsg db 'Viewing system configuration...', 10, 0 ; View configuration message
    setmsg db 'Enter key and value to set: ', 0 ; Set configuration message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    configfile db 'config.txt', 0       ; Configuration file

section .bss
    fd resb 1              ; File descriptor
    key resb 128           ; Buffer for key
    value resb 128         ; Buffer for value
    file_content resb 1024 ; Buffer for file content

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern write
    extern close
    extern unlink
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

config_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, viewmsg
    call strcmp
    je view_config

    mov rsi, buffer
    mov rdi, setmsg
    call strcmp
    je set_config

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_config

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp config_loop

; View configuration
view_config:
    ; Open the configuration file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, configfile     ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Print the file content
    mov rsi, viewmsg
    call print_message
    mov rsi, file_content
    call print_message

    ; Close the configuration file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp config_loop

; Set configuration
set_config:
    ; Prompt for key and value to set
    mov rsi, setmsg
    call print_message
    mov rdi, buffer           ; Buffer to store input
    call get_input

    ; Parse key and value
    mov rsi, buffer
    call parse_key_value

    ; Open the configuration file for reading and writing (O_RDWR)
    mov eax, 2              ; syscall: open
    mov rdi, configfile     ; filename
    mov esi, 2 | 1          ; flags: O_RDWR
    syscall
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Update the configuration
    mov rsi, file_content
    mov rdi, key
    mov rdx, value
    call update_config

    ; Write the modified content back to the file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer with modified content
    mov rdx, 1024           ; number of bytes to write
    syscall

    ; Close the configuration file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp config_loop

; Exit the configuration tool
exit_config:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to parse key and value from buffer
parse_key_value:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

    ; Assume the format is "key value"
    ; Copy key
    mov rdi, key
parse_key_loop:
    lodsb
    cmp al, ' '
    je parse_value
    stosb
    jmp parse_key_loop

parse_value:
    mov byte [rdi], 0       ; Null-terminate the key
    mov rdi, value
parse_value_loop:
    lodsb
    stosb
    test al, al
    jnz parse_value_loop

    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to update configuration (config in rsi, key in rdi, value in rdx)
update_config:
    push rsi                ; Save rsi
    push rdi                ; Save rdi
    push rdx                ; Save rdx
    push rcx                ; Save rcx
    push rbx                ; Save rbx

    ; Search for the key in the configuration
    mov rbx, rsi            ; Backup config start
update_search_loop:
    mov rsi, rbx            ; Reset to start of line
    mov rcx, rdi            ; Key to search
update_search_key:
    lodsb
    scasb
    jne update_next_line
    test al, al
    jnz update_search_key

    ; Key found, update the value
    mov rdi, rsi            ; Move rdi to after the key
update_replace_value:
    lodsb
    cmp al, '='
    jne update_replace_value
    mov rdi, rsi            ; Move rdi to start of value
    mov rsi, rdx            ; Value to set
update_write_value:
    lodsb
    stosb
    test al, al
    jnz update_write_value

    pop rbx                 ; Restore rbx
    pop rcx                 ; Restore rcx
    pop rdx                 ; Restore rdx
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

update_next_line:
    mov rbx, rsi            ; Move to next line
    scasb
    test al, al
    jnz update_next_line
    jmp update_search_loop


78.asm
;Content of 78.asm
section .data
    prompt db 'diskutil> ', 0            ; Command prompt
    menu db 'Commands: usage, exit', 10, 0 ; Menu message
    usagemsg db 'Disk Usage:', 10, 0      ; Disk usage message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                 ; Input buffer

section .bss
    total_space resq 1                   ; Total disk space
    used_space resq 1                    ; Used disk space
    free_space resq 1                    ; Free disk space

section .text
    extern printf
    extern scanf
    extern statvfs
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

diskutil_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, usagemsg
    call strcmp
    je show_disk_usage

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_diskutil

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp diskutil_loop

; Show disk usage
show_disk_usage:
    ; Retrieve disk usage statistics
    ; Here, we'll simulate the disk usage information
    ; In a real implementation, replace this with actual system calls to retrieve disk usage
    mov qword [total_space], 500000      ; Example total space in MB
    mov qword [used_space], 250000       ; Example used space in MB
    mov qword [free_space], 250000       ; Example free space in MB

    ; Print disk usage information
    mov rsi, usagemsg
    call print_message

    mov rsi, 'Total Space: '
    call print_message
    mov rsi, total_space
    call print_number

    mov rsi, ' MB', 10, 0
    call print_message

    mov rsi, 'Used Space: '
    call print_message
    mov rsi, used_space
    call print_number

    mov rsi, ' MB', 10, 0
    call print_message

    mov rsi, 'Free Space: '
    call print_message
    mov rsi, free_space
    call print_number

    mov rsi, ' MB', 10, 0
    call print_message

    jmp diskutil_loop

; Exit the disk utility
exit_diskutil:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to print a number (number in rsi)
print_number:
    ; Convert number to string and print it
    mov rax, [rsi]          ; Load the number to print
    call itoa               ; Convert to string
    mov rsi, buffer         ; Buffer now contains the string
    call print_message
    ret

; Function to convert integer to ASCII (itoa)
itoa:
    push rdi                ; Save rdi
    mov rdi, buffer + 255   ; Point to the end of the buffer
    mov byte [rdi], 0       ; Null-terminate the string

itoa_loop:
    xor rdx, rdx
    mov rbx, 10
    div rbx                 ; Divide rax by 10
    add dl, '0'             ; Convert digit to ASCII
    dec rdi
    mov [rdi], dl           ; Store the digit
    test rax, rax           ; Check if rax is zero
    jnz itoa_loop           ; Repeat if not zero

    pop rdi                 ; Restore rdi
    ret


79.asm
;Content of 79.asm
section .data
    prompt db 'backup> ', 0             ; Command prompt
    menu db 'Commands: backup [filename], exit', 10, 0 ; Menu message
    backupmsg db 'Enter filename to backup: ', 0 ; Backup file message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                ; Input buffer
    bak_extension db '.bak', 0          ; Backup file extension

section .bss
    filename resb 256                   ; Buffer for filename
    file_content resb 1024              ; Buffer for file content

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern write
    extern close
    extern strcat
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

backup_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, backupmsg
    call strcmp
    je backup_file

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_backup

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp backup_loop

; Backup file
backup_file:
    ; Prompt for filename to backup
    mov rsi, backupmsg
    call print_message
    mov rdi, filename           ; Buffer to store input
    call get_input

    ; Open the file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    test eax, eax
    js backup_failed
    mov [fd], eax           ; Save the file descriptor

    ; Read the file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Close the file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Append ".bak" to the filename
    mov rsi, filename
    mov rdi, bak_extension
    call strcat

    ; Open the backup file for writing (O_WRONLY | O_CREAT | O_TRUNC)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; backup filename
    mov esi, 1 | 64 | 512   ; flags: O_WRONLY | O_CREAT | O_TRUNC
    mov edx, 420            ; mode: 0644
    syscall
    test eax, eax
    js backup_failed
    mov [fd], eax           ; Save the file descriptor

    ; Write the file content to the backup file
    mov eax, 1              ; syscall: write
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer with file content
    mov rdx, 1024           ; number of bytes to write
    syscall

    ; Close the backup file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    ; Print success message
    mov rsi, 'Backup completed successfully', 10, 0
    call print_message
    jmp backup_loop

backup_failed:
    mov rsi, 'Failed to backup file', 10, 0
    call print_message
    jmp backup_loop

; Exit the backup utility
exit_backup:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret

; Function to concatenate two strings (str1 in rsi, str2 in rdi)
strcat:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

    ; Move to the end of the first string
    mov rax, rsi
strcat_find_end:
    lodsb
    test al, al
    jnz strcat_find_end
    dec rsi                 ; Step back to null terminator

    ; Copy the second string to the end of the first
strcat_copy:
    lodsb
    stosb
    test al, al
    jnz strcat_copy

    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret


80.asm
;Content of 80.asm
section .data
    prompt db 'logviewer> ', 0            ; Command prompt
    menu db 'Commands: view [logfile], exit', 10, 0 ; Menu message
    viewmsg db 'Enter log file to view: ', 0 ; View log file message
    unknown_cmd db 'Unknown command', 10, 0 ; Unknown command message
    buffer db 256 dup(0)                  ; Input buffer

section .bss
    filename resb 256                     ; Buffer for filename
    file_content resb 1024                ; Buffer for file content

section .text
    extern printf
    extern scanf
    extern open
    extern read
    extern close
    global _start

_start:
    ; Display the menu
    mov rsi, menu
    call print_message

logviewer_loop:
    ; Display the prompt
    mov rsi, prompt
    call print_message

    ; Get user input
    mov rdi, buffer
    call get_input

    ; Check for commands
    mov rsi, buffer
    mov rdi, viewmsg
    call strcmp
    je view_log

    mov rsi, buffer
    mov rdi, exit_cmd
    call strcmp
    je exit_logviewer

    ; Unknown command
    mov rsi, unknown_cmd
    call print_message
    jmp logviewer_loop

; View log file
view_log:
    ; Prompt for log file to view
    mov rsi, viewmsg
    call print_message
    mov rdi, filename           ; Buffer to store input
    call get_input

    ; Open the log file for reading (O_RDONLY)
    mov eax, 2              ; syscall: open
    mov rdi, filename       ; filename
    xor esi, esi            ; flags: O_RDONLY
    syscall
    test eax, eax
    js view_failed
    mov [fd], eax           ; Save the file descriptor

    ; Read the log file content
    mov eax, 0              ; syscall: read
    mov edi, [fd]           ; file descriptor
    mov rsi, file_content   ; buffer to read into
    mov rdx, 1024           ; number of bytes to read
    syscall

    ; Print the log file content
    mov rsi, file_content
    call print_message

    ; Close the log file
    mov eax, 3              ; syscall: close
    mov rdi, [fd]           ; file descriptor
    syscall

    jmp logviewer_loop

view_failed:
    mov rsi, 'Failed to open log file', 10, 0
    call print_message
    jmp logviewer_loop

; Exit the log viewer
exit_logviewer:
    ; Exit the program
    mov eax, 60             ; syscall: exit
    xor edi, edi            ; status: 0
    syscall

; Function to print a message (message in rsi)
print_message:
    push rsi                ; Save rsi
    mov rdi, rsi            ; Message to print
    xor eax, eax            ; Zero eax for syscall number
    call printf             ; Call printf
    pop rsi                 ; Restore rsi
    ret

; Function to get user input (buffer in rdi)
get_input:
    push rdi                ; Save rdi
    mov rsi, rdi            ; Buffer to store input
    xor eax, eax            ; Zero eax for syscall number
    call scanf              ; Call scanf
    pop rdi                 ; Restore rdi
    ret

; Function to compare two strings (str1 in rsi, str2 in rdi)
strcmp:
    push rsi                ; Save rsi
    push rdi                ; Save rdi

strcmp_loop:
    lodsb                   ; Load byte from [rsi] into al
    scasb                   ; Compare byte from [rdi] with al
    jne strcmp_not_equal    ; If not equal, jump to not equal
    test al, al             ; Check for null terminator
    jnz strcmp_loop         ; If not null, loop

strcmp_equal:
    xor eax, eax            ; Set return value to 0 (equal)
    jmp strcmp_done

strcmp_not_equal:
    mov eax, 1              ; Set return value to 1 (not equal)

strcmp_done:
    pop rdi                 ; Restore rdi
    pop rsi                 ; Restore rsi
    ret


81.asm
;Content of 81.asm
section .data
    printer_status db 'ready', 0
    job_queue times 10 db 0  ; Queue to hold up to 10 print jobs

section .bss
    current_job resb 1
    job_count resb 1

section .text
    global _start

_start:
    ; Initialize job count
    mov byte [job_count], 0

    ; Check printer status
    call check_printer_status

    ; Main loop
main_loop:
    ; Check for new print jobs
    call check_for_new_jobs
    cmp byte [job_count], 0
    je .no_jobs

    ; Process the next job in the queue
    call process_next_job

.no_jobs:
    ; Wait for a while before checking again
    call wait
    jmp main_loop

check_printer_status:
    ; In a real implementation, this would query the printer hardware
    mov rax, 1  ; Assume printer is ready (1 = ready, 0 = not ready)
    ret

check_for_new_jobs:
    ; In a real implementation, this would check for new print jobs from the OS
    ; Simulate adding a job to the queue
    cmp byte [job_count], 10  ; Check if the queue is full
    je .queue_full
    ; Add a new job
    mov rbx, [job_count]
    inc rbx
    mov [job_queue + rbx - 1], 1  ; Add job (1 = job present)
    mov [job_count], rbx
.queue_full:
    ret

process_next_job:
    ; Get the next job from the queue
    mov rbx, [job_count]
    dec rbx
    mov [current_job], [job_queue + rbx]
    mov [job_queue + rbx], 0
    mov [job_count], rbx

    ; Send the job to the printer
    call send_to_printer

    ; Notify the user
    call notify_user
    ret

send_to_printer:
    ; Simulate sending data to the printer
    mov rax, [current_job]
    ; In a real implementation, this would send data to the printer hardware
    ret

notify_user:
    ; Notify the user that their job has been printed
    ; In a real implementation, this could use OS-specific APIs to send notifications
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret


82.asm
;Content of 82.asm
section .data
    service_status db 'stopped', 0
    service_commands db 'start', 'stop', 'status', 0
    current_command db 0

section .bss
    active_services resb 10  ; Track up to 10 active services
    command_buffer resb 10
    service_index resb 1

section .text
    global _start

_start:
    ; Initialize active services
    mov rdi, active_services
    mov rcx, 10
    rep stosb

    ; Main loop
main_loop:
    ; Get user command
    call get_user_command
    cmp byte [current_command], 0
    je .no_command

    ; Process command
    call process_command

.no_command:
    ; Monitor services
    call monitor_services
    jmp main_loop

get_user_command:
    ; Simulate reading a command (in a real implementation, read from input)
    mov byte [command_buffer], 'start'
    mov byte [command_buffer+1], 0
    mov [current_command], command_buffer
    ret

process_command:
    ; Check the command and act accordingly
    cmp byte [current_command], 'start'
    je start_service
    cmp byte [current_command], 'stop'
    je stop_service
    cmp byte [current_command], 'status'
    je status_service
    ret

start_service:
    ; Find a free slot in active_services
    mov rdi, active_services
    mov rcx, 10
    repe scasb
    jne .no_free_slot
    ; Mark the service as active
    mov byte [rdi-1], '1'
.no_free_slot:
    ret

stop_service:
    ; Find an active service to stop
    mov rdi, active_services
    mov rcx, 10
    repe scasb
    je .no_active_service
    ; Mark the service as inactive
    mov byte [rdi-1], 0
.no_active_service:
    ret

status_service:
    ; Print the status of services (in a real implementation, output to user)
    mov rdi, active_services
    mov rcx, 10
.print_status_loop:
    lodsb
    cmp al, 0
    je .service_inactive
    cmp al, '1'
    je .service_active
.service_inactive:
    ; Print 'inactive'
    jmp .next_service
.service_active:
    ; Print 'active'
.next_service:
    loop .print_status_loop
    ret

monitor_services:
    ; Check the status of all services and restart if necessary
    mov rdi, active_services
    mov rcx, 10
.monitor_loop:
    lodsb
    cmp al, '1'
    jne .next_monitor
    ; Check if service is running (in a real implementation, check actual status)
    ; Restart service if not running
.next_monitor:
    loop .monitor_loop
    ret


83.asm
;Content of 83.asm
section .data
    time_format db "HH:MM:SS", 0
    date_format db "YYYY-MM-DD", 0
    time_string db "00:00:00", 0
    date_string db "1970-01-01", 0

section .bss
    current_time resb 8   ; Store current time in HHMMSS format
    current_date resb 8   ; Store current date in YYYYMMDD format
    sync_server resb 16   ; Store IP or hostname of time server

section .text
    global _start

_start:
    ; Initialize current time and date
    call init_time_and_date

    ; Main loop
main_loop:
    ; Synchronize time with external server if needed
    call synchronize_time

    ; Check for user commands to set or get time and date
    call check_user_commands

    ; Manage alarms and timers
    call manage_alarms_and_timers

    jmp main_loop

init_time_and_date:
    ; Initialize the current time and date to system defaults
    mov byte [current_time], '0'
    mov byte [current_date], '0'
    ret

synchronize_time:
    ; Synchronize system time with an external time server
    ; This is a stub, in a real implementation it would contact the server and update the time
    ; For example, using the Network Time Protocol (NTP)
    ; mov [sync_server], "time.server.com"
    ret

check_user_commands:
    ; Check for user commands to set or get the time and date
    ; This is a stub, in a real implementation it would read commands from input
    ret

manage_alarms_and_timers:
    ; Check and manage alarms and timers
    ; This is a stub, in a real implementation it would handle the actual timer and alarm functionality
    ret

set_system_time:
    ; Set the current system time
    ; In a real implementation, this would involve system calls or hardware instructions
    ; Example time format: "HHMMSS"
    mov rsi, time_string
    mov rdi, current_time
    call copy_string
    ret

get_system_time:
    ; Get the current system time
    ; In a real implementation, this would involve system calls or hardware instructions
    mov rsi, current_time
    mov rdi, time_string
    call copy_string
    ret

set_system_date:
    ; Set the current system date
    ; Example date format: "YYYYMMDD"
    mov rsi, date_string
    mov rdi, current_date
    call copy_string
    ret

get_system_date:
    ; Get the current system date
    mov rsi, current_date
    mov rdi, date_string
    call copy_string
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 8
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


84.asm
;Content of 84.asm
section .data
    update_server db 'update.server.com', 0
    update_status db 'No updates available', 0
    update_path db '/updates/', 0

section .bss
    current_version resb 16  ; Store current system version
    latest_version resb 16   ; Store latest version from server
    update_file resb 256     ; Path to the update file

section .text
    global _start

_start:
    ; Initialize current system version
    call init_system_version

    ; Main loop
main_loop:
    ; Check for updates
    call check_for_updates

    ; If updates are available, download and apply them
    cmp byte [update_status], 'U'  ; 'U' means updates available
    jne .no_update

    ; Download updates
    call download_updates

    ; Apply updates
    call apply_updates

    ; Verify updates
    call verify_updates

    ; Update the current version
    call update_system_version

.no_update:
    ; Wait for a while before checking again
    call wait
    jmp main_loop

init_system_version:
    ; Initialize the current system version
    ; In a real implementation, this would read the version from system files
    mov rsi, 'v1.0.0'
    mov rdi, current_version
    call copy_string
    ret

check_for_updates:
    ; Check for updates from the server
    ; This is a stub, in a real implementation it would connect to the server
    ; and compare the latest version with the current version
    ; Simulate an update available
    mov rsi, 'v1.0.1'
    mov rdi, latest_version
    call copy_string
    mov byte [update_status], 'U'  ; Mark updates available
    ret

download_updates:
    ; Download the update file from the server
    ; This is a stub, in a real implementation it would download the file
    ; from the update server
    mov rsi, 'update_v1.0.1.bin'
    mov rdi, update_file
    call copy_string
    ret

apply_updates:
    ; Apply the downloaded updates
    ; This is a stub, in a real implementation it would apply the updates
    ; to the system files
    ret

verify_updates:
    ; Verify the applied updates
    ; This is a stub, in a real implementation it would verify the integrity
    ; and functionality of the updates
    ret

update_system_version:
    ; Update the current system version to the latest version
    mov rsi, latest_version
    mov rdi, current_version
    call copy_string
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 16
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


85.asm
;Content of 85.asm
section .data
    log_file db 'system.log', 0
    log_msg_info db 'INFO: ', 0
    log_msg_warn db 'WARNING: ', 0
    log_msg_error db 'ERROR: ', 0
    newline db 10, 0

section .bss
    log_buffer resb 256  ; Buffer to construct log messages

section .text
    global _start

_start:
    ; Initialize the log file
    call init_log_file

    ; Main loop to handle events
main_loop:
    ; Simulate logging an informational event
    mov rsi, log_msg_info
    mov rdi, 'System started successfully'
    call log_event

    ; Simulate logging a warning event
    mov rsi, log_msg_warn
    mov rdi, 'Low disk space'
    call log_event

    ; Simulate logging an error event
    mov rsi, log_msg_error
    mov rdi, 'Disk read failure'
    call log_event

    ; Wait for a while before logging the next event
    call wait
    jmp main_loop

init_log_file:
    ; Initialize the log file (create or clear the log file)
    ; This is a stub, in a real implementation it would use system calls
    ; to create or open the log file
    ret

log_event:
    ; Construct the log message
    mov rdi, log_buffer
    call copy_string  ; Copy the log level (INFO, WARNING, ERROR)

    ; Add the actual log message
    add rdi, 6  ; Move the destination pointer past the log level
    call copy_string

    ; Add a newline
    mov rdi, log_buffer + 6 + 256
    mov rsi, newline
    call copy_string

    ; Write the log message to the log file
    ; This is a stub, in a real implementation it would use system calls
    ; to write the log message to the log file
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


86.asm
;Content of 86.asm
section .data
    notification_info db 'INFO: ', 0
    notification_warn db 'WARNING: ', 0
    notification_error db 'CRITICAL: ', 0
    notification_msg db 'New notification: ', 0
    newline db 10, 0

section .bss
    notification_buffer resb 256  ; Buffer to construct notification messages
    notification_history resb 4096 ; Buffer to store notification history

section .text
    global _start

_start:
    ; Initialize notification manager
    call init_notifications

    ; Main loop to handle notifications
main_loop:
    ; Simulate generating an informational notification
    mov rsi, notification_info
    mov rdi, 'System check completed successfully'
    call generate_notification

    ; Simulate generating a warning notification
    mov rsi, notification_warn
    mov rdi, 'Battery level low'
    call generate_notification

    ; Simulate generating a critical notification
    mov rsi, notification_error
    mov rdi, 'Overheating detected'
    call generate_notification

    ; Wait for a while before generating the next notification
    call wait
    jmp main_loop

init_notifications:
    ; Initialize the notification manager (clear the history)
    ; This is a stub, in a real implementation it might involve more setup
    mov rdi, notification_history
    mov rcx, 4096
    xor rax, rax
    rep stosb
    ret

generate_notification:
    ; Construct the notification message
    mov rdi, notification_buffer
    call copy_string  ; Copy the notification type (INFO, WARNING, CRITICAL)

    ; Add the actual notification message
    add rdi, 8  ; Move the destination pointer past the notification type
    call copy_string

    ; Add a newline
    mov rdi, notification_buffer + 8 + 256
    mov rsi, newline
    call copy_string

    ; Display the notification to the user
    call display_notification

    ; Save the notification to history
    call save_notification_history
    ret

display_notification:
    ; Display the notification to the user
    ; This is a stub, in a real implementation it would use system calls
    ; to display the notification (e.g., pop-up, system tray message)
    ret

save_notification_history:
    ; Save the notification to the history buffer
    ; This is a stub, in a real implementation it would manage the history buffer
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


87.asm
;Content of 87.asm
section .data
    service_names db 'Service1', 0, 'Service2', 0, 'Service3', 0, 0
    service_status db 'stopped', 0, 'stopped', 0, 'stopped', 0
    command_start db 'start', 0
    command_stop db 'stop', 0
    command_status db 'status', 0
    newline db 10, 0

section .bss
    command_buffer resb 10  ; Buffer for user commands
    service_index resb 1

section .text
    global _start

_start:
    ; Initialize services
    call init_services

    ; Main loop to handle service commands
main_loop:
    ; Get user command
    call get_user_command
    cmp byte [command_buffer], 0
    je .no_command

    ; Process command
    call process_command

.no_command:
    ; Monitor services
    call monitor_services
    jmp main_loop

init_services:
    ; Initialize all services to stopped state
    ; This is a stub, in a real implementation it would initialize service data structures
    ret

get_user_command:
    ; Simulate reading a command (in a real implementation, read from input)
    ; Here we simulate a start command for Service1
    mov rsi, command_start
    mov rdi, 'Service1'
    call copy_string_to_command_buffer
    ret

process_command:
    ; Check the command and act accordingly
    mov rsi, command_buffer
    cmp byte [rsi], 'start'
    je start_service
    cmp byte [rsi], 'stop'
    je stop_service
    cmp byte [rsi], 'status'
    je status_service
    ret

start_service:
    ; Find the service index
    call find_service_index
    cmp byte [service_index], -1
    je .invalid_service

    ; Start the service
    mov rbx, service_index
    lea rdi, [service_status + rbx]
    mov byte [rdi], 'running'
.invalid_service:
    ret

stop_service:
    ; Find the service index
    call find_service_index
    cmp byte [service_index], -1
    je .invalid_service_stop

    ; Stop the service
    mov rbx, service_index
    lea rdi, [service_status + rbx]
    mov byte [rdi], 'stopped'
.invalid_service_stop:
    ret

status_service:
    ; Print the status of all services
    ; This is a stub, in a real implementation it would output to user
    ret

monitor_services:
    ; Check the status of all services and restart if necessary
    ; This is a stub, in a real implementation it would check actual status
    ret

find_service_index:
    ; Find the index of the service in the service_names list
    ; This is a stub, in a real implementation it would search through the list
    mov byte [service_index], 0  ; Simulate finding the first service
    ret

copy_string_to_command_buffer:
    ; Copy the string from rsi to the command buffer
    mov rdi, command_buffer
    call copy_string
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 10
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


88.asm
;Content of 88.asm
section .data
    task_queue db 10, 20, 30, 40, 0  ; Queue of task durations (in milliseconds)
    task_priorities db 1, 2, 3, 2, 0 ; Task priorities (1 = highest, 3 = lowest)
    current_task db 0
    task_index db 0
    max_tasks db 4
    cpu_time db 50  ; Total CPU time available for tasks in each cycle

section .bss
    remaining_time resb 1

section .text
    global _start

_start:
    ; Initialize remaining CPU time for this cycle
    mov al, [cpu_time]
    mov [remaining_time], al

    ; Main loop to handle scheduling
main_loop:
    ; Check if there are tasks to schedule
    call check_tasks
    cmp byte [task_index], [max_tasks]
    je .no_tasks

    ; Schedule and execute the next task
    call schedule_task

.no_tasks:
    ; Wait for the next scheduling cycle
    call wait
    jmp main_loop

check_tasks:
    ; Check the task queue for tasks
    ; In a real implementation, this would involve more complex logic
    ret

schedule_task:
    ; Find the highest priority task that can be executed within the remaining time
    mov bl, [max_tasks]
    xor bh, bh
    mov [task_index], bx

.find_task:
    mov al, [task_priorities + rbx]
    cmp al, 0
    je .no_more_tasks
    mov al, [task_queue + rbx]
    cmp al, [remaining_time]
    jae .skip_task

    ; Schedule this task
    mov [current_task], al
    call execute_task

    ; Update remaining time
    sub [remaining_time], al

.skip_task:
    inc rbx
    cmp rbx, [max_tasks]
    jne .find_task
.no_more_tasks:
    ret

execute_task:
    ; Execute the current task
    ; This is a stub, in a real implementation it would execute the actual task code
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret


89.asm
;Content of 89.asm
section .data
    restore_point_path db 'C:\restore_points\', 0
    restore_point_prefix db 'restore_point_', 0
    restore_point_extension db '.dat', 0
    latest_restore_point db 0
    current_restore_point db 0

section .bss
    restore_point_buffer resb 256
    restore_point_index resb 1

section .text
    global _start

_start:
    ; Main loop to handle restore utility functions
main_loop:
    ; Simulate user commands for creating and restoring points
    ; In a real implementation, these would be actual user inputs
    call create_restore_point
    call list_restore_points
    call restore_system

    ; Wait for the next command cycle
    call wait
    jmp main_loop

create_restore_point:
    ; Create a new restore point
    call generate_restore_point_name
    ; Save the system state to the restore point file
    ; This is a stub, in a real implementation it would involve copying system state to the file
    inc byte [latest_restore_point]
    ret

list_restore_points:
    ; List all available restore points
    ; This is a stub, in a real implementation it would read the directory and list files
    ret

restore_system:
    ; Restore the system to the selected restore point
    ; This is a stub, in a real implementation it would involve restoring the system state from the file
    ret

generate_restore_point_name:
    ; Generate a name for the new restore point
    mov rsi, restore_point_path
    mov rdi, restore_point_buffer
    call copy_string

    mov rsi, restore_point_prefix
    add rdi, 256
    call copy_string

    mov al, [latest_restore_point]
    add rdi, 256
    stosb

    mov rsi, restore_point_extension
    add rdi, 256
    call copy_string
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


90.asm
;Content of 90.asm
section .data
    crash_log_file db 'crash.log', 0
    crash_message db 'System has crashed. Details logged.', 0
    newline db 10, 0

section .bss
    crash_buffer resb 256  ; Buffer to construct crash log messages
    crash_details resb 1024 ; Buffer to store crash details

section .text
    global _start

_start:
    ; Main loop to simulate the system running
main_loop:
    ; Simulate a crash (in a real implementation, this would be triggered by an actual crash event)
    call capture_crash_information
    call log_crash_information
    call notify_user
    call report_crash

    ; Wait before simulating another crash
    call wait
    jmp main_loop

capture_crash_information:
    ; Capture details about the crash
    ; This is a stub, in a real implementation it would capture register states, memory dumps, etc.
    mov rsi, 'CRASH at 0x00400000: Illegal instruction'
    mov rdi, crash_details
    call copy_string
    ret

log_crash_information:
    ; Log the captured crash information to a file
    ; This is a stub, in a real implementation it would write to a log file using system calls
    mov rsi, crash_log_file
    mov rdi, crash_buffer
    call copy_string

    mov rsi, crash_details
    add rdi, 256
    call copy_string

    mov rsi, newline
    add rdi, 256
    call copy_string
    ret

notify_user:
    ; Notify the user that a crash has occurred
    ; This is a stub, in a real implementation it would display a message to the user
    mov rsi, crash_message
    call display_message
    ret

report_crash:
    ; Report the crash information to developers or support teams
    ; This is a stub, in a real implementation it might send the log file over the network
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


91.asm
;Content of 91.asm
section .data
    boot_config_file db 'boot.cfg', 0
    boot_devices db 'HDD0', 0, 'USB0', 0, 'CDROM0', 0, 0
    boot_sequence db 'HDD0', 0, 'USB0', 0, 0
    boot_options db 'normal', 0, 'safe', 0, 'recovery', 0, 0
    current_boot_option db 'normal', 0

section .bss
    config_buffer resb 256  ; Buffer to construct configuration settings
    user_input_buffer resb 32 ; Buffer for user input

section .text
    global _start

_start:
    ; Initialize boot configuration
    call load_boot_config

    ; Main loop to handle boot configuration settings
main_loop:
    ; Display current settings and menu
    call display_menu

    ; Get user input
    call get_user_input

    ; Process user input
    call process_user_input

    ; Save and apply settings
    call save_boot_config

    ; Wait before showing the menu again
    call wait
    jmp main_loop

load_boot_config:
    ; Load boot configuration from file
    ; This is a stub, in a real implementation it would read from a config file
    mov rsi, 'boot.cfg loaded'
    call display_message
    ret

display_menu:
    ; Display the current boot configuration and menu options
    ; This is a stub, in a real implementation it would display a menu to the user
    mov rsi, 'Current Boot Sequence: '
    call display_message
    mov rsi, boot_sequence
    call display_message
    mov rsi, 'Current Boot Option: '
    call display_message
    mov rsi, current_boot_option
    call display_message
    mov rsi, 'Menu: 1. Set Boot Sequence, 2. Set Boot Option, 3. Exit'
    call display_message
    ret

get_user_input:
    ; Get user input for menu selection
    ; This is a stub, in a real implementation it would read from user input
    mov rsi, '1'
    mov rdi, user_input_buffer
    call copy_string
    ret

process_user_input:
    ; Process the user input and perform the corresponding action
    mov rsi, user_input_buffer
    cmp byte [rsi], '1'
    je set_boot_sequence
    cmp byte [rsi], '2'
    je set_boot_option
    cmp byte [rsi], '3'
    je exit_program
    ret

set_boot_sequence:
    ; Set the boot sequence based on user input
    ; This is a stub, in a real implementation it would prompt the user for boot device order
    mov rsi, 'HDD0, USB0'
    mov rdi, boot_sequence
    call copy_string
    ret

set_boot_option:
    ; Set the boot option based on user input
    ; This is a stub, in a real implementation it would prompt the user for boot options
    mov rsi, 'safe'
    mov rdi, current_boot_option
    call copy_string
    ret

save_boot_config:
    ; Save the boot configuration to file
    ; This is a stub, in a real implementation it would write to a config file
    mov rsi, 'boot.cfg saved'
    call display_message
    ret

exit_program:
    ; Exit the boot configuration utility
    ; This is a stub, in a real implementation it would exit the program
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


92.asm
;Content of 92.asm
section .data
    driver_path db 'C:\drivers\', 0
    drivers db 'driver1.sys', 0, 'driver2.sys', 0, 'driver3.sys', 0, 0
    loaded_drivers db 'driver1.sys', 0, 0
    load_command db 'load', 0
    unload_command db 'unload', 0
    list_command db 'list', 0
    newline db 10, 0

section .bss
    command_buffer resb 32  ; Buffer for user commands
    driver_buffer resb 256  ; Buffer for driver paths

section .text
    global _start

_start:
    ; Initialize the driver loader
    call init_driver_loader

    ; Main loop to handle driver commands
main_loop:
    ; Display menu and get user command
    call display_menu
    call get_user_command

    ; Process user command
    call process_command

    ; Wait for the next command cycle
    call wait
    jmp main_loop

init_driver_loader:
    ; Initialize the driver loader
    ; This is a stub, in a real implementation it might involve more setup
    mov rsi, 'Driver loader initialized'
    call display_message
    ret

display_menu:
    ; Display the driver loader menu options
    mov rsi, 'Menu: 1. Load Driver, 2. Unload Driver, 3. List Loaded Drivers, 4. Exit'
    call display_message
    ret

get_user_command:
    ; Get user input for menu selection
    ; This is a stub, in a real implementation it would read from user input
    mov rsi, '1'
    mov rdi, command_buffer
    call copy_string
    ret

process_command:
    ; Process the user command and perform the corresponding action
    mov rsi, command_buffer
    cmp byte [rsi], '1'
    je load_driver
    cmp byte [rsi], '2'
    je unload_driver
    cmp byte [rsi], '3'
    je list_loaded_drivers
    cmp byte [rsi], '4'
    je exit_program
    ret

load_driver:
    ; Load the specified driver
    ; This is a stub, in a real implementation it would prompt the user for the driver to load
    mov rsi, 'driver2.sys'
    mov rdi, driver_buffer
    call copy_string

    ; Add the driver to the list of loaded drivers
    call add_loaded_driver
    ret

unload_driver:
    ; Unload the specified driver
    ; This is a stub, in a real implementation it would prompt the user for the driver to unload
    mov rsi, 'driver1.sys'
    call remove_loaded_driver
    ret

list_loaded_drivers:
    ; List all currently loaded drivers
    ; This is a stub, in a real implementation it would output to user
    mov rsi, 'Loaded Drivers:'
    call display_message
    mov rsi, loaded_drivers
    call display_message
    ret

add_loaded_driver:
    ; Add a driver to the list of loaded drivers
    ; This is a stub, in a real implementation it would update the list
    mov rsi, driver_buffer
    mov rdi, loaded_drivers + 256  ; Assume the first entry is already used
    call copy_string
    ret

remove_loaded_driver:
    ; Remove a driver from the list of loaded drivers
    ; This is a stub, in a real implementation it would update the list
    ret

exit_program:
    ; Exit the driver loader utility
    ; This is a stub, in a real implementation it would exit the program
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


93.asm
;Content of 93.asm
section .data
    diagnostics_report_file db 'diag_report.log', 0
    diagnostics_message db 'Running diagnostics...', 0
    cpu_check_msg db 'CPU Check: ', 0
    memory_check_msg db 'Memory Check: ', 0
    disk_check_msg db 'Disk Check: ', 0
    network_check_msg db 'Network Check: ', 0
    pass_msg db 'PASS', 0
    fail_msg db 'FAIL', 0
    newline db 10, 0

section .bss
    diagnostics_buffer resb 256  ; Buffer to construct diagnostics messages

section .text
    global _start

_start:
    ; Initialize diagnostics
    call init_diagnostics

    ; Main loop to run diagnostics
main_loop:
    ; Perform CPU diagnostics
    call cpu_diagnostics

    ; Perform memory diagnostics
    call memory_diagnostics

    ; Perform disk diagnostics
    call disk_diagnostics

    ; Perform network diagnostics
    call network_diagnostics

    ; Generate diagnostics report
    call generate_report

    ; Wait before running diagnostics again
    call wait
    jmp main_loop

init_diagnostics:
    ; Initialize the diagnostics program
    mov rsi, diagnostics_message
    call display_message
    ret

cpu_diagnostics:
    ; Perform CPU diagnostics
    ; This is a stub, in a real implementation it would check CPU health and performance
    mov rsi, cpu_check_msg
    mov rdi, pass_msg
    call log_diagnostics
    ret

memory_diagnostics:
    ; Perform memory diagnostics
    ; This is a stub, in a real implementation it would test system memory for errors
    mov rsi, memory_check_msg
    mov rdi, pass_msg
    call log_diagnostics
    ret

disk_diagnostics:
    ; Perform disk diagnostics
    ; This is a stub, in a real implementation it would check disk health and performance
    mov rsi, disk_check_msg
    mov rdi, pass_msg
    call log_diagnostics
    ret

network_diagnostics:
    ; Perform network diagnostics
    ; This is a stub, in a real implementation it would test network connectivity and performance
    mov rsi, network_check_msg
    mov rdi, pass_msg
    call log_diagnostics
    ret

generate_report:
    ; Generate a report of the diagnostics results
    ; This is a stub, in a real implementation it would write the results to a report file
    mov rsi, 'Diagnostics completed. Report generated.'
    call display_message
    ret

log_diagnostics:
    ; Log the diagnostics message
    ; Copy the message to the diagnostics buffer
    mov rdi, diagnostics_buffer
    call copy_string

    ; Add the result to the buffer
    add rdi, 256
    call copy_string

    ; Add a newline
    mov rsi, newline
    add rdi, 256
    call copy_string
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


94.asm
;Content of 94.asm
section .data
    shutdown_msg db 'Shutting down...', 0
    restart_msg db 'Restarting...', 0
    sleep_msg db 'Entering sleep mode...', 0
    wake_msg db 'Waking from sleep mode...', 0
    battery_status_msg db 'Battery status: ', 0
    battery_ok_msg db 'OK', 0
    battery_low_msg db 'LOW', 0
    newline db 10, 0

section .bss
    command_buffer resb 32  ; Buffer for user commands
    battery_level resb 1    ; Battery level (0-100)

section .text
    global _start

_start:
    ; Initialize the power management utility
    call init_power_management

    ; Main loop to handle power management commands
main_loop:
    ; Display menu and get user command
    call display_menu
    call get_user_command

    ; Process user command
    call process_command

    ; Wait for the next command cycle
    call wait
    jmp main_loop

init_power_management:
    ; Initialize the power management utility
    mov rsi, 'Power management utility initialized'
    call display_message
    ret

display_menu:
    ; Display the power management menu options
    mov rsi, 'Menu: 1. Shutdown, 2. Restart, 3. Sleep, 4. Wake, 5. Battery Status, 6. Exit'
    call display_message
    ret

get_user_command:
    ; Get user input for menu selection
    ; This is a stub, in a real implementation it would read from user input
    mov rsi, '1'
    mov rdi, command_buffer
    call copy_string
    ret

process_command:
    ; Process the user command and perform the corresponding action
    mov rsi, command_buffer
    cmp byte [rsi], '1'
    je shutdown_system
    cmp byte [rsi], '2'
    je restart_system
    cmp byte [rsi], '3'
    je sleep_system
    cmp byte [rsi], '4'
    je wake_system
    cmp byte [rsi], '5'
    je battery_status
    cmp byte [rsi], '6'
    je exit_program
    ret

shutdown_system:
    ; Shutdown the system
    mov rsi, shutdown_msg
    call display_message
    ; In a real implementation, this would involve a system call to power off the system
    ret

restart_system:
    ; Restart the system
    mov rsi, restart_msg
    call display_message
    ; In a real implementation, this would involve a system call to reboot the system
    ret

sleep_system:
    ; Put the system into sleep mode
    mov rsi, sleep_msg
    call display_message
    ; In a real implementation, this would involve a system call to enter sleep mode
    ret

wake_system:
    ; Wake the system from sleep mode
    mov rsi, wake_msg
    call display_message
    ; In a real implementation, this would involve a system call to wake the system
    ret

battery_status:
    ; Check and display the battery status
    ; This is a stub, in a real implementation it would read the actual battery level
    mov byte [battery_level], 80
    cmp byte [battery_level], 20
    jae .battery_ok
    mov rsi, battery_low_msg
    jmp .display_battery_status
.battery_ok:
    mov rsi, battery_ok_msg
.display_battery_status:
    call display_message
    ret

exit_program:
    ; Exit the power management utility
    ; This is a stub, in a real implementation it would exit the program
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


95.asm
;Content of 95.asm
section .data
    battery_level_msg db 'Battery Level: ', 0
    charging_status_msg db 'Charging Status: ', 0
    battery_health_msg db 'Battery Health: ', 0
    level db '100%', 0
    status db 'Charging', 0
    health db 'Good', 0
    newline db 10, 0

section .bss
    battery_level resb 4   ; Battery level (0-100%)
    charging_status resb 10 ; Charging status (Charging/Discharging/Full)
    battery_health resb 10  ; Battery health status

section .text
    global _start

_start:
    ; Initialize battery monitor
    call init_battery_monitor

    ; Main loop to monitor battery status
main_loop:
    ; Update battery status
    call update_battery_status

    ; Display battery status
    call display_battery_status

    ; Wait for a while before checking again
    call wait
    jmp main_loop

init_battery_monitor:
    ; Initialize the battery monitor
    mov rsi, 'Battery monitor initialized'
    call display_message
    ret

update_battery_status:
    ; Update battery level
    ; This is a stub, in a real implementation it would read the actual battery level
    mov byte [battery_level], 85

    ; Update charging status
    ; This is a stub, in a real implementation it would read the actual charging status
    mov rsi, 'Discharging'
    mov rdi, charging_status
    call copy_string

    ; Update battery health
    ; This is a stub, in a real implementation it would read actual health indicators
    mov rsi, 'Good'
    mov rdi, battery_health
    call copy_string
    ret

display_battery_status:
    ; Display battery level
    mov rsi, battery_level_msg
    call display_message
    mov rsi, battery_level
    call display_message

    ; Display charging status
    mov rsi, charging_status_msg
    call display_message
    mov rsi, charging_status
    call display_message

    ; Display battery health
    mov rsi, battery_health_msg
    call display_message
    mov rsi, battery_health
    call display_message
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 10
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


96.asm
;Content of 96.asm
section .data
    remote_host db '192.168.1.100', 0
    username db 'user', 0
    password db 'pass', 0
    connection_status db 'Disconnected', 0
    auth_status db 'Not Authenticated', 0
    display_buffer resb 1024*768*4 ; Buffer for remote display
    input_buffer resb 256 ; Buffer for user input
    newline db 10, 0

section .bss
    session_id resb 8 ; ID for the remote session

section .text
    global _start

_start:
    ; Initialize remote desktop client
    call init_remote_desktop_client

    ; Main loop to handle remote desktop operations
main_loop:
    ; Establish connection
    call establish_connection

    ; Authenticate user
    call authenticate_user

    ; Render remote display
    call render_remote_display

    ; Forward user input
    call forward_user_input

    ; Manage session
    call manage_session

    ; Wait for a while before next iteration
    call wait
    jmp main_loop

init_remote_desktop_client:
    ; Initialize the remote desktop client
    mov rsi, 'Remote desktop client initialized'
    call display_message
    ret

establish_connection:
    ; Establish connection to the remote host
    ; This is a stub, in a real implementation it would establish a network connection
    mov rsi, 'Connecting to '
    call display_message
    mov rsi, remote_host
    call display_message
    mov rsi, newline
    call display_message
    mov rsi, 'Connected'
    mov rdi, connection_status
    call copy_string
    ret

authenticate_user:
    ; Authenticate the user with the remote system
    ; This is a stub, in a real implementation it would send credentials to the server
    mov rsi, 'Authenticating as '
    call display_message
    mov rsi, username
    call display_message
    mov rsi, newline
    call display_message
    mov rsi, 'Authenticated'
    mov rdi, auth_status
    call copy_string
    ret

render_remote_display:
    ; Render the remote desktop display on the local machine
    ; This is a stub, in a real implementation it would receive and render the display data
    ret

forward_user_input:
    ; Forward user input (keyboard and mouse) to the remote system
    ; This is a stub, in a real implementation it would send input events to the server
    ret

manage_session:
    ; Manage the remote session (e.g., handle disconnections and reconnections)
    ; This is a stub, in a real implementation it would manage the session state
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


97.asm
;Content of 97.asm
section .data
    vm_config_path db 'C:\vm_configs\', 0
    vm_image_path db 'C:\vm_images\', 0
    vm_list db 'vm1', 0, 'vm2', 0, 0
    vm_status_running db 'running', 0
    vm_status_stopped db 'stopped', 0
    vm_status db 'stopped', 0
    create_cmd db 'create', 0
    start_cmd db 'start', 0
    stop_cmd db 'stop', 0
    monitor_cmd db 'monitor', 0
    delete_cmd db 'delete', 0
    newline db 10, 0

section .bss
    command_buffer resb 32  ; Buffer for user commands
    vm_name_buffer resb 32  ; Buffer for VM names
    vm_status_buffer resb 32 ; Buffer for VM status

section .text
    global _start

_start:
    ; Initialize the virtualization manager
    call init_virtualization_manager

    ; Main loop to handle VM commands
main_loop:
    ; Display menu and get user command
    call display_menu
    call get_user_command

    ; Process user command
    call process_command

    ; Wait for the next command cycle
    call wait
    jmp main_loop

init_virtualization_manager:
    ; Initialize the virtualization manager
    mov rsi, 'Virtualization manager initialized'
    call display_message
    ret

display_menu:
    ; Display the virtualization manager menu options
    mov rsi, 'Menu: 1. Create VM, 2. Start VM, 3. Stop VM, 4. Monitor VM, 5. Delete VM, 6. Exit'
    call display_message
    ret

get_user_command:
    ; Get user input for menu selection
    ; This is a stub, in a real implementation it would read from user input
    mov rsi, '1'
    mov rdi, command_buffer
    call copy_string
    ret

process_command:
    ; Process the user command and perform the corresponding action
    mov rsi, command_buffer
    cmp byte [rsi], '1'
    je create_vm
    cmp byte [rsi], '2'
    je start_vm
    cmp byte [rsi], '3'
    je stop_vm
    cmp byte [rsi], '4'
    je monitor_vm
    cmp byte [rsi], '5'
    je delete_vm
    cmp byte [rsi], '6'
    je exit_program
    ret

create_vm:
    ; Create a new virtual machine
    mov rsi, 'Creating VM: vm3'
    call display_message
    ; In a real implementation, this would involve creating VM configurations and disk images
    ret

start_vm:
    ; Start an existing virtual machine
    mov rsi, 'Starting VM: vm1'
    call display_message
    mov rsi, vm_status_running
    mov rdi, vm_status
    call copy_string
    ret

stop_vm:
    ; Stop a running virtual machine
    mov rsi, 'Stopping VM: vm1'
    call display_message
    mov rsi, vm_status_stopped
    mov rdi, vm_status
    call copy_string
    ret

monitor_vm:
    ; Monitor the status of virtual machines
    mov rsi, 'VM Status: '
    call display_message
    mov rsi, vm_status
    call display_message
    ret

delete_vm:
    ; Delete a virtual machine
    mov rsi, 'Deleting VM: vm2'
    call display_message
    ; In a real implementation, this would involve removing VM configurations and disk images
    ret

exit_program:
    ; Exit the virtualization manager utility
    ; This is a stub, in a real implementation it would exit the program
    ret

wait:
    ; Simple busy-wait loop (for simulation purposes)
    mov rcx, 100000000
.wait_loop:
    loop .wait_loop
    ret

display_message:
    ; Display a message to the user
    ; This is a stub, in a real implementation it would use system calls to display the message
    ret

copy_string:
    ; Copy string from rsi to rdi
    mov rcx, 256
.copy_loop:
    lodsb
    stosb
    loop .copy_loop
    ret


98.asm
;Content of 98.asm
section .data
    ; Device addresses
    bt_addr db '00:1A:7D:DA:71:13', 0
    msg_connected db 'Bluetooth Device Connected', 0
    msg_disconnected db 'Bluetooth Device Disconnected', 0

section .bss
    connection_status resb 1

section .text
    global _start

_start:
    ; Initialize Bluetooth Device
    call initialize_bluetooth
    cmp byte [connection_status], 1
    je .connected

    ; Connect to Bluetooth Device
    call connect_bluetooth
    cmp byte [connection_status], 1
    je .connected

.disconnected:
    ; Handle Disconnected State
    call print_message
    db msg_disconnected

.connected:
    ; Handle Connected State
    call print_message
    db msg_connected

    ; Main Loop
    .loop:
        ; Check connection status periodically
        call check_connection_status
        cmp byte [connection_status], 1
        je .loop

    ; Exit program
    call exit_program

initialize_bluetooth:
    ; Add code to initialize the Bluetooth adapter
    ; This is a placeholder for actual initialization code
    mov byte [connection_status], 0
    ret

connect_bluetooth:
    ; Add code to connect to the Bluetooth device
    ; This is a placeholder for actual connection code
    mov byte [connection_status], 1
    ret

check_connection_status:
    ; Add code to check the connection status of the Bluetooth device
    ; This is a placeholder for actual status checking code
    ret

print_message:
    mov rsi, rdi  ; Message to print
    call print_string
    ret

print_string:
    mov rax, 1    ; syscall number for sys_write
    mov rdi, 1    ; file descriptor 1 is stdout
    mov rdx, rsi  ; message to write
    syscall
    ret

exit_program:
    mov rax, 60   ; syscall number for exit
    xor rdi, rdi  ; exit code 0
    syscall


99.asm
;Content of 99.asm
section .data
    ; Key codes for hotkeys
    hotkey1 db 0x1E   ; 'A' key
    hotkey2 db 0x30   ; 'B' key
    msg_hotkey1 db 'Hotkey 1 Activated', 0
    msg_hotkey2 db 'Hotkey 2 Activated', 0

section .bss
    key_status resb 1

section .text
    global _start

_start:
    ; Initialize Hotkey Manager
    call initialize_hotkey_manager

    ; Main Loop
    .loop:
        ; Check for hotkey presses
        call check_hotkeys
        cmp byte [key_status], 1
        je .hotkey1
        cmp byte [key_status], 2
        je .hotkey2

        jmp .loop

.hotkey1:
    ; Handle Hotkey 1 Activation
    call print_message
    db msg_hotkey1
    mov byte [key_status], 0
    jmp .loop

.hotkey2:
    ; Handle Hotkey 2 Activation
    call print_message
    db msg_hotkey2
    mov byte [key_status], 0
    jmp .loop

    ; Exit program
    call exit_program

initialize_hotkey_manager:
    ; Add code to initialize the hotkey manager
    ; This is a placeholder for actual initialization code
    ret

check_hotkeys:
    ; Add code to check if any hotkeys are pressed
    ; This is a placeholder for actual hotkey checking code
    ; Simulate hotkey 1 press
    mov byte [key_status], 1
    ret

print_message:
    mov rsi, rdi  ; Message to print
    call print_string
    ret

print_string:
    mov rax, 1    ; syscall number for sys_write
    mov rdi, 1    ; file descriptor 1 is stdout
    mov rdx, rsi  ; message to write
    syscall
    ret

exit_program:
    mov rax, 60   ; syscall number for exit
    xor rdi, rdi  ; exit code 0
    syscall


100.asm
;Content of 100.asm
section .data
    msg_cpu db 'CPU: ', 0
    msg_mem db 'Memory: ', 0
    msg_disk db 'Disk: ', 0
    newline db 10, 0  ; newline character

section .bss
    buffer resb 128

section .text
    global _start

_start:
    ; Initialize System Profiler
    call initialize_system_profiler

    ; Retrieve and print CPU information
    call get_cpu_info
    call print_message
    db msg_cpu
    call print_buffer
    call print_message
    db newline

    ; Retrieve and print Memory information
    call get_mem_info
    call print_message
    db msg_mem
    call print_buffer
    call print_message
    db newline

    ; Retrieve and print Disk information
    call get_disk_info
    call print_message
    db msg_disk
    call print_buffer
    call print_message
    db newline

    ; Exit program
    call exit_program

initialize_system_profiler:
    ; Add code to initialize the system profiler
    ; This is a placeholder for actual initialization code
    ret

get_cpu_info:
    ; Add code to get CPU information
    ; This is a placeholder for actual CPU information retrieval code
    mov rdi, buffer
    mov rsi, 'Intel i7', 0
    call copy_string
    ret

get_mem_info:
    ; Add code to get Memory information
    ; This is a placeholder for actual Memory information retrieval code
    mov rdi, buffer
    mov rsi, '16GB', 0
    call copy_string
    ret

get_disk_info:
    ; Add code to get Disk information
    ; This is a placeholder for actual Disk information retrieval code
    mov rdi, buffer
    mov rsi, '512GB SSD', 0
    call copy_string
    ret

print_message:
    mov rsi, rdi  ; Message to print
    call print_string
    ret

print_string:
    mov rax, 1    ; syscall number for sys_write
    mov rdi, 1    ; file descriptor 1 is stdout
    mov rdx, rsi  ; message to write
    syscall
    ret

print_buffer:
    mov rsi, buffer  ; Print buffer content
    call print_string
    ret

copy_string:
    .copy_loop:
        lodsb
        stosb
        test al, al
        jnz .copy_loop
    ret

exit_program:
    mov rax, 60   ; syscall number for exit
    xor rdi, rdi  ; exit code 0
    syscall


