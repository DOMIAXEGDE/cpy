----- Content of 1.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("SOLUTION_RENAME_MAX.txt","w");
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 100;
	puts("26 = SPACE");
	puts("27 = NEWLINE");
	puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}

	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"%d ", (id - 1));
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			fprintf(p,"\n");
			//printf("\n");
		}
	}
	if(cheque == 0){
		for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"%d ", (id - 1));
				for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
					cell = (row/rdiv) % (k+1);
					fprintf(p,"%c", a[cell]);
				}
				fprintf(p,"\n");
				//printf("\n");
			}	
		}
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of 2.cpp -----
#include <iostream>
#include <fstream>
#include <vector>
#include <filesystem>
#include <string>
#include <unordered_map>

using namespace std;
namespace fs = std::filesystem;

vector<unordered_map<string, string>> readMappings() {
    vector<unordered_map<string, string>> mappings(4);
    for (int i = 1; i <= 4; ++i) {
        ifstream file(to_string(i) + ".txt");
        if (!file) {
            cerr << "Error opening file " << i << ".txt" << endl;
            exit(EXIT_FAILURE);
        }
        string line;
        while (getline(file, line)) {
            int spacePos = line.find(' ');
            if (spacePos != string::npos) {
                string numberStr = line.substr(0, spacePos);
                string str = line.substr(spacePos + 1);
                mappings[i - 1][str] = numberStr;
            }
        }
    }
    return mappings;
}



int main() {
    auto mappings = readMappings();

    int start, end;
    cout << "Enter the range of files to read (e.g., 5 15 to read from 5.txt to 15.txt): ";
    cin >> start >> end;

    int maxFileNumber = -1;

    for (const auto& entry : fs::directory_iterator("./")) {
        string filename = entry.path().filename().string();
        if (filename.find(".txt") != string::npos) {
            int fileNumber = stoi(filename.substr(0, filename.find(".txt")));
            maxFileNumber = max(maxFileNumber, fileNumber);
        }
    }

    for (int i = start; i <= end; ++i) {
        ifstream inputFile("inputs/" + to_string(i) + ".txt");
        if (!inputFile) {
            cerr << "Could not open the file " + to_string(i) + ".txt" << endl;
            continue;
        }

        string line, content;
        while (getline(inputFile, line)) {
            content += line + "\n";
        }
        inputFile.close();

        string outputContent;
        for (size_t i = 0; i < content.size(); ++i) {
			if (content[i] == '\n') {
				outputContent += "1.27 "; // Assuming 27 is the mapping for newline character
				continue;
			}
			bool found = false;
			for (int len = 4; len >= 1; --len) {
				if (i + len - 1 < content.size()) {
					string substr = content.substr(i, len);
					if (mappings[len - 1].find(substr) != mappings[len - 1].end()) {
						int number = stoi(mappings[len - 1][substr]);
						outputContent += to_string(len) + "." + to_string(number + 1) + " ";
						i += len - 1;
						found = true;
						break;
					}
				}
			}
			if (!found) {
				outputContent += "0 ";
			}
		}


        ofstream outputFile(to_string(maxFileNumber + 1) + ".txt");
        if (outputFile) {
            outputFile << outputContent;
            outputFile.close();
            maxFileNumber++;
        } else {
            cerr << "Could not create the file " + to_string(maxFileNumber + 1) + ".txt" << endl;
        }
    }

    return 0;
}


----- Content of 3.cpp -----
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <sstream>

using namespace std;

vector<unordered_map<string, string>> readMappings() {
    vector<unordered_map<string, string>> mappings(4);
    for (int i = 1; i <= 4; ++i) {
        ifstream file(to_string(i) + ".txt");
        if (!file) {
            cerr << "Error opening file " << i << ".txt" << endl;
            exit(EXIT_FAILURE);
        }
        string line;
        while (getline(file, line)) {
            int spacePos = line.find(' ');
            if (spacePos != string::npos) {
                string numberStr = line.substr(0, spacePos);
                string str = line.substr(spacePos + 1);
                mappings[i - 1][numberStr] = str;
            }
        }
    }
    return mappings;
}

int main() {
    auto mappings = readMappings();

    string inputFilePath;
    cout << "Enter the path of the file to re-convert: ";
    cin >> inputFilePath;

    ifstream inputFile(inputFilePath);
    if (!inputFile) {
        cerr << "Could not open the file " << inputFilePath << endl;
        exit(EXIT_FAILURE);
    }

    string line, content;
    while (getline(inputFile, line)) {
        content += line + '\n';
    }
    inputFile.close();

    stringstream ss(content);
    string token;
    string outputContent;
    while (getline(ss, token, ' ')) {
		int dotPos = token.find('.');
		if (dotPos != string::npos) {
			int len = stoi(token.substr(0, dotPos));
			string numberStr = token.substr(dotPos + 1);
			if (numberStr == "27" && len == 1) {
				outputContent += '\n';
			} else if (numberStr != "0") {
				numberStr = to_string(stoi(numberStr) - 1);
				if (mappings[len - 1].find(numberStr) != mappings[len - 1].end()) {
					outputContent += mappings[len - 1][numberStr];
				} else {
					outputContent += "?"; // Placeholder for unmapped values
				}
			}
		}
	}


    ofstream outputFile("0.txt");
    if (outputFile) {
        outputFile << outputContent;
        outputFile.close();
    } else {
        cerr << "Could not create the file 0.txt" << endl;
    }

    return 0;
}


----- Content of 4.cpp -----
//compile cpptoexe.cpp in terminal or CMD Prompt
//g++ -std=c++17 -lstdc++fs cpptoexe.cpp -o cpptoexe
#include <iostream>
#include <cstdlib>
#include <filesystem>

int main() {
    // Get the current working directory
    std::filesystem::path current_path = std::filesystem::current_path();

    // Iterate through each file in the current directory
    for (const auto& entry : std::filesystem::directory_iterator(current_path)) {
        std::filesystem::path file_path = entry.path();
        
        // Check if the file has a .cpp extension
        if (file_path.extension() == ".cpp") {
            std::string compile_command = "g++ " + file_path.string() + " -o " + file_path.stem().string();
            
            // Compile the .cpp file
            std::cout << "Compiling: " << file_path.string() << std::endl;
            std::system(compile_command.c_str());
        }
    }

    return 0;
}


----- Content of 5.py -----
from tkinter import Tk, Label, Button, filedialog
from PIL import Image, ImageDraw
import math

# Predefined color palette with 12 unique colors
COLOR_PALETTE = [
    '#FF5733', '#33FF57', '#3357FF', '#F1C40F', '#8E44AD', 
    '#1ABC9C', '#E74C3C', '#2ECC71', '#3498DB', '#9B59B6',
    '#FF33A1', '#A1FF33'
]

class App:
    def __init__(self, master):
        self.master = master
        master.title("Hex Color Picker")

        self.label = Label(master, text="Choose Text File")
        self.label.pack()

        self.open_file_button = Button(master, text="Open File", command=self.open_file)
        self.open_file_button.pack()

        self.close_button = Button(master, text="Generate Image", command=self.generate_image)
        self.close_button.pack()
        
        self.save_pdf_button = Button(master, text="Save as PDF", command=self.save_as_pdf)
        self.save_pdf_button.pack()

        self.data = []
        self.color_encoding = {}

    def open_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'r') as file:
                    self.data = [float(num) for num in file.read().split()]
                    self.label.config(text="File successfully opened.")
            except Exception as e:
                self.label.config(text=f"Error opening file: {e}")
        else:
            self.label.config(text="No file selected.")

    def generate_image(self):
        print("Generating ...")
        if hasattr(self, 'data') and self.data:
            self.label.config(text="Generating, please wait...")
            self.master.update_idletasks()  # Force update of the GUI
            
            # Convert data to colors
            color_data = [self.data_to_color(datum) for datum in self.data]

            self.label.config(text="Data converted to colors. Creating image...")
            self.master.update_idletasks()  # Force update of the GUI

            create_image(color_data, self.data)
            
            self.label.config(text="Image successfully generated.")
        else:
            self.label.config(text="Please select a file first.")
    
    def data_to_color(self, datum):
        # Perform the modular arithmetic-based color encoding
        first_digit = int(str(datum)[0]) - 1
        fractional_part = int(str(datum).split('.')[1])
        cpoint = fractional_part % 12
        pointer = (first_digit + cpoint) % 12
        return COLOR_PALETTE[pointer]
    
    def save_as_pdf(self):
        if hasattr(self, 'generated_image'):
            file_path = filedialog.asksaveasfilename(defaultextension='.pdf', filetypes=[("PDF files", "*.pdf")])
            if file_path:
                # A5 dimensions in pixels (previously calculated)
                a5_width_pixels = 1748
                a5_height_pixels = 2480

                # Call the function to save the image as a PDF
                save_image_as_pdf(self.generated_image, file_path, a5_width_pixels, a5_height_pixels)
                self.label.config(text="Saved as PDF.")
            else:
                self.label.config(text="No file selected.")
        else:
            self.label.config(text="Generate an image first.")

def create_image(color_data, data):
    # Count unique string encodings
    unique_encodings = set(data)
    num_unique_encodings = len(unique_encodings)
    total_encodings = len(data)  # This will count all the encodings
    print(f"Number of unique encodings: {num_unique_encodings}")
    print(f"Total number of encodings: {total_encodings}")

    # Request image dimensions and pixel size from user
    pixel_side_length = int(input("Enter the square side length of each pixel to be created: "))
    num_pixels_width = int(input("Enter the pixel width of the image, by number of pixels: "))
    num_pixels_height = int(input("Enter the pixel height of the image, by number of pixels: "))
    
    img_width = pixel_side_length * num_pixels_width
    img_height = pixel_side_length * num_pixels_height
    
    # Create an empty white canvas
    image = Image.new('RGB', (img_width, img_height), color="white")
    
    # Create a drawing context for the image
    draw = ImageDraw.Draw(image)
    
    # Save the image in the object for later PDF conversion
    app.generated_image = image
    
    data_idx = 0  # Index to track data position
    for i in range(num_pixels_height):
        for j in range(num_pixels_width):
            if data_idx < len(color_data):
                hex_value = color_data[data_idx]
                top_left = (j * pixel_side_length, i * pixel_side_length)
                bottom_right = ((j + 1) * pixel_side_length, (i + 1) * pixel_side_length)
                draw.rectangle([top_left, bottom_right], fill=hex_value)
                data_idx += 1

    image.show()
    image.save('generated_image.png')

    return image

def save_image_as_pdf(image, file_path, a5_width_pixels, a5_height_pixels, margin_mm=10):
    margin_pixels = int(margin_mm * (300 / 25.4))
    drawable_width = a5_width_pixels - (2 * margin_pixels)
    drawable_height = a5_height_pixels - (2 * margin_pixels)
    num_pages_horizontal = math.ceil(image.width / drawable_width)
    num_pages_vertical = math.ceil(image.height / drawable_height)

    pdf_pages = []

    for y in range(num_pages_vertical):
        for x in range(num_pages_horizontal):
            left = x * drawable_width
            upper = y * drawable_height
            right = min(left + drawable_width, image.width)
            lower = min(upper + drawable_height, image.height)
            crop_area = (left, upper, right, lower)

            cropped_image = image.crop(crop_area)
            pdf_page = Image.new('RGB', (a5_width_pixels, a5_height_pixels), 'white')

            paste_position = (
                margin_pixels + max(0, (drawable_width - cropped_image.width) // 2),
                margin_pixels + max(0, (drawable_height - cropped_image.height) // 2)
            )

            pdf_page.paste(cropped_image, paste_position)
            pdf_pages.append(pdf_page)

    pdf_pages[0].save(file_path, save_all=True, append_images=pdf_pages[1:], resolution=100.0)

root = Tk()
app = App(root)
root.mainloop()


----- Content of AlgorithmicProof.c -----
//Version of A Mathematical Proof Assitant Console Application
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

int main()
{
	FILE *p;
	p = fopen("method.txt", "w");
	start:
	printf("\n\tHave Your Statement at the ready. 1 is for yes, 2 is for no. Anything else will produce an error. Note, the output of this program is in the same directory as this program. The output is named, 'method.txt'.");
	int bin, trya;
	puts("\n\nCan you write the statement in the form: P(x) for some element in X?\n\t");
	scanf("%d", &bin);
	if(bin == 1){
		puts("Can you spot a value of x being an element of X for when P(x) is true?\n\t");
		scanf("%d", &bin);
		if(bin == 1){
			//Proof_Path_1
			puts("Prove P(x) by construction. Start your proof with a commonly known definition.");
			fprintf(p, "Prove P(x) by construction. Start your proof with a commonly known definition.");
		}
	}
	if(bin == 0){
		puts("Can you write the statement in the form: P(x) for all x as elements in X?\n\t");
		scanf("%d", &bin);
		if(bin == 1){
			puts("Can you spot a value of x as an element of X for which P(x) is false?\n\t");
			if(bin == 1){
				//Proof_Path_2
				puts("Disprove P(x) by counter-example. Start your proof with a commonly known definition.");
				fprintf(p, "Disprove P(x) by counter-example. Start your proof with a commonly known definition.");
			}
			if(bin == 0){
				puts("Is x small enough for each x to be checked in turn?\n\t");
				scanf("%d", &bin);
				if(bin == 1){
					//Proof_Path_3
					puts("Prove P(x) by exhaustion. Start your proof with a commonly known definition.");
					fprintf(p, "Prove P(x) by exhaustion. Start your proof with a commonly known definition.");
				}
				if(bin == 0){
					puts("Is X the set of natural numbers greater than or equal to some N as an element of the Set of Natural numbers?\n\t");
					scanf("%d", &bin);
					if(bin == 1){
						puts("Can you show P(N) is true, and prove the inductive step P(k) which implies P(k + 1) for k greater than or equal to N?\n\t");
						scanf("%d", &bin);
						if(bin == 1){
							//Proof_Path_4
							puts("Prove P(N) and the inductive step P(k) which implies P(k + 1) by induction. Start your proof with a commonly known definition.");
							fprintf(p, "Prove P(N) and the inductive step P(k) which implies P(k + 1) by induction. Start your proof with a commonly known definition.");
						}
						if(bin == 0){
							puts("Can you write the statement in the form P implies Q and Q implies P?\n\t");
							scanf("%d", &bin);
							if(bin == 1){
								puts("Can you find a sequence of equivalences where P implies P sub 1 ... which implies Q and Q implies P sub 1 ... which implies P?\n\t");
								scanf("%d", &bin);
								if(bin == 1){
									//Proof_Path_5
									puts("Prove by deduction. Start your proof with a commonly known definition.");
									fprintf(p, "Prove by deduction. Start your proof with a commonly known definition.");
								}
								if(bin == 0){
									puts("Can you find sequences of implications where P implies P sub 1 ... which implies Q and Q implies Q sub 1 ... which implies P?\n\t");
									scanf("%d", &bin);
									if(bin == 1){
										//Proof_Path_6
										puts("Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
										fprintf(p, "Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
									}
									if(bin == 0){
										puts("Your Statement is either invalid, or you have misunderstood one of the previous questions. Please try again. Or your statement is beyond the scope of this program's'algorithm.");
										puts("\n\tDo you want to try again?\n\t");
										scanf("%d", &trya);
										if(trya == 1){
											goto start;
										}
										if(trya == 0){
											fprintf(p, "An error was produced (Error Code 001). Please try again or, use another Statement. Thank you.");
											exit(0);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if(bin == 0){
			puts("Can you write the statement in the form P implies Q and Q implies P?\n\t");
			scanf("%d", &bin);
			if(bin == 1){
				puts("Can you find a sequence of equivalences where P imlpies P sub 1 ... which implies Q and Q implies P sub 1 ... which implies P?\n\t");
				scanf("%d", &bin);
				if(bin == 1){
					//Proof_Path_7
					puts("Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
					fprintf(p, "Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
				}
				if(bin == 0){
					puts("Can you find the sequences of implications P implies P sub 1 ... which implies Q and Q implies Q sub 1 which implies P?\n\t");
					scanf("%d", &bin);
					if(bin == 1){
						//Proof_Path_8
						puts("Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
						fprintf(p, "Prove P implies Q and Q implies P by deduction. Start your proof with a commonly known definition.");
					}
					if(bin == 0){
						puts("Your statement is either invalid or you have misunderstood one of the prvious questions. Please try again. Or your statement is beyond the scope of this program's'algorithm.");
						puts("Do you want to try again?\n\t");
						scanf("%d", &trya);
						if(trya == 1){
							goto start;
						}
						if(trya == 0){
							fprintf(p, "An error was produced (Error Code 002). Please try again or, use another Statement. Thank you.");
							exit(0);
						}
					}
				}
			}
			if(bin == 0){
				puts("Can you write the statement in the form P implies Q?\n\t");
				scanf("%d", &bin);
				if(bin == 1){
					puts("Can you find a sequence of implications where P implies P sub 1 ... which implies P?\n\t");
					scanf("%d", &bin);
					if(bin == 1){
						//Proof_Path_9
						puts("Prove P implies Q by deduction. Start your proof with a commonly known definition.");
						fprintf(p, "Prove P implies Q by deduction. Start your proof with a commonly known definition.");
					}
					if(bin == 0){
						puts("Can you find a squence of implications for the contrapositive: NOT Q implies P sub 1 ... which implies NOT P?\n\t");
						scanf("%d", &bin);
						if(bin == 1){
							//Proof_Path_10
							puts("Prove P implies Q by contraposition. Start your proof with a commonly known definition.");
							fprintf(p, "Prove P implies Q by contraposition. Start your proof with a commonly known definition.");
						}
						if(bin == 0){
							puts("Your statement is either invalid or you have misunderstood one of the previous questions. Please try again. Or your statement is beyond the scope of this program's'algorithm.");
							puts("Do you want to try again?\n\t");
							scanf("%d", &trya);
							if(trya == 1){
								goto start;
							}
							if(trya == 0){
								fprintf(p, "An error was produced (Error Code 003). Please try again or, use another Statement. Thank you.");
								exit(0);
							}
						}
					}
				}
				if(bin == 0){
					puts("Let the statement be P. Can you find a sequence P implies P sub 1 ... which implies P sub n which implies Q and Q implies P sub n which implies P sub 1 ... which implies P, where Q is true?\n\t");
					scanf("%d", &bin);
					if(bin == 1){
						//Proof_Path_11
						puts("Prove P by equivalence. Start your proof with a commonly known definition.");
						fprintf(p, "Prove P by equivalence. Start your proof with a commonly known definition.");
					}
					if(bin == 0){
						puts("Let the statement be P. Can you find a sequence NOT P implies P sub 1 ... which implies P sub n, where P sub n is false?\n\t");
						scanf("%d", &bin);
						if(bin == 1){
							//Proof_Path_12
							puts("Prove P by contradiction. Start your proof with a commonly known definition.");
							fprintf(p, "Prove P by contradiction. Start your proof with a commonly known definition.");
						}
						if(bin == 0){
							puts("Your statement is either invalid or you have misunderstood one of the previous questions. Please try again. Or your statement is beyond the scope of this program's algorithm.");
							puts("Do you want to try again?\n\t");
							scanf("%d", &trya);
							if(trya == 1){
								goto start;
							}
							if(trya == 0){
								fprintf(p, "An error was produced (Error Code 004). Please try again or, use another Statement. Thank you.");
								exit(0);
							}
						}
					}
				}
			}
		}
	}
	fclose(p);
	return 0;	
}


----- Content of Arithmetic_Modulo_n.py -----
import tkinter as tk
from tkinter import ttk

def create_table(op_type, n):
    for widget in table_frame.winfo_children():
        widget.destroy()

    for i in range(n+1):
        for j in range(n+1):
            if i == 0 and j == 0:
                label = tk.Label(table_frame, text=" ", width=5, height=2, borderwidth=1, relief="solid")
            elif i == 0:
                label = tk.Label(table_frame, text=str(j-1), width=5, height=2, borderwidth=1, relief="solid")
            elif j == 0:
                label = tk.Label(table_frame, text=str(i-1), width=5, height=2, borderwidth=1, relief="solid")
            else:
                if op_type == "Addition":
                    label = tk.Label(table_frame, text=str((i-1)+(j-1) % n), width=5, height=2, borderwidth=1, relief="solid")
                elif op_type == "Multiplication":
                    label = tk.Label(table_frame, text=str((i-1)*(j-1) % n), width=5, height=2, borderwidth=1, relief="solid")
            
            label.grid(row=i, column=j)

root = tk.Tk()
root.title("Modular Arithmetic Table")

control_frame = tk.Frame(root)
control_frame.pack(side=tk.TOP, padx=10, pady=10)

table_frame = tk.Frame(root)
table_frame.pack(side=tk.BOTTOM, padx=10, pady=10)

operation_label = tk.Label(control_frame, text="Operation:")
operation_label.pack(side=tk.LEFT)

operation_combobox = ttk.Combobox(control_frame, values=["Addition", "Multiplication"], state="readonly")
operation_combobox.pack(side=tk.LEFT)
operation_combobox.current(0)

n_label = tk.Label(control_frame, text="Modulo (n):")
n_label.pack(side=tk.LEFT)

n_entry = tk.Entry(control_frame, width=5)
n_entry.pack(side=tk.LEFT)
n_entry.insert(0, "6")

def update_table():
    op_type = operation_combobox.get()
    n = int(n_entry.get())
    create_table(op_type, n)

update_button = tk.Button(control_frame, text="Update Table", command=update_table)
update_button.pack(side=tk.LEFT)

create_table("Addition", 6)

root.mainloop()


----- Content of bertotools.py -----
import tkinter as tk
import random
from PIL import ImageGrab
import pickle
from tkinter import simpledialog
import os
from tkinter import Menu, Checkbutton, BooleanVar
from tkinter.colorchooser import askcolor
import logging
import time
import json
import os
import pyautogui
import keyboard


current_col = 0
current_row = 0
            
def get_random_color():
    r = lambda: random.randint(0,255)
    return '#%02X%02X%02X' % (r(),r(),r())

def get_random_char():
    random_int = random.randint(0x0021, 0x007E)
    return chr(random_int)

def draw_grid():
    for i in range(grid_size):
        for j in range(grid_size):
            color = get_random_color()
            square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
            char = get_random_char()
            text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", 18), anchor="center")


def draw_grid_IDE():
    global col
    try:
        for i in range(grid_size):
            for j in range(grid_size):
                color = "blue"
                square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color, outline = "white")
        if typing_mode:
            # In the function where you create the canvas...
            canvas.bind("<Key>", on_key_press)
            canvas.focus_set()
    except:
        print("Submit an app mode ...")


def toggle_color_mode():
    """Toggles between manual color mode and random color mode"""
    global color_mode_var
    color_mode_var.set(not color_mode_var.get())

font_size = 9

def draw_char1(canvas, char, row, col, font_size, color):
    global cell_size, font_color, square_size, grid_size, last_drawn, note, char_note

    '''
    def draw_char1(canvas, char, row, col, font_size):
    
    Draws a character on the Tkinter canvas at the specified row and column with the specified font size.
    
    Parameters:
    canvas (tk.Canvas): The Tkinter canvas to draw on.
    char (str): The character to draw.
    row (int): The row to draw the character at.
    col (int): The column to draw the character at.
    font_size (int): The font size to use for the character.
    
    '''


    try:
        x = col * square_size + square_size / 2
        y = row * square_size + square_size / 2
        
        print(f"Drawing char '{char}' at ({x}, {y})")  # Debug print to check coordinates
        canvas.create_rectangle(col * square_size, row * square_size, (col+1) * square_size, (row+1) * square_size, fill=color)
        canvas.create_text(x, y, text=char, fill=font_color, font=('Calibri', int(font_size)))
        note = char_note.get()
        # Log the color and character info
        logging.info(f"Position:'{x};{y}',Xp:'{x}',Yp:'{y}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{x},{y},{char},{color},{font_color},{note}", file=login)

    except Exception as e:
        print(f"Something Went Wrong... Error: {e}")



def draw_char(i=None, j=None):
    try:
        """Draws a character from input field in a specific square"""
        global char_count, IDE_mode, typing_mode, last_drawn, font_color
        if(mode == 'IDE'):
            IDE_mode = True
        # Check if last_drawn is defined, otherwise define it
        if 'last_drawn' not in globals():
            last_drawn = []

        # If i, j are not provided, calculate them based on char_count
        if i is None or j is None:
            i, j = divmod(char_count, grid_size)
            # Handle out-of-grid situations
            if i >= grid_size or j >= grid_size:
                print('Out of grid!')
                return

        # Generate a random color if not in typing mode, white otherwise
        ##color = get_random_color() if not typing_mode else "white"

        # Check color mode
        if color_mode_var.get():
            # Manual color mode
            # Show a color picker and get the chosen color for the square
            color = askcolor(title="Choose square color")[1]

            # Ask for the font color
            color_result = askcolor(title="Choose font color")
            if color_result is not None:
                font_color = color_result[1]
            else:
                # Handle the case when the user cancelled the color selection
                font_color = "#000000"  # default to black, for example


        else:
            # Random color mode
            color = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            color1 = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            font_color = color1 #"#000000"


        square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
        char = char_entry.get()[:1]
        note = char_note.get()
        text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", font_size), fill=font_color, anchor="center")

        '''
        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}'")
        # Log the color and character info in a text file
        with open("color_log.txt", "a") as login:
            print(f"{i},{j},{char},{color},{font_color}", file=login)
        '''

        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{i},{j},{char},{color},{font_color},{note}", file=login)

        
        if len(char_entry.get()) > 0:  # Check if there's more than one character
            char_entry.delete(0, 1)  # Delete the first character

        last_drawn.append((square, text))

        if not IDE_mode:
            char_count = (char_count + 1) % (grid_size * grid_size)
            if char_count == 0:  # If we've filled the canvas, clear it
                canvas.delete('all')

        return square, text
    except:
        print("Submit an app mode ...")


def adjust_grid_and_font():
    global grid_size, square_size, font_size, canvas_width, current_row, current_col

    n_g_s = simpledialog.askstring("Change Grid Size (Grid Width)", "Enter New Grid Size (+Integer):")
    if(n_g_s != ''):
        new_grid_size = n_g_s
    n_f_s = simpledialog.askstring("Change Font Size (Default = 9)", "Enter New Font Size (+Integer):")
    if(n_f_s != ''):
        new_font_size = n_f_s
        # Update the global variables
    if(new_grid_size==None and new_font_size==None):
        grid_size = 10
        font_size = 9
    if((not new_grid_size==None) and (not new_font_size==None)):
        try: 
            grid_size = int(new_grid_size)
            square_size = canvas_width / grid_size
            font_size = int(new_font_size)
        except:
            print("positive integers please")
        
    '''
    # Get new values from input fields
    new_grid_size = grid_size_entry.get()
    new_font_size = font_size_entry.get()
    
    # Update the global variables
    grid_size = int(new_grid_size)
    square_size = canvas_width // grid_size
    font_size = int(new_font_size)
    '''

    # Redraw the grid
    refresh_canvas()
    qit = input("Are you in typing mode, or want to enter typing mode? 1 for (No), 2 for (yes): ")
    if(qit == '2'):
        current_row = 0
        current_col = 0
        show_typing_mode_menu()

def refresh_canvas():
    """Clears the canvas and resets the char_count"""
    global char_count
    canvas.delete('all')
    char_count = 0
    draw_grid_IDE()
    last_drawn.clear()

def undo_last():
    """Undoes the last drawing operation"""
    if last_drawn:
        square, text = last_drawn.pop()
        canvas.delete(square)
        canvas.delete(text)

def update_canvas():
    if not paused.get():
        canvas.delete('all')
        draw_grid()
    root.after(8000, update_canvas)

def toggle_typing_mode():
    global typing_mode, canvas

    typing_mode = not typing_mode
    if typing_mode:
        canvas.focus_set()  # Set focus to the canvas for keyboard input



def on_canvas_click(event):
    try:
        global mode, typing_mode
        if mode == 'IDE' and not typing_mode:
            j = event.x // square_size
            i = event.y // square_size
            draw_char(i, j)
        else:
            paused.set(not paused.get())
    except:
        print("Submit an app mode ...")

def on_key_press(event):
    global char_count, typing_mode
    if typing_mode:
        char_entry.delete(0, 'end')  # Clear the entry box
        try:
            utf8_char = event.char.encode('utf-8').decode('utf-8')
            char_entry.insert(0, utf8_char)  # Insert the typed character
        except UnicodeDecodeError:
            print("Non UTF-8 character detected")
            return
        draw_char()  # Draw the character
        char_count += 1  # Increment the count

        # If char_count exceeds the total number of squares in the grid, reset it
        if char_count >= grid_size ** 2:
            char_count = 0




def submit_mode():

    global char_count, mode, typing_mode
    
    mode = mode_entry.get().upper()
    
    '''
    if mode in ['editor']:

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        draw_grid()
        char_label.pack()
        char_entry.pack()
        char_button.pack()

    '''    
        
    # Draw the initial grid
    if(mode != 'IDE'):
        print("A valid mode ...")

    '''
    if(mode == 'normal'):

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()

        draw_grid()
        create_menu_1()

    if mode == 'normal':
        # Schedule the first update
        root.after(8000, update_canvas)
    '''
    
    if mode == 'IDE':

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        char_count = 0
        draw_grid_IDE()
        
        control_frame.pack()
        char_label.pack()
        char_entry.pack()
        #grid_size_label.pack()
        #grid_size_entry.pack()
        #font_size_label.pack()
        #font_size_entry.pack()
        #adjust_button.pack()
        char_note_label.pack()
        char_note.pack()
        #refresh_button.pack(side="left")
        #undo_button.pack(side="left")
        #save_button = tk.Button(root, text='Save', command=save_canvas, bg="white", padx=5, pady=0)
        #save_button.pack(side="left")
        #save_Sbutton.pack(side="left")
        #load_button.pack(side="left")
        create_menu()


    return mode



def save_canvas():
    global IC_value, xSwitch, ing
    xSwitch = 1
    ing = 1
    if(ing == 0):
        ing = 2
    ing = 1
    if(xSwitch == 1 and ing == 1):
        IC_value = 0
        ing = 0
    """Save the current state of the canvas to a .png file"""
    #filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    filename = f"ImageCanvas{IC_value}_rename"
    
    if filename:  # Only save the canvas if a filename was entered
        # Get the bounding box of the canvas
        x = root.winfo_rootx() + canvas.winfo_x()
        y = root.winfo_rooty() + canvas.winfo_y()
        x1 = x + canvas.winfo_width()
        y1 = y + canvas.winfo_height()
        time.sleep(3)
        # Grab the image, crop it to the bounding box, and save it
        ImageGrab.grab().crop((x, y, x1, y1)).save(filename + ".png")


def save_session():
    """Save the current session to a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Save Session", "Enter filename:")
    if filename:  # Only save the session if a filename was entered
        session_data = [(canvas.coords(square), canvas.itemcget(square, "fill"),
                        canvas.coords(text), canvas.itemcget(text, "text"), canvas.itemcget(text, "fill"))
                        for square, text in last_drawn]
        with open(filename + ".pkl", "wb") as f:
            pickle.dump(session_data, f)


def load_session():
    """Load a saved session from a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Load Session", "Enter filename:")
    if filename:  # Only try to load a session if a filename was entered
        try:
            with open(filename + ".pkl", "rb") as f:
                session_data = pickle.load(f)
                # Clear the canvas and redraw all elements from the loaded session
                canvas.delete('all')
                draw_grid_IDE()
                last_drawn = []
                for square_coords, square_fill, text_coords, text_content, text_fill in session_data:
                    square = canvas.create_rectangle(*square_coords, fill=square_fill)
                    text = canvas.create_text(*text_coords, text=text_content, fill=text_fill, font=("Arial", font_size), anchor="center")
                    last_drawn.append((square, text))
        except FileNotFoundError:
            print(f"No session named '{filename}' found.")

#def exit_app():
#    exit()

def show_about():
    about_window = tk.Toplevel(root)
    about_window.title("About")
    about_msg = "This is a program created to learn and experiment with Tkinter. In IDE mode, you can draw characters on a grid (By typing or copying and pasting then clicking the squares you want to draw each character on), adjust the grid and font size, save and load sessions, and more, like saving the grid as an image (For example). C(num) was written with the aid of Chat GPT. Enjoy!\n\nNote: the workflow ... IDE to color_log.txt (Compiled by compile#.exe or compile#.py);\nindex_1.txt contains fields of study or research and development and\nindex_2.txt contains fields of study or research and development also ...\n\nBertotools Digital"
    tk.Message(about_window, text=about_msg, width=500).pack()
    tk.Button(about_window, text="OK", command=about_window.destroy).pack()

def compileGOSmX():
    MAX_LINE_LENGTH = 256
    MAX_TOPICS = 256

    global index_1, index_2
    
    index_1 = [
        "Axiom",
        "Theorem",
        "Lemma",
        "Proposition",
        "Corollary",
        "Conjecture",
        "Proof",
        "Premise",
        "Conclusion",
        "Hypothesis",
        "Counterexample",
        "Direct Proof",
        "Indirect Proof",
        "Proof by Contradiction (Reductio ad absurdum)",
        "Proof by Induction",
        "Proof by Contrapositive",
        "Deductive Reasoning",
        "Inference",
        "Assumption",
        "Statement",
        "Postulate",
        "Proof by Exhaustion",
        "Syllogism",
        "Constructive Proof",
        "Non-Constructive Proof",
        "Trivial Proof",
        "Vacuous Proof",
        "Biconditional",
        "Condition",
        "Sufficiency",
        "Necessity",
        "Quantifier",
        "Universal Quantifier",
        "Existential Quantifier",
        "Bound Variable",
        "Free Variable",
        "Predicate",
        "Propositional Logic",
        "Modus Ponens",
        "Modus Tollens",
        "Discrete Mathematics",
        "Set Theory",
        "Function",
        "Bijection",
        "Injection",
        "Surjection",
        "Equivalence Relation",
        "Partial Order",
        "Total Order",
        "Well-Order",
        "Reflexivity",
        "Symmetry",
        "Transitivity",
        "Antisymmetry",
        "Completeness",
        "Compactness",
        "Connectedness",
        "Convergence",
        "Divergence",
        "Limit",
        "Sequence",
        "Series",
        "Monotonicity",
        "Cauchy Sequence",
        "Infinite Set",
        "Finite Set",
        "Cardinality",
        "Countable Set",
        "Uncountable Set",
        "Subset",
        "Superset",
        "Intersection",
        "Union",
        "Empty Set",
        "Power Set",
        "Cartesian Product",
        "Equivalence Class",
        "Partition",
        "Field",
        "Ring",
        "Group",
        "Abelian Group",
        "Non-abelian Group",
        "Matrix",
        "Vector Space",
        "Linear Transformation",
        "Eigenvalue",
        "Eigenvector",
        "Norm",
        "Inner Product",
        "Orthogonality",
        "Basis",
        "Dimension",
        "Rank",
        "Nullity",
        "Determinant",
        "Graph Theory",
        "Vertex",
        "Edge",
        "Connectivity",
        "Cycle",
        "Path",
        "Degree",
        "Subgraph",
        "Tree",
        "Forest",
        "Planar Graph",
        "Bipartite Graph",
        "Directed Graph (Digraph)",
        "Eulerian Graph",
        "Hamiltonian Graph",
        "Adjacency Matrix",
        "Incidence Matrix",
        "Isomorphism",
        "Homeomorphism",
        "Topology",
        "Open Set",
        "Closed Set",
        "Boundary",
        "Compact Space",
        "Hausdorff Space",
        "Continuity",
        "Differential",
        "Derivative",
        "Integral",
        "Partial Derivative",
        "Multivariable Calculus",
        "Laplace Transform",
        "Fourier Transform",
        "Taylor Series",
        "Maclaurin Series",
        "Conic Sections",
        "Hyperbola",
        "Ellipse",
        "Parabola",
        "Asymptote",
        "Limits at Infinity",
        "Complex Number",
        "Imaginary Unit",
        "Real Number",
        "Rational Number",
        "Irrational Number",
        "Prime Number",
        "Composite Number",
        "GCD (Greatest Common Divisor)",
        "LCM (Least Common Multiple)",
        "Permutation",
        "Combination",
        "Probability",
        "Statistics",
        "Expected Value",
        "Variance",
        "Standard Deviation",
        "Normal Distribution",
        "Poisson Distribution",
        "Binomial Distribution",
        "Hypothesis Testing",
        "Regression",
        "Correlation",
        "Matrix Algebra",
        "Linear Algebra",
        "Vector Calculus",
        "Optimization",
        "Algorithm",
        "Computational Complexity",
        "Big O Notation",
        "Pigeonhole Principle",
        "Principle of Inclusion-Exclusion",
        "Turing Machine",
        "Computability",
        "Unsolvability",
        "Parity",
        "Diophantine Equations",
        "Cryptography",
        "Fermat's Last Theorem",
        "Pythagorean Theorem",
        "Triangle Inequality",
        "Trigonometric Functions",
        "Trigonometric Identities",
        "Polar Coordinates",
        "Euler's Formula",
        "Riemann Zeta Function",
        "P vs NP Problem",
        "NP-complete Problem",
        "Stochastic Process",
        "Markov Chain",
        "Random Variable",
        "Conditional Probability",
        "Bayes' Theorem",
        "Monte Carlo Method",
        "Fractal",
        "Chaos Theory",
        "Game Theory",
        "Nash Equilibrium",
        "Zero-Sum Game",
        "Non-Zero-Sum Game",
        "Linear Programming",
        "Nonlinear Programming",
        "Quadratic Programming",
        "Dynamic Programming",
        "Integer Programming",
        "Graph Coloring",
        "Network Flow",
        "Spanning Tree",
        "Bellman-Ford Algorithm",
        "Dijkstra's Algorithm",
        "Kruskal's Algorithm",
        "Prim's Algorithm",
        "Floyd-Warshall Algorithm",
        "Euler's Method",
        "Runge-Kutta Method",
        "Numerical Integration",
        "Numerical Differentiation",
        "Bisection Method",
        "Newton's Method",
        "Secant Method",
        "Fixed Point Iteration",
        "Linear Interpolation",
        "Polynomial Interpolation",
        "Lagrange Interpolation",
        "Splines",
        "Fourier Series",
        "Laplace's Equation",
        "Heat Equation",
        "Wave Equation",
        "Schrodinger Equation",
        "Ordinary Differential Equation (ODE)",
        "Partial Differential Equation (PDE)",
        "Boundary Value Problem",
        "Initial Value Problem",
        "Green's Theorem",
        "Stoke's Theorem",
        "Divergence Theorem",
        "Curl",
        "Gradient",
        "Divergence",
        "Tensor",
        "Manifold",
        "Topological Space",
        "Measure Theory",
        "Lebesgue Integral",
        "Borel Set",
        "Hilbert Space",
        "Banach Space",
        "Category Theory",
        "Functor",
        "Natural Transformation",
        "Sheaf",
        "Homotopy",
        "Homology",
        "Cohomology",
        "Galois Theory",
        "Algebraic Geometry",
        "Topological K-Theory",
        "Knot Theory",
        "Lattice Theory"
    ]

    index_2 = [
        "Biochemistry",
        "Biophysics",
        "Molecular biology",
        "Genetics",
        "Immunology",
        "Cell biology",
        "Microbiology",
        "Neuroscience",
        "Pharmacology",
        "Bioinformatics",
        "Biotechnology",
        "Proteomics",
        "Genomics",
        "Structural biology",
        "Virology",
        "Systems biology",
        "Developmental biology",
        "Evolutionary biology",
        "Synthetic biology",
        "Metabolomics",
        "Epigenetics",
        "Tissue engineering",
        "Nanotechnology",
        "Materials science",
        "Quantum physics",
        "Condensed matter physics",
        "Particle physics",
        "Astrophysics",
        "Cosmology",
        "Optics",
        "Atomic and molecular physics",
        "Fluid mechanics",
        "Thermodynamics",
        "Environmental science",
        "Climate science",
        "Geology",
        "Oceanography",
        "Atmospheric science",
        "Ecology",
        "Conservation biology",
        "Botany",
        "Zoology",
        "Entomology",
        "Marine biology",
        "Paleontology",
        "Anthropology",
        "Archaeology",
        "Psychology",
        "Cognitive science",
        "Social psychology",
        "Linguistics",
        "Artificial intelligence",
        "Machine learning",
        "Computer vision",
        "Natural language processing",
        "Human-computer interaction",
        "Robotics",
        "Computer graphics",
        "Data science",
        "Mathematical modeling",
        "Mathematical physics",
        "Number theory",
        "Algebraic geometry",
        "Differential equations",
        "Computational physics",
        "Mathematical biology",
        "Operations research",
        "Biostatistics",
        "Epidemiology",
        "Cancer research",
        "Diabetes research",
        "Heart disease research",
        "Infectious diseases research",
        "Immunotherapy",
        "Stem cell research",
        "Gene therapy",
        "Drug discovery",
        "Precision medicine",
        "Health informatics",
        "Renewable energy",
        "Energy storage",
        "Sustainable materials",
        "Environmental engineering",
        "Water management",
        "Transportation engineering",
        "Civil engineering",
        "Chemical engineering",
        "Aerospace engineering",
        "Biomedical engineering",
        "Electrical engineering",
        "Mechanical engineering",
        "Robotics engineering",
        "Quantum computing",
        "Cryptography",
        "Cybersecurity",
        "Network engineering",
        "Telecommunications",
        "Human genetics",
        "Forensic science",
        "Space exploration and research",
        "Planetary science",
        "Astrobiology",
        "Astrochemistry",
        "Astrogeology",
        "Astroinformatics",
        "Exoplanet research",
        "Stellar evolution",
        "Galactic astronomy",
        "Observational astronomy",
        "Computational astrophysics",
        "Quantum chemistry",
        "Computational chemistry",
        "Organic chemistry",
        "Inorganic chemistry",
        "Physical chemistry",
        "Environmental chemistry",
        "Analytical chemistry",
        "Agricultural science",
        "Food science",
        "Nutritional science",
        "Exercise physiology",
        "Sports science",
        "Biomechanics",
        "Plant physiology",
        "Plant genetics",
        "Plant pathology",
        "Soil science",
        "Hydrology",
        "Geochemistry",
        "Geophysics",
        "Geomorphology",
        "Remote sensing",
        "Geotechnical engineering",
        "Petroleum engineering",
        "Aerospace materials",
        "Nanomaterials",
        "Polymer science",
        "Computational materials science",
        "Photonics",
        "Physical optics",
        "Quantum optics",
        "Neuroengineering",
        "Brain imaging",
        "Cognitive neuroscience",
        "Neuroinformatics",
        "Psychophysics",
        "Developmental psychology",
        "Personality psychology",
        "Clinical psychology",
        "Industrial-organizational psychology",
        "Educational psychology",
        "Psycholinguistics",
        "Human genetics",
        "Evolutionary genetics",
        "Population genetics",
        "Genetic engineering",
        "Genetic counseling",
        "Epigenomics",
        "Cardiovascular research",
        "Respiratory research",
        "Gastroenterology research",
        "Endocrinology research",
        "Nephrology research",
        "Hematology research",
        "Ophthalmology research",
        "Orthopedic research",
        "Dermatology research",
        "Veterinary medicine",
        "Animal behavior",
        "Conservation ecology",
        "Wildlife biology",
        "Environmental microbiology",
        "Agricultural economics",
        "Development economics",
        "Behavioral economics",
        "Econometrics",
        "Financial mathematics",
        "Operations management",
        "Supply chain management",
        "Industrial engineering",
        "Human-computer interaction",
        "Virtual reality",
        "Augmented reality",
        "Data mining",
        "Text mining",
        "Big data analytics",
        "Computational linguistics",
        "Quantum information science",
        "Quantum cryptography",
        "Biometrics",
        "Information retrieval",
        "Software engineering",
        "Computer networks",
        "Embedded systems",
        "Human-robot interaction",
        "Control systems",
        "Biopharmaceuticals",
        "Drug delivery systems",
        "Clinical trials",
        "Regenerative medicine",
        "Agricultural biotechnology",
        "Plant breeding",
        "Animal breeding",
        "Food technology",
        "Sensory science",
        "Poultry science",
        "Aquaculture",
        "Marine ecology",
        "Limnology",
        "Population ecology",
        "Landscape ecology",
        "Evolutionary ecology",
        "Environmental toxicology",
        "Environmental chemistry",
        "Environmental microbiology",
        "Ecotoxicology",
        "Green chemistry",
        "Space physics",
        "Space weather",
        "Astrostatistics",
        "Computational fluid dynamics",
        "Mathematical optimization",
        "Operations research",
        "Human genetics",
        "Functional genomics",
        "Molecular genetics",
        "Cancer genetics",
        "Psychiatric genetics",
        "Population genomics",
        "Bioengineering",
        "Biomaterials",
        "Biomechatronics",
        "Cardiovascular engineering",
        "Neural engineering",
        "Rehabilitation engineering",
        "Genetic engineering",
        "Environmental engineering",
        "Water resources engineering",
        "Structural engineering",
        "Robotics engineering",
        "Quantum information theory",
        "Quantum simulation",
        "Quantum sensing",
        "Geographical information systems (GIS)",
        "Urban planning",
        "Renewable energy systems",
        "Solar cell technology",
        "Wind energy research",
        "Energy policy and economics",
        "Computational neuroscience",
        "Neurobiology",
        "Cognitive neuroscience",
        "Systems neuroscience",
        "Human-robot interaction",
        "Evolutionary psychology",
        "Social network analysis"
    ]



    def square_print_topic_indices(r_value, g_value, b_value, file):
        index1 = r_value % len(index_1)
        index2 = g_value % len(index_1)
        index3 = b_value % len(index_1)
        '''
        file.write(f"\t\t\t{topics[index1]}\n")
        file.write(f"\t\t\t{topics[index2]}\n")
        file.write(f"\t\t\t{topics[index3]}\n")
        '''
        file.write(f"\t\t\t{index_1[index1]}\n")
        file.write(f"\t\t\t{index_1[index2]}\n")
        file.write(f"\t\t\t{index_1[index3]}\n")
                
        squareRatio = str(index1) + ":" + str(index2) + ":" + str(index3)
        return squareRatio

    def font_print_topic_indices(r_value, g_value, b_value, file):
        index1_ = r_value % len(index_2)
        index2_ = g_value % len(index_2)
        index3_ = b_value % len(index_2)
        file.write(f"\t\t\t{index_2[index1_]}\n")
        file.write(f"\t\t\t{index_2[index2_]}\n")
        file.write(f"\t\t\t{index_2[index3_]}\n")

        fontRatio = str(index1_) + ":" + str(index2_) + ":" + str(index3_)
        return fontRatio



    def get_index(i, j, grid_size):
        return i * grid_size + j

    def extract_rgb_values(color):
        if len(color) != 7 or color[0] != '#':
            raise ValueError('Input should be a hex color code in the format "#RRGGBB"')
        try:
            red = int(color[1:3], 16)
            green = int(color[3:5], 16)
            blue = int(color[5:7], 16)
            return red, green, blue
        except ValueError:
            raise ValueError('Invalid color code. RGB values should be hex digits (0-9, A-F)')


    def GO():
        log_file = "color_log.txt"
##        topic_file = "index_1.txt"
##        topic2_file = "index_2.txt"  # Corrected this line to read from a different file
        gridWidth = int(input("Enter gridWidth: "))
        # Read topic files to get the topics and topic2s
##        with open(topic_file, "r", encoding='utf8') as file:
##            topics = [line.strip() for line in file]
##
##        with open(topic2_file, "r", encoding='utf8') as file:
##            topic2s = [line.strip() for line in file]

        numTopics = len(index_1)
        numTopic2s = len(index_2)

        # Read color log file
        with open(log_file, "r") as file:
            lines = file.readlines()

        lineNumber = 0
        # Save output to a file
        output_file = "output.txt"
        with open(output_file, "w") as file:
            print()
        for line in lines:
            parts = line.strip().split(",")
            if len(parts) >= 5:
                xcoor = int(parts[1])
                ycoor = int(parts[0])
                index_ = (gridWidth * ycoor) + xcoor
                character = parts[2]
                squareColor = parts[3]
                fontColor = parts[4]
                notes = parts[5]

                # Extract RGB values from squareColor
                red, green, blue = extract_rgb_values(squareColor)

                # Extract RGB values from fontColor
                fontRed, fontGreen, fontBlue = extract_rgb_values(fontColor)

                # Calculate the grid size
                grid_size = int(parts[0])

                # Select topics based on RGB values from squareColor
                topicIndices = [(red + get_index(i, j, grid_size)) % numTopics for i in range(grid_size) for j in range(grid_size)]
                
                lineNumber += 1

                
                with open(output_file, "a") as file:
                    file.write(f"Compiling Line/s: {lineNumber}\n\n")
                    file.write(f"Line({lineNumber})\n\n")
                    file.write(f"0\tLineNumber: {lineNumber}\tx-coordinate: {xcoor}\ty-coordinate: {ycoor}\t Character: {character}\tRGB: {squareColor}\tRGB: {fontColor}\t Note: {notes}\t GridDimensions: {gridWidth}x{gridWidth}\n\n")
                    #print(topicIndices)
                    file.write(f"Line/s({lineNumber}) Output:\n\n")
                    file.write(f"#define Line({lineNumber}){{\n\n")
                    # Inside the main function
                    file.write(f"\ti_1_0(squareColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {red}, G: {green}, B: {blue})\n")
                    s_ratio = square_print_topic_indices(red, green, blue, file)
                    #square_print_topic_indices(red, green, blue, topics, file)   # Modify this line
                    file.write("\t\t)\n")
                    file.write("\t};\n\n")
                    file.write(f"\ti_1_1(fontColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {fontRed}, G: {fontGreen}, B: {fontBlue})\n")
                    f_ratio = font_print_topic_indices(fontRed, fontGreen, fontBlue, file)
                    #font_print_topic_indices(fontRed, fontGreen, fontBlue, topic2s, file)   # And this line
                    file.write("\t\t)\n")
                    file.write(f"\treturn squareRatio({s_ratio}), fontRatio({f_ratio}), sqaureIndex({index_})\n")
                    #file.write(f"\treturn fontRatio({f_ratio})\n")
                    file.write("}\n\n")


    GO()


def create_menu():
    global control_frame
    def home():
        canvas.pack_forget()
        menubar.destroy()
        control_frame.pack()
        char_entry.pack_forget()
        char_label.pack_forget()
        #grid_size_label.pack_forget()
        #grid_size_entry.pack_forget()
        #font_size_label.pack_forget()
        #font_size_entry.pack_forget()
        #adjust_button.pack_forget()
        char_note.pack_forget()
        char_note_label.pack_forget()

        root.destroy()
        switch = 1
        setup_mode(switch)
    
    # Create a menubar
    menubar = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu = tk.Menu(menubar, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="Toggle Manual/Random Colour", command=manual_colour)

    dropdown.add_command(label="Refresh", command=refresh_canvas)
    dropdown.add_command(label="Undo", command=undo_last)
    dropdown.add_command(label="Save Session", command=save_session)
    dropdown.add_command(label="Load Session", command=load_session)
    dropdown.add_command(label="Save as Image", command=save_canvas)
    dropdown.add_command(label="Compile Canvas", command=compileGOSmX)
    #dropdown.add_command(label="Exit", command=exit_app)
    #dropdown.add_command(label="Toggle Type/Click Mode", command=toggle_typing_mode)
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Go Home", command=home)
    dropdown.add_command(label="Edit Grid Dimensions", command=adjust_grid_and_font)
    dropdown.add_command(label="Typing Mode", command=show_typing_mode_menu)


    # Set the menubar
    root.config(menu=menubar)

    

def create_menu_1():
    global control_frame
    def home1():
        canvas.pack_forget()
        menubar1.destroy()
        root.destroy()
        switch = 1
        setup_mode(switch)
        
    
    # Create a menubar
    menubar1 = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu1 = tk.Menu(menubar1, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar1, tearoff=0)
    menubar1.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Change Mode", command=home1)

    # Set the menubar
    root.config(menu=menubar1)


def manual_colour():
    # Toggle the value of color_mode_var
    current_value = color_mode_var.get()
    color_mode_var.set(not current_value)


'''
# Create a tkinter window
root = tk.Tk()
root.title("General Operating System")
root.iconbitmap("logo.ico")
'''

def show_typing_mode_menu():
    global color_
    while True:
        print("1. Use default UTF-8 mapping")
        print("4. Exit")
        choice = input("Choose an option: ")
        
        if choice == "1":
            # Use default UTF-8 mapping
            print("Using default UTF-8 mapping.")
            color_ = input("Use Default Colour Scheme (1): ")
            if(color_ == '1'):
                # Initialize bg_color and font_color with default values at the global scope
                bg_color = "#FFFFFF"  # Default white background color
                font_color = "#000000"  # Default black font color
                break
        else:
            print("Invalid choice. Please try again.")

    canvas.bind("<Key>", type_character)
    canvas.focus_set()





def set_background_color():
    global color
    #bg_color = tk.colorchooser.askcolor()[1]
    color = input("Enter background color (#FFFFFF for example):")
    
def set_font_color():
    global font_color, font_size
    #font_color = tk.colorchooser.askcolor()[1]
    font_color = input("Enter background color (#000000 for example): ")
    font_size = input("Enter font_size: ")


def type_character(event):
    global current_row, current_col, col, font_size, font_color, color, canvas_width, square_size
    color = "#FFFFFF"
    font_color = "#000000"
    char = event.char
    if char:  # Ignore non-character events
        try:
            
            draw_char1(canvas, char, current_row, current_col, font_size, color)
            current_col += 1
            if (current_col >= canvas_width/square_size):
                current_col = 0
                current_row += 1
            if(current_row >= canvas_width/square_size):
                current_col = 0
                current_row = 0
        except Exception as e:
            print("Something Went Wrong...")
            print(e)

        
        


def setup_mode(sw):

    global mode_entry, mode_label, square_size, grid_size, char_count, last_drawn
    global root, color_mode_var, logging, paused, canvas_width, canvas_height, canvas
    global grid_size_label, grid_size_entry, font_size_label, font_size_entry, adjust_button
    global save_Sbutton, load_button, char_label, char_entry, char_note_label, char_note, char_button
    global refresh_button, undo_button, control_frame, submit_button, col, color_


    current_row = 0
    current_col = 0
    color_ = 1
    
    # Define the size of the squares and the grid
    square_size = 70
    grid_size = 10
    char_count = 0
    last_drawn = []

    window_height = square_size * grid_size + (square_size * 2)
    window_width = square_size * grid_size
    

    if(sw == 1):
        # Create a tkinter window
        root = tk.Tk()
        root.title("C22")
        #root.iconbitmap("logo.ico")
        sw = 0
        switch = 0

    ###

    # Get screen width and height
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    # Calculate position of the window
    position_top = int(screen_height / 2 - window_height / 2)
    position_right = int(screen_width / 2 - window_width / 2)

    # Set the dimensions of the window and where it is placed
    root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')

    ###

    # Create a BooleanVar for the color mode and set it to False initially
    color_mode_var = BooleanVar(value=False)

    # Setup logging
    logging.basicConfig(filename='logging.txt', level=logging.INFO)

    paused = tk.BooleanVar()
    paused.set(False)

    canvas_width = grid_size * square_size
    canvas_height = grid_size * square_size
    canvas = tk.Canvas(root, width=canvas_width, height=canvas_height)
    col = canvas_width
    canvas.pack()
    canvas.bind("<Button-1>", on_canvas_click)
    
    # In the function where you create the canvas...
    canvas.bind("<Key>", on_key_press)
    canvas.focus_set()
    
    # Create input fields and buttons for grid and font size input
    grid_size_label = tk.Label(root, text="Grid size:")
    grid_size_entry = tk.Entry(root, width=5)
    font_size_label = tk.Label(root, text="Font size:")
    font_size_entry = tk.Entry(root, width=5)
    adjust_button = tk.Button(root, text='Adjust Grid & Font', command=adjust_grid_and_font)

    # Create the save and load buttons
    save_Sbutton = tk.Button(root, text='Save Session', command=save_session, bg="white", padx=5, pady=0)
    load_button = tk.Button(root, text='Load Session', command=load_session, bg="white", padx=5, pady=0)

    # Create input fields and buttons for mode and character input
    mode_label = tk.Label(root, text="Enter ... 'IDE' for an\nInteractive Development Environment\nfor Learning anything!")
    mode_entry = tk.Entry(root)
    submit_button = tk.Button(root, text='LEARN', command=submit_mode)


    '''
    filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    if filename:
    '''
    
    char_label = tk.Label(root, text="Enter symbol/s to draw: ")
    char_entry = tk.Entry(root, width=12)
    char_note_label = tk.Label(root, text="Enter Note: ")
    char_note = tk.Entry(root, width=12)
    #char_button = tk.Button(root, text='Draw Character', command=draw_char)

    refresh_button = tk.Button(root, text='Refresh', command=refresh_canvas, bg="white", padx=5, pady=0)
    undo_button = tk.Button(root, text='Undo', command=undo_last, bg="white", padx=5, pady=0)

    control_frame = tk.Frame(root)

    mode_label.pack()
    mode_entry.pack()
    submit_button.pack()
    # create_menu(root)

    # Run the tkinter main loop
    root.mainloop()

global switch
switch = 1

setup_mode(switch)


----- Content of BlockDesignCraft.py -----
import tkinter as tk
from tkinter import simpledialog
from tkinter import colorchooser

class BlockDiagramDesigner(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Block Diagram Designer")
        self.geometry("800x600")

        print("Welcome to the Block Diagram Designer!")
        print("Instructions:")
        print("Left-click to add a block.")
        print("Double-click on a block to customize its color and label.")
        print("Press and hold the right mouse button, drag, and release to draw an arrow.")
        print("Press Ctrl+Z to undo the last action.")


        self.canvas = tk.Canvas(self, bg="white")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        self.shift_pressed = False
        self.grid_size = 20  # Size of each grid cell
        self.block_counter = 0  # Counter to keep track of block IDs
        self.draw_grid()

        self.canvas.bind("<Button-1>", self.add_block)
        self.canvas.bind("<ButtonPress-3>", self.start_arrow)
        self.canvas.bind("<ButtonRelease-3>", self.end_arrow)
        self.canvas.bind("<B3-Motion>", self.drag_arrow)
        self.canvas.bind("<Double-Button-1>", self.double_click_block)  # Only keep this for double click
        self.canvas.bind("<Shift-KeyPress>", self.shift_pressed_event)
        self.canvas.bind("<Shift-KeyRelease>", self.shift_released_event)

        self.undo_stack = []  # List to store actions for undo
        self.bind("<Control-z>", self.undo)

        self.labels = {}  # To keep track of block labels
        self.lines = []  # To store lines
        self.arrows = []  # To store arrows

        self.blocks = {}
        self.arrows = []
        self.action_stack = []  # For undo functionality
        self.temp_arrow = None  # For drag-to-draw arrow

        # Variables for arrow drawing
        self.start_position = None
        self.end_position = None
        self.drawing_arrow = False

    def draw_grid(self):
        for i in range(0, 800, self.grid_size):
            self.canvas.create_line([(i, 0), (i, 600)], tag='grid_line', fill="#d3d3d3")

        for i in range(0, 600, self.grid_size):
            self.canvas.create_line([(0, i), (800, i)], tag='grid_line', fill="#d3d3d3")

    def snap_to_grid(self, x, y):
        return round(x / self.grid_size) * self.grid_size, round(y / self.grid_size) * self.grid_size

    def shift_pressed_event(self, event):
        self.shift_pressed = True

    def shift_released_event(self, event):
        self.shift_pressed = False
    
    def add_block(self, event):
        x, y = self.snap_to_grid(event.x, event.y)
        block_width = self.grid_size
        block_height = self.grid_size
        x1, y1 = x - block_width // 2, y - block_height // 2
        x2, y2 = x + block_width // 2, y + block_height // 2
        block = self.canvas.create_rectangle(x1, y1, x2, y2, fill='gold', tags="block")
        self.blocks[block] = {'coords': [x1, y1, x2, y2], 'fill': 'gold', 'label': None, 'font_color': None}

        # Store the block information with its ID as the key
        self.blocks[block] = {'id': block, 'coords': [x1, y1, x2, y2], 'fill': 'gold', 'label': None, 'font_color': None}
        self.block_counter += 1  # Increment the block counter
        self.undo_stack.append(("add_block", block))
    
    def change_block_color(self, event):
        # Find closest block
        x, y = self.snap_to_grid(event.x, event.y)
        closest_block = self.canvas.find_closest(x, y, halo=20, start=None)
        if closest_block:
            block = closest_block[0]
            new_color = colorchooser.askcolor()[1]
            if new_color:
                self.canvas.itemconfig(block, fill=new_color)
        
        # New code to change label color
        if block in self.labels:
            label = self.labels[block]
            new_font_color = colorchooser.askcolor()[1]
            if new_font_color:
                self.canvas.itemconfig(label, fill=new_font_color)

    def double_click_block(self, event):
        clicked_items = self.canvas.find_withtag(tk.CURRENT)
        for item in clicked_items:
            if "block" in self.canvas.gettags(item):
                # Code to show dialog boxes for customizing the block
                block_fill = colorchooser.askcolor(title="Choose block color")[1]
                self.canvas.itemconfig(item, fill=block_fill)
                
                label_font_color = colorchooser.askcolor(title="Choose label font color")[1]
                
                label_text = simpledialog.askstring("Input", "Enter the label:")
                
                self.canvas.create_text((self.blocks[item]['coords'][0] + self.blocks[item]['coords'][2]) // 2, 
                                        (self.blocks[item]['coords'][1] + self.blocks[item]['coords'][3]) // 2,
                                        text=label_text, fill=label_font_color)

    def label_block(self, event):
        item = self.canvas.find_closest(event.x, event.y)
        if 'block' in self.canvas.gettags(item):
            label = simpledialog.askstring("Input", "Enter block label:")
            if label:
                label = label.encode('utf-8').decode('utf-8')
                x, y = self.blocks[item[0]]
                self.canvas.create_text(x, y, text=label)

    def undo(self, event=None):
        if self.undo_stack:
            action, item = self.undo_stack.pop()
            if action == "add_block":
                # Delete the last added block
                self.canvas.delete(item)
            elif action == "add_arrow" or action == "add_line":
                # Delete the last added arrow or line
                self.canvas.delete(item)
                if action == "add_arrow" and item in self.arrows:
                    self.arrows.remove(item)
                #elif action == "add_line" and item in self.lines:
                #    self.lines.remove(item)
            elif action == "add_label":
                # Delete the last added label
                self.canvas.delete(item)



    def start_arrow(self, event):
        x, y = self.snap_to_grid(event.x, event.y)
        self.start_position = [x, y]
        self.drawing_arrow = True
        self.end_position = [x, y]  # Start with the end position at the cursor

        # Create the temporary arrow (temp_arrow)
        if self.drawing_arrow:
            self.temp_arrow = self.canvas.create_line(x, y, x, y, arrow=tk.LAST, tags="temp_arrow")

    def drag_arrow(self, event):
        if self.drawing_arrow:
            x, y = self.snap_to_grid(event.x, event.y)
            self.end_position = [x, y]
            if self.temp_arrow:
                self.canvas.coords(self.temp_arrow, self.start_position[0], self.start_position[1], x, y)

    def end_arrow(self, event):
        #global terminating_coords
        if self.drawing_arrow:
            x, y = self.snap_to_grid(event.x, event.y)
            closest_block = self.canvas.find_closest(x, y, halo=20, start=None)
            if closest_block:
                block = closest_block[0]

                # Check if the block ID exists in self.blocks
                if block in self.blocks:
                    x1, y1, x2, y2 = self.blocks[block]['coords']
                    cx, cy = (x1 + x2) / 2, (y1 + y2) / 2  # center coordinates

                    # Determine the end position based on user input
                    if self.end_position[0] == x and self.end_position[1] == y:
                        terminating_coords = self.end_position  # User clicked to set the end coordinates
                    else:
                        # User specified a direction (top, right, bottom, left)
                        direction = self.end_position
                        if direction == "top":
                            terminating_coords = [cx, y1]
                        elif direction == "right":
                            terminating_coords = [x2, cy]
                        elif direction == "bottom":
                            terminating_coords = [cx, y2]
                        elif direction == "left":
                            terminating_coords = [x1, cy]
                        else:
                            terminating_coords = self.end_position

                        # Draw an arrow and store it in self.arrows
                        arrow = self.canvas.create_line(self.start_position[0], self.start_position[1], terminating_coords[0], terminating_coords[1], arrow=tk.LAST, tags="arrow")
                        self.action_stack.append(("add_arrow", arrow))
                        self.arrows.append(arrow)  # Append the arrow to the arrows list
                        #self.arrows.append(arrow)

                # Reset the arrow drawing state
                self.drawing_arrow = False

        # Delete the temporary arrow if it exists
        #if self.temp_arrow:
        #    self.canvas.delete(self.temp_arrow)



if __name__ == "__main__":
    app = BlockDiagramDesigner()
    app.mainloop()


----- Content of BooleanWords.py -----
import itertools

def is_valid_expression(expression):
    last_was_operator = True # Start with True to disallow leading operators
    for token in expression:
        if token in ['AND', 'OR', 'XOR']:
            if last_was_operator:
                return False
            last_was_operator = True
        elif token == 'NOT':
            if not last_was_operator:
                return False
            last_was_operator = True
        else:
            if not last_was_operator:
                return False
            last_was_operator = False
    return not last_was_operator  # Expression can't end with an operator

# Function to create B# Boolean statements
def create_boolean_statements(array, mapping, num_placeholders):
    statements = []
    if num_placeholders % 2 == 0:
        print("Number of placeholders must be odd.")
        return
    
    placeholders = ["_" for _ in range(num_placeholders)]
    
    combinations = list(itertools.product(array, repeat=num_placeholders))
    
    for combination in combinations:
        statement = placeholders.copy()
        for i, val in enumerate(combination):
            statement[i] = mapping[val]
        if is_valid_expression(statement):
            statements.append(" ".join(statement))
    
    return statements

# Function to load senses from an external file
def load_senses_from_file(filename):
    mapping_ = {}
    with open(filename, 'r') as file:
        for line in file:
            index, label = line.strip().split(" ")
            mapping_[int(index)] = label
    return mapping_, len(mapping_)


# Ask the user for the size of the array
ask = input("Type defaults to use default settings else type continue or custom to load settings from a file: ")

if(ask == 'continue'):
    size = int(input("Enter the size of your array: "))
    
array = []

# Dictionary to hold default settings
if(ask == 'defaults'):
    size = 9
    mapping = {
        1: "Sound",
        3: "Taste",
        4: "Touch",
        5: "Light",
        6: "Smell",
        7: "AND",
        8: "OR",
        9: "NOT",
        10: "XOR"
    }
    
    array = list(mapping.keys())[:size]
        
elif(ask == 'continue'):
    
    #mapping = {}
    
    for i in range(size):
        num = int(input(f"Enter element {i+1}: "))
        array.append(num)
        label = input(f"Enter the label for {num}: ")
        mapping[num] = label

elif(ask == 'custom'):
    filename = input("Enter 'filename.txt' to load custom settings: ")
    mapping, size = load_senses_from_file(filename)
    array = list(mapping.keys())[:size]

else:
    print("typo ...")

num_placeholders = int(input("Enter the number of placeholders (must be odd): "))

statements = create_boolean_statements(array, mapping, num_placeholders)
with open('words.txt', 'w') as f:
    for statement in statements:
        #print(statement)
        f.write(f"{statement}\n")

print("Boolean statements have been saved in 'words.txt'")


----- Content of boolean_senses.cpp -----
//SOLUTION_MAX.cpp, written by Dominic Alexander Cooper (Database of Files from the given set of elements/ functions, that being a).
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("Instruction_Set_Rename.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 97;
	//puts("26 = SPACE");
	//puts("27 = NEWLINE");
	//puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array (0 or 1)? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;
			//fprintf(p,"\n\nF%d\n\n", id);
			fprintf(p,"%d ", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			fprintf(p,"\n");
		}
	}
	if(cheque == 0){
	for (row=0; row < nbr_comb; row++){
			id++;
			//fprintf(p,"\n\nF%d\n\n", id);
			fprintf(p,"%d ", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				cell = (row/rdiv) % (k+1);
				fprintf(p,"%c", a[cell]);
			}
			fprintf(p,"\n");
		}	
	}
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of calculator_app.py -----
import tkinter as tk
from tkinter import ttk

def calc_action(button, entry):
    if button == 'C':
        entry.delete(0, tk.END)
    elif button == '=':
        try:
            entry.insert(tk.END, " = " + str(eval(entry.get())))
        except:
            entry.delete(0, tk.END)
            entry.insert(tk.END, "Error")
    else:
        entry.insert(tk.END, button)

def open_calculator(root):
    calculator = tk.Toplevel(root)
    calculator.title("Calculator")
    
    entry = ttk.Entry(calculator)
    entry.grid(row=0, column=0, columnspan=4)
    
    buttons = [
        '7', '8', '9', '+',
        '4', '5', '6', '-',
        '1', '2', '3', '*',
        'C', '0', '=', '/'
    ]
    
    row_val = 1
    col_val = 0
    for button in buttons:
        ttk.Button(calculator, text=button, command=lambda b=button: calc_action(b, entry)).grid(row=row_val, column=col_val)
        col_val += 1
        if col_val > 3:
            col_val = 0
            row_val += 1

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    ttk.Button(root, text="Open Calculator", command=lambda: open_calculator(root)).pack()
    root.mainloop()


----- Content of canvas2.py -----
import tkinter as tk
from tkinter.colorchooser import askcolor

class DigitalInkApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Digital Ink Application")
        
        self.canvas_bg = "#ffffff"
        self.ink_color = "#000000"

        self.canvas = tk.Canvas(root, bg=self.canvas_bg, width=800, height=600)
        self.canvas.pack(expand=tk.YES, fill=tk.BOTH)

        self.canvas.bind("<B1-Motion>", self.paint)

        menu = tk.Menu(root)
        root.config(menu=menu)

        colorMenu = tk.Menu(menu)
        menu.add_cascade(label="Colors", menu=colorMenu)

        colorMenu.add_command(label="Canvas Background", command=self.change_canvas_bg)
        colorMenu.add_command(label="Ink Color", command=self.change_ink_color)

        editMenu = tk.Menu(menu)
        menu.add_cascade(label="Edit", menu=editMenu)
        editMenu.add_command(label="Clear Canvas", command=self.clear_canvas)

    def paint(self, event):
        x1, y1 = (event.x - 1), (event.y - 1)
        x2, y2 = (event.x + 1), (event.y + 1)
        self.canvas.create_oval(x1, y1, x2, y2, fill=self.ink_color, outline=self.ink_color, width=2)

    def change_canvas_bg(self):
        color = askcolor()[1]
        if color:
            self.canvas_bg = color
            self.canvas.config(bg=self.canvas_bg)

    def change_ink_color(self):
        color = askcolor()[1]
        if color:
            self.ink_color = color

    def clear_canvas(self):
        self.canvas.delete("all")

if __name__ == "__main__":
    root = tk.Tk()
    app = DigitalInkApp(root)
    root.mainloop()


----- Content of canvas3.py -----
import tkinter as tk
from tkinter.colorchooser import askcolor
from PIL import Image, ImageDraw

class DigitalInkApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Digital Ink Application")
        
        self.canvas_bg = "#ffffff"
        self.ink_color = "#000000"
        self.width = 800
        self.height = 600

        self.canvas = tk.Canvas(root, bg=self.canvas_bg, width=self.width, height=self.height)
        self.canvas.pack(expand=tk.YES, fill=tk.BOTH)

        self.canvas.bind("<B1-Motion>", self.paint)

        menu = tk.Menu(root)
        root.config(menu=menu)

        colorMenu = tk.Menu(menu)
        menu.add_cascade(label="Colors", menu=colorMenu)

        colorMenu.add_command(label="Canvas Background", command=self.change_canvas_bg)
        colorMenu.add_command(label="Ink Color", command=self.change_ink_color)

        editMenu = tk.Menu(menu)
        menu.add_cascade(label="Edit", menu=editMenu)
        editMenu.add_command(label="Clear Canvas", command=self.clear_canvas)
        
        sizeMenu = tk.Menu(menu)
        menu.add_cascade(label="Size", menu=sizeMenu)
        sizeMenu.add_command(label="Resize Window", command=self.resize_window)

        fileMenu = tk.Menu(menu)
        menu.add_cascade(label="File", menu=fileMenu)
        fileMenu.add_command(label="Save", command=self.save_canvas)

    def paint(self, event):
        x1, y1 = (event.x - 1), (event.y - 1)
        x2, y2 = (event.x + 1), (event.y + 1)
        self.canvas.create_oval(x1, y1, x2, y2, fill=self.ink_color, outline=self.ink_color, width=1)

    def change_canvas_bg(self):
        color = askcolor()[1]
        if color:
            self.canvas_bg = color
            self.canvas.config(bg=self.canvas_bg)

    def change_ink_color(self):
        color = askcolor()[1]
        if color:
            self.ink_color = color

    def clear_canvas(self):
        self.canvas.delete("all")

    def resize_window(self):
        new_width = tk.simpledialog.askinteger("Width", "Enter new width:", initialvalue=self.width)
        new_height = tk.simpledialog.askinteger("Height", "Enter new height:", initialvalue=self.height)
        if new_width and new_height:
            self.width, self.height = new_width, new_height
            self.canvas.config(width=self.width, height=self.height)

    def save_canvas(self):
        # Specify the full path where 'canvas.ps' will be saved
        ps_file_path = "D:\\learn\\canvas.ps"
        
        # Save the canvas as a PostScript file
        self.canvas.postscript(file=ps_file_path, colormode='color')
        
        # Open the saved PostScript file and convert it to an image
        img = Image.open(ps_file_path)
        img.save("canvas.png", "png")


if __name__ == "__main__":
    import tkinter.simpledialog  # Importing here to avoid error if not used elsewhere
    root = tk.Tk()
    app = DigitalInkApp(root)
    root.mainloop()


----- Content of charSF3.py -----
import os
import re

def extract_characters_from_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        return re.findall(r'\bU\+[0-9A-F]{4,5}\b', file.read())

def write_characters_to_file(characters, output_file_path):
    with open(output_file_path, 'w', encoding='utf-8') as file:
        for char in characters:
            file.write(chr(int(char[2:], 16)) + '\n')

def main():
    directory = '.'  # Specify the directory where your files are located
    output_file_path = 'charSF3.txt'
    all_characters = set()
    files_to_process = ['Unihan_Readings', 'Unihan_IRGSources', 'Unihan_Variants', 'Unihan_NumericValues', 'Unihan_RadicalStrokeCounts.txt', 'Unihan_DictionaryLikeData']  # Add more file names as needed ...

    for filename in os.listdir(directory):
        for file_prefix in files_to_process:
            if filename.startswith(file_prefix) and filename.endswith('.txt'):
                file_path = os.path.join(directory, filename)
                characters = extract_characters_from_file(file_path)
                all_characters.update(characters)

    write_characters_to_file(all_characters, output_file_path)
    print("Characters extracted and saved to", output_file_path)

if __name__ == "__main__":
    main()


----- Content of CMD-Terminal.py -----
import tkinter as tk
from tkinter import scrolledtext
import subprocess

class CustomTerminal(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Python Terminal")
        self.geometry("800x600")

        self.text_widget = scrolledtext.ScrolledText(self, wrap='word', height=30, width=80)
        self.text_widget.pack()

        self.command_entry = tk.Entry(self, width=80)
        self.command_entry.pack()
        self.command_entry.bind('<Return>', self.execute_command)

    def execute_command(self, event):
        command = self.command_entry.get()
        self.command_entry.delete(0, tk.END)
        self.text_widget.insert(tk.END, f'> {command}\n')

        # Specify that stdin is also a pipe, so we can write to it
        process = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Assuming some_input is the input you want to provide to the executable
        some_input = "your_input_here\n"
        process.stdin.write(some_input)
        process.stdin.flush()  # Ensure the input is sent to the subprocess

        stdout, stderr = process.communicate()
        self.text_widget.insert(tk.END, stdout + stderr)

if __name__ == "__main__":
    terminal = CustomTerminal()
    terminal.mainloop()


----- Content of ComputationalChemistry.py -----
import tkinter as tk
from tkinter import ttk

print("Photosynthesis: Time = 30 minutes\nCellular Respiration: Time = 45 minutes\nCombustion of Methane: Time = 5 minutes\nHydrolysis of Sodium Chloride (Salt): Time = 15 minutes\nFermentation of Glucose: Time = 60 minutes\nOxidation of Iron (Rust Formation): Time = 120 minutes\nNeutralization of Hydrochloric Acid with Sodium Hydroxide: Time = 10 minutes\nPolymerization of Ethylene (Plastic Formation): Time = 90 minutes\nDecomposition of Hydrogen Peroxide: Time = 20 minutes\nPrecipitation of Barium Sulfate: Time = 25 minutes\nPhotosensitive Reaction in Photography: Time = 180 minutes\nEsterification Reaction (Production of Esters): Time = 75 minutes")

def create_table(op_type, n, reaction_time1, reaction_time2):
    for widget in table_frame.winfo_children():
        widget.destroy()

    for i in range(n+1):
        for j in range(n+1):
            if i == 0 and j == 0:
                text = f"ReactionTime1\nReactionTime2"
            elif i == 0:
                text = f"{j-1}"
            elif j == 0:
                text = f"{i-1}"
            else:
                if op_type == "Addition":
                    result = (i-1 + j-1) % n
                elif op_type == "Multiplication":
                    result = (i-1) * (j-1) % n
                text = f"{result} (Least Residue)"

            label = tk.Label(table_frame, text=text, width=15, height=2, borderwidth=1, relief="solid")
            label.grid(row=i, column=j)

    # Display the result for the input reaction times
    if op_type == "Addition":
        result_text = f"({reaction_time1} + {reaction_time2}) mod {n} = {(reaction_time1 + reaction_time2) % n} (Least Residue)"
    elif op_type == "Multiplication":
        result_text = f"({reaction_time1} * {reaction_time2}) mod {n} = {(reaction_time1 * reaction_time2) % n} (Least Residue)"
    result_label.config(text=result_text)

root = tk.Tk()
root.title("Modular Arithmetic Table - Computational Biology")

# ... (Rest of the script remains the same)


# ... (Rest of the script remains the same)


control_frame = tk.Frame(root)
control_frame.pack(side=tk.TOP, padx=10, pady=10)

table_frame = tk.Frame(root)
table_frame.pack(side=tk.BOTTOM, padx=10, pady=10)

operation_label = tk.Label(control_frame, text="Operation:")
operation_label.pack(side=tk.LEFT)

operation_combobox = ttk.Combobox(control_frame, values=["Addition", "Multiplication"], state="readonly")
operation_combobox.pack(side=tk.LEFT)
operation_combobox.current(0)

n_label = tk.Label(control_frame, text="Modulo (n  12):")
n_label.pack(side=tk.LEFT)

n_entry = tk.Entry(control_frame, width=5)
n_entry.pack(side=tk.LEFT)
n_entry.insert(0, "3")

rt1_label = tk.Label(control_frame, text="Reaction Time 1:")
rt1_label.pack(side=tk.LEFT)

rt1_entry = tk.Entry(control_frame, width=5)
rt1_entry.pack(side=tk.LEFT)
rt1_entry.insert(0, "1")

rt2_label = tk.Label(control_frame, text="Reaction Time 2:")
rt2_label.pack(side=tk.LEFT)

rt2_entry = tk.Entry(control_frame, width=5)
rt2_entry.pack(side=tk.LEFT)
rt2_entry.insert(0, "1")

result_label = tk.Label(root, text="")
result_label.pack(side=tk.TOP, pady=5)

def update_table():
    op_type = operation_combobox.get()
    n = int(n_entry.get())
    reaction_time1 = int(rt1_entry.get())
    reaction_time2 = int(rt2_entry.get())
    create_table(op_type, n, reaction_time1, reaction_time2)

update_button = tk.Button(control_frame, text="Update Table", command=update_table)
update_button.pack(side=tk.LEFT)

update_table()

root.mainloop()


----- Content of Comsz_Engine.cpp -----
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <stdlib.h>
#include "database.h"

using namespace std;

map<string, string> database;

// Function to add a new record to the database
void addRecord(string key, string value)
{
    cout << "Adding record..." << endl;
    database[key] = value;
    cout << "Record added successfully!" << endl;
}

// Function to delete a record from the database
void deleteRecord(string key)
{
    cout << "Deleting record..." << endl;
    database.erase(key);
    cout << "Record deleted successfully!" << endl;
}

// Function to search for a record in the database
void searchRecord(string key)
{
    cout << "Searching record..." << endl;
    if (database.find(key) != database.end())
    {
        cout << "Record found!" << endl;
        cout << "Value: " << database[key] << endl;
    }
    else
    {
        cout << "Record not found!" << endl;
    }
}

// Function to update a record in the database
void updateRecord(string key, string value)
{
    cout << "Updating record..." << endl;
    if (database.find(key) != database.end())
    {
        database[key] = value;
        cout << "Record updated successfully!" << endl;
    }
    else
    {
        cout << "Record not found!" << endl;
    }
}

// Function to print all records in the database
void printAllRecords()
{
    cout << "Printing all records..." << endl;
    for (auto& record : database)
    {
        cout << record.first << ": " << record.second << endl;
    }
}

// Function to save the database to a file
void saveDatabase()
{
    ofstream file("database.txt");
    for (auto& record : database)
    {
        file << record.first << "," << record.second << endl;
    }
    file.close();
}

// Function to load the database from a file
void loadDatabase()
{
    ifstream file("database.txt");
    string line;
    while (getline(file, line))
    {
        stringstream sstream(line);
        string key, value;
        getline(sstream, key, ',');
        getline(sstream, value, ',');
        database[key] = value;
    }
    file.close();
}

int main()
{
    // Load the database from the file
    
    loadDatabase();
    int mode;
    
    int xin;
    cout << "\n\nContinue? 1 for yes, 0 for no: ";
    cin >> xin;
    while (xin == 1) {
        cout << "\n\nEnter mode: \n1 (Add record)\n2 (Search for record)\n3 (Update existing record)\n4 (Delete a record)\n5 (Print all records)\n6 (Save the database to file (database.txt))] --> ";
        cin >> mode;
        if (mode == 1) {
            // Add a new record
            string jhin, valued;
            cout << "\nEnter entry ID: ";
            cin >> jhin;

            cout << "\nEnter entry value: ";
            cin >> valued;

            addRecord(jhin, valued);
            
        }
        else if (mode == 2) {
            // Search for a record
            string mode2;
            cout << "\nEnter record ID: ";
            cin >> mode2;
            searchRecord(mode2);
        }
        else if (mode == 3) {
            // Update an existing record
            string mode3a, mode3b;
            cout << "\nEnter record ID: ";
            cin >> mode3a;
            cout << "\nEnter new record value: ";
            cin >> mode3b;
            updateRecord(mode3a, mode3b);
        }
        else if (mode == 4) {
            // Delete a record
            string mode4;
            cout << "\nEnter record ID to be deleted: ";
            cin >> mode4;
            deleteRecord(mode4);
        }
        else if (mode == 5) {
            // Print all records
            printAllRecords();
        }
        else {
            // Save the database to the file
            saveDatabase();
        }
        cout << "\n\nContinue? 1 for yes, 0 for no: ";
        cin >> xin;
    }
    
    system("Comsz_OperatingSystem.exe");

    return 0;
  
    
}


----- Content of Comsz_OperatingSystem.c -----
//Written with the aid of Chat GPT-3
//include necessary libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char input[100]; //stores the user input
    char command[100]; //stores the command
    char argument[100]; //stores the argument
    int quit = 0; //boolean for exiting the system

    printf("Welcome to my simple text-based operating system!\n");
    printf("Type 'help' for a list of commands\n");

    //run the system until the user quits
    while(quit != 1)
    {
        //get user input
        printf("\n>");
        fgets(input, sizeof(input), stdin);
        sscanf(input, "%s %s", command, argument); //separate the command and argument

        //execute the command
        if (strcmp(command, "help") == 0)
        {
            printf("Available commands:\n");
            printf("help: Prints a list of available commands\n");
            printf("echo: Prints the given argument\n");
            printf("startd: runs file of the given filename/ argument.\n");
            printf("quit: Quits the system\n");
        }
        else if (strcmp(command, "echo") == 0)
        {
            printf("%s\n", argument);
        }
        else if (strcmp(command, "quit") == 0)
        {
            printf("Goodbye!\n");
            quit = 1;
        }
        else if(strcmp(command, "startd") == 0){
        	system(argument);
		}
        else
        {
            printf("Invalid command.\n");
        }
    }

    return 0;
}


----- Content of ConsolePrint.cpp -----
#include <iostream>
#include <fstream>
#include <string>

int main() {
    std::string filename;
    std::cout << "Enter the filename: ";
    std::getline(std::cin, filename);

    std::ifstream inputFile(filename);
    if (!inputFile.is_open()) {
        std::cerr << "Error: unable to open file \"" << filename << "\"\n";
        return 1;
    }

    std::string line;
    int lineNumber = 1;
    while (std::getline(inputFile, line)) {
        std::cout << lineNumber << ": " << line << std::endl;
        ++lineNumber;
    }

    inputFile.close();
    return 0;
}


----- Content of Control.py -----
import pygame
import importlib
import requests
import os
import subprocess
import webbrowser
import csv
from bs4 import BeautifulSoup
import datetime
import sys
import math
import random
import json
import re

####import pywebbrowser
#create a custom event type
MY_CUSTOM_EVENT = pygame.USEREVENT + 1

# Initialize pygame
pygame.init()

# Initialize joystick module
pygame.joystick.init()

# Check if any joysticks are connected
if pygame.joystick.get_count() > 0:
    # Get the first joystick
    joystick = pygame.joystick.Joystick(0)
    # Initialize the joystick
    joystick.init()

# Set screen size
#enter = int(input("Enter the dimension --> options 422, and multiples of 422"))
enter = 422
screen_width = enter
screen_height = enter


bls = 52
screen = pygame.display.set_mode((screen_width, screen_height))
#screen = pygame.display.set_mode((screen_width, screen_height), pygame.RESIZABLE)
##################

#Create Commands
bus_ = 255
amount_ = (bus_ + 1) * (bus_ + 1)
line_number_ = 0
            
create_f = open("Command_Template.txt", "w")
while(line_number_ < amount_):
    #i = log10(line_number)
    create_f.write("print(\"[Empty Command Slot] (Change using a text-editor to Update this slot in Command_Template.txt\") #remembering to rename Command_Template.txt\n")
    line_number_ = line_number_ + 1

create_f.close()

#LoadCommands
xin = 0
filnam = "Command_Template.txt"
with open(filnam, 'r') as file:
    commands = file.readlines()
    xin = xin + 1


star = [0]

for i, command in enumerate(commands):
    commands[i] = command.strip()
    #cmd = command.split(",")
    star.append(command)
del star[0]

###################

##################

#LoadCoordinates
xin2 = 0
with open('Coordinates_Python.txt', 'r') as file2:
    commands2 = file2.readlines()
    xin2 = xin2 + 1


starsx = [0]
starsy = [0]

for i2, command2 in enumerate(commands2):
    commands2[i2] = command2.strip()
    cmd2 = command2.split(",")
    starsx.append(int(cmd2[1]))
    varys = int(cmd2[2].strip())
    starsy.append(varys)
    
del starsx[0]
del starsy[0]

"""
for i3, commandy in starsy:
    new = starsy[i3].strip()
    starsy[i3] = int(new)
"""

print(starsx)
print(starsy)
###################


# Load images
block_images = []
for i in range(256):
    block_images.append(pygame.image.load(f"block{i}.png"))


# Maze layout
maze_layout = [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
    [12, 13, 14, 15]
]


#Function to check if a position is inside the maze
def is_inside_maze(x, y, maze_width, maze_height, bls):
    return 0 <= x < maze_width * bls and 0 <= y < maze_height * bls

# Load player images
player_image = pygame.image.load("player.png")
player_image2 = pygame.image.load("player2.png")

#scaled_block_images = [pygame.transform.scale(img, (int(img.get_width() * scale_factor), int(img.get_height() * scale_factor))) for img in block_images]
#scaled_player_image = pygame.transform.scale(player_image, (int(player_image.get_width() * scale_factor), int(player_image.get_height() * scale_factor)))


# Set player position
player_x = 0
player_y = 0
con_program = int(input("Continue? 1 [yes], 0 [no]: "))
if(con_program == 1):
    print("Ok ...")
if(con_program == 0):
    print("Exiting ...")
    exit()
if(con_program != 0 and con_program != 1):
    print("Error")
    exit()
# Set initial input type
typei = "k"
print("Switch Command Matrix [s],\n mouse [m],\nkeyboard arrows [k],\nD-Pad (Xbox One Controller) [d]\nPress [SPACEBAR] to call a command from Commands_Template.txt (Commands can be changed using a text-editor)  ... ")

# some input variable
input_variable = 0
# add the custom event to the event queue
pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": input_variable}))
#etch loop
etch = 0

#maze width
maze_width = 16
maze_height = 16
# Main game loop
running = True
#new screen size settings
##screen_width, screen_height = pygame.display.get_surface().get_size()
scale_factor_x = screen_width / maze_width
#scale_factor_y = screen_height / maze_height
#scale_factor = min(scale_factor_x, scale_factor_y)
scale_factor = scale_factor_x

bls = int(bls * 0.5)

scaled_block_images = []
for ni in range(256):
    s_i = pygame.transform.scale(block_images[ni], (bls, bls))
    block_images[ni] = s_i

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
############
        elif event.type == pygame.KEYDOWN:
            # Check for key press event
            if event.key == pygame.K_m and typei != "m":
                # Update input type
                typei = "m"
            elif event.key == pygame.K_k and typei != "k":
                # Update input type
                typei = "k"
            elif event.key == pygame.K_s and typei != "s":
                # Update input type
                typei = "s"
            elif event.key == pygame.K_d and typei != "d":
                # Update input type
                typei = "d"
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    #update input_type
                    typei = "n"
                    #check for status
                    enter_cma = int(input("Enter command? 1[yes], 0 [no]: "))
                    """
                    # user input variable
                    if(enter_cma == 0):
                        typei = "k"
                        player_x = 0
                        player_y = 0
                        etch = 1
                    """
                    if(enter_cma == 0):
                        typei = "k"
                        player_x = 0
                        player_y = 0
                    if(enter_cma == 1):
                        input_variable = int(input("Enter command number ID (0 to 65535): "))
                    # add the custom event to the event queue
                    pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": input_variable}))
                    #pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": cma}))
            '''
            elif event.type == pygame.MOUSEBUTTONUP:
                # Get mouse position
                mouse_x, mouse_y = pygame.mouse.get_pos()

                # Check if the clicked position is inside the maze
                if is_inside_maze(mouse_x, mouse_y, len(maze_layout[0]), len(maze_layout), bls):
                    # Calculate the clicked cell
                    cell_x = mouse_x // bls
                    cell_y = mouse_y // bls

                    # Execute the desired action (e.g., print a message with the image ID)
                    print(f"Hello, world! Image ID: {maze_layout[cell_y][cell_x]}")
            '''
     
        # check for custom event type
        for event in pygame.event.get(MY_CUSTOM_EVENT):
            # access the input variable from the event object
            cma = event.input_variable
            # do something with the input variable
            #pass...
            if(typei == 'n'):
                
                #enter_cma = int(input("Enter command? 1[yes], 0 [no]: "))
                if(enter_cma == 1 and enter_cma != 0):
                    player_x = 0
                    player_y = 0
                    
                    # Clear screen
                    screen.fill((255, 255, 255))
                    # Update display
                    #pygame.display.update()
                    
                    #cma = int(input("Enter command number ID (0 to 65535): "))
                    try:
                        exec(star[cma], globals())
                    except:
                        print("Try again, there was an error")
                    #update command index pointer
                    bus = 255 + 1
                    if(cma <= 255):
                        cmd_index = 0
                        command_point = cma
                    elif(cma > 255):
                        cmd_index = cma//bus
                        command_point = cma
                        for tip in range(0, cmd_index):
                            command_point = command_point - (bus)
                    #print(command_point)

                    prompt = "Executing Command " + str(cma) + " from index: " + str(cmd_index)
                    print(prompt)
                    #print(starsx)
                    
                    player_x = starsy[cmd_index]
                    player_y = starsx[cmd_index]
                    command_point_x = starsy[command_point]
                    command_point_y = starsx[command_point]
                    
   

                    # Render player image at new position --> screen.blit(player_image, (player_x, player_y))

                    ####################

     

                    # Draw blocks
                    for y in range(int(screen_height/bls)):
                        for x in range(int(screen_width /bls)):
                            relative_x = x - player_x
                            relative_y = y - player_y
                            screen.blit(block_images[relative_x + relative_y * int(screen_width/bls)], (x * bls, y * bls))
                            #screen.blit(scaled_block_images[relative_x + relative_y * int(screen_width // (bls * scale_factor))], (x * bls * scale_factor, y * bls * scale_factor))

                    if(typei == 'n'):
                        #Draw2 player
                        screen.blit(player_image2, (player_x * bls, player_y * bls))
                        #Draw Command pointer
                        screen.blit(player_image, (command_point_x * bls, command_point_y * bls))
                        #screen.blit(scaled_player_image, (player_x * bls * scale_factor, player_y * bls * scale_factor))

                    # Update display
                    pygame.display.update()
                    
                    #cma = int(input("Enter command number ID (0 to 65535): "))
                    
                    ####################
                
        if(typei == 'd'):
            # Check for Xbox controller input
            if pygame.joystick.get_count() > 0:
                joystick = pygame.joystick.Joystick(0)
                joystick.init()
                # Check for D-Pad input
                dpad = joystick.get_hat(0)
                if dpad == (1, 0):
                    player_x += 1
                elif dpad == (-1, 0):
                    player_x -= 1
                elif dpad == (0, 1):
                    player_y -= 1
                elif dpad == (0, -1):
                    player_y += 1
                if player_x < 0:
                    player_x = 0
                if player_x >= int(screen_width / bls):
                    player_x = int(screen_width / bls) - 1
                if player_y < 0:
                    player_y = 0
                if player_y >= int(screen_height / bls):
                    player_y = int(screen_height / bls) - 1



        if(typei == 's'):
            
            ##################

            #LoadCommands
            xin = 0
            filnam = input("Enter name of Command Matrix file, 'filename.txt': ")
            quet = int(input("Enter 1 if file already exists [Read mode], Else Enter 2 [Write mode], choose carefully: "))
            
            bus = 255
            amount = (bus + 1) * (bus + 1)
            line_number = 0
            #ai = log10(amount)
            if(quet == 2):
                create_f = open(filnam, "w")
                while(line_number < amount):
                    #i = log10(line_number)
                    create_f.write("print(\"[Empty Command Slot] Change using a text-editor to Update this slot in Command_Template.txt after renaming it accordingly.\")\n")
                    line_number = line_number + 1

                create_f.close()
            
            with open(filnam, 'r') as file:
                commands = file.readlines()
                xin = xin + 1

            star = [0]

            for i, command in enumerate(commands):
                commands[i] = command.strip()
                #cmd = command.split(",")
                star.append(command)
            del star[0]
            
            #reset state of matrix
            typei = "k"
            player_x = 0
            player_y = 0
        
        if(typei == 'k'):
            # Get user keyboard input
            keys = pygame.key.get_pressed()

            # Update move flag based on keyboard input
            if keys[pygame.K_LEFT] or keys[pygame.K_RIGHT] or keys[pygame.K_UP] or keys[pygame.K_DOWN]:
                move = True
            else:
                move = False

            # Update player position based on keyboard input
            if(move):
                if keys[pygame.K_LEFT]:
                    player_x -= 1
                if keys[pygame.K_RIGHT]:
                    player_x += 1
                if keys[pygame.K_UP]:
                    player_y -= 1
                if keys[pygame.K_DOWN]:
                    player_y += 1
                if player_x < 0:
                    player_x = 0
                if player_x >= int(screen_width / bls):
                    player_x = int(screen_width / bls) - 1
                if player_y < 0:
                    player_y = 0
                if player_y >= int(screen_height / bls):
                    player_y = int(screen_height / bls) - 1
                
        if(typei == 'm'):
            # Get mouse position
            mouse_x, mouse_y = pygame.mouse.get_pos()

            # Update player position based on mouse position
            player_x = mouse_x // bls
            player_y = mouse_y // bls

    
    # Clear screen
    screen.fill((255, 255, 255))

    
    
    # Draw blocks
    if(typei == 'k' or typei == 'm' or typei == 'd'):
        for y in range(int(screen_height/bls)):
            for x in range(int(screen_width/bls)):
                relative_x = x - player_x
                relative_y = y - player_y
                screen.blit(block_images[relative_x + relative_y * int(screen_width // (bls))], (x * bls, y * bls))
        if(typei == 'k' or typei == 'm' or typei == 'd'):
            screen.blit(player_image, (player_x * bls, player_y * bls))


    if(typei == 'k' or typei == 'm' or typei == 'd'):
        # Update display
        pygame.display.update()
    

# Quit pygame
pygame.quit()


----- Content of Controller30IDE.py -----
import pygame
import importlib
import requests
import os
import subprocess
import webbrowser
import csv
from bs4 import BeautifulSoup
import datetime
import sys
import math
import random
import json
import re

####import pywebbrowser
#create a custom event type
MY_CUSTOM_EVENT = pygame.USEREVENT + 1

# Initialize pygame
pygame.init()

# Initialize joystick module
pygame.joystick.init()

# Check if any joysticks are connected
if pygame.joystick.get_count() > 0:
    # Get the first joystick
    joystick = pygame.joystick.Joystick(0)
    # Initialize the joystick
    joystick.init()

# Set screen size
#enter = int(input("Enter the dimension --> options 422, and multiples of 422"))
enter = 422
screen_width = enter
screen_height = enter


bls = 52
screen = pygame.display.set_mode((screen_width, screen_height))
#screen = pygame.display.set_mode((screen_width, screen_height), pygame.RESIZABLE)
##################

#Create Commands
bus_ = 255
amount_ = (bus_ + 1) * (bus_ + 1)
line_number_ = 0
            
create_f = open("Command_Template.txt", "w")
while(line_number_ < amount_):
    #i = log10(line_number)
    create_f.write("print(\"[Empty Command Slot] (Change using a text-editor to Update this slot in Command_Template.txt\") #remembering to rename Command_Template.txt\n")
    line_number_ = line_number_ + 1

create_f.close()

#LoadCommands
xin = 0
filnam = "Command_Template.txt"
with open(filnam, 'r') as file:
    commands = file.readlines()
    xin = xin + 1


star = [0]

for i, command in enumerate(commands):
    commands[i] = command.strip()
    #cmd = command.split(",")
    star.append(command)
del star[0]

###################

##################

#LoadCoordinates
xin2 = 0
with open('Coordinates_Python.txt', 'r') as file2:
    commands2 = file2.readlines()
    xin2 = xin2 + 1


starsx = [0]
starsy = [0]

for i2, command2 in enumerate(commands2):
    commands2[i2] = command2.strip()
    cmd2 = command2.split(",")
    starsx.append(int(cmd2[1]))
    varys = int(cmd2[2].strip())
    starsy.append(varys)
    
del starsx[0]
del starsy[0]

"""
for i3, commandy in starsy:
    new = starsy[i3].strip()
    starsy[i3] = int(new)
"""

print(starsx)
print(starsy)
###################


# Load images
block_images = []
for i in range(256):
    block_images.append(pygame.image.load(f"block{i}.png"))


# Maze layout
maze_layout = [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
    [12, 13, 14, 15]
]


#Function to check if a position is inside the maze
def is_inside_maze(x, y, maze_width, maze_height, bls):
    return 0 <= x < maze_width * bls and 0 <= y < maze_height * bls

# Load player images
player_image = pygame.image.load("player.png")
player_image2 = pygame.image.load("player2.png")

#scaled_block_images = [pygame.transform.scale(img, (int(img.get_width() * scale_factor), int(img.get_height() * scale_factor))) for img in block_images]
#scaled_player_image = pygame.transform.scale(player_image, (int(player_image.get_width() * scale_factor), int(player_image.get_height() * scale_factor)))


# Set player position
player_x = 0
player_y = 0
con_program = int(input("Continue? 1 [yes], 0 [no]: "))
if(con_program == 1):
    print("Ok ...")
if(con_program == 0):
    print("Exiting ...")
    exit()
if(con_program != 0 and con_program != 1):
    print("Error")
    exit()
# Set initial input type
typei = "k"
print("Switch Command Matrix [s],\n mouse [m],\nkeyboard arrows [k],\nD-Pad (Xbox One Controller) [d]\nPress [SPACEBAR] to call a command from Commands_Template.txt (Commands can be changed using a text-editor)  ... ")

# some input variable
input_variable = 0
# add the custom event to the event queue
pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": input_variable}))
#etch loop
etch = 0

#maze width
maze_width = 16
maze_height = 16
# Main game loop
running = True
#new screen size settings
##screen_width, screen_height = pygame.display.get_surface().get_size()
scale_factor_x = screen_width / maze_width
#scale_factor_y = screen_height / maze_height
#scale_factor = min(scale_factor_x, scale_factor_y)
scale_factor = scale_factor_x

bls = int(bls * 0.5)

scaled_block_images = []
for ni in range(256):
    s_i = pygame.transform.scale(block_images[ni], (bls, bls))
    block_images[ni] = s_i

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
############
        elif event.type == pygame.KEYDOWN:
            # Check for key press event
            if event.key == pygame.K_m and typei != "m":
                # Update input type
                typei = "m"
            elif event.key == pygame.K_k and typei != "k":
                # Update input type
                typei = "k"
            elif event.key == pygame.K_s and typei != "s":
                # Update input type
                typei = "s"
            elif event.key == pygame.K_d and typei != "d":
                # Update input type
                typei = "d"
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    #update input_type
                    typei = "n"
                    #check for status
                    enter_cma = int(input("Enter command? 1[yes], 0 [no]: "))
                    """
                    # user input variable
                    if(enter_cma == 0):
                        typei = "k"
                        player_x = 0
                        player_y = 0
                        etch = 1
                    """
                    if(enter_cma == 0):
                        typei = "k"
                        player_x = 0
                        player_y = 0
                    if(enter_cma == 1):
                        input_variable = int(input("Enter command number ID (0 to 65535): "))
                    # add the custom event to the event queue
                    pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": input_variable}))
                    #pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": cma}))
            '''
            elif event.type == pygame.MOUSEBUTTONUP:
                # Get mouse position
                mouse_x, mouse_y = pygame.mouse.get_pos()

                # Check if the clicked position is inside the maze
                if is_inside_maze(mouse_x, mouse_y, len(maze_layout[0]), len(maze_layout), bls):
                    # Calculate the clicked cell
                    cell_x = mouse_x // bls
                    cell_y = mouse_y // bls

                    # Execute the desired action (e.g., print a message with the image ID)
                    print(f"Hello, world! Image ID: {maze_layout[cell_y][cell_x]}")
            '''
     
        # check for custom event type
        for event in pygame.event.get(MY_CUSTOM_EVENT):
            # access the input variable from the event object
            cma = event.input_variable
            # do something with the input variable
            #pass...
            if(typei == 'n'):
                
                #enter_cma = int(input("Enter command? 1[yes], 0 [no]: "))
                if(enter_cma == 1 and enter_cma != 0):
                    player_x = 0
                    player_y = 0
                    
                    # Clear screen
                    screen.fill((255, 255, 255))
                    # Update display
                    #pygame.display.update()
                    
                    #cma = int(input("Enter command number ID (0 to 65535): "))
                    try:
                        exec(star[cma], globals())
                    except:
                        print("Try again, there was an error")
                    #update command index pointer
                    bus = 255 + 1
                    if(cma <= 255):
                        cmd_index = 0
                        command_point = cma
                    elif(cma > 255):
                        cmd_index = cma//bus
                        command_point = cma
                        for tip in range(0, cmd_index):
                            command_point = command_point - (bus)
                    #print(command_point)

                    prompt = "Executing Command " + str(cma) + " from index: " + str(cmd_index)
                    print(prompt)
                    #print(starsx)
                    
                    player_x = starsy[cmd_index]
                    player_y = starsx[cmd_index]
                    command_point_x = starsy[command_point]
                    command_point_y = starsx[command_point]
                    
   

                    # Render player image at new position --> screen.blit(player_image, (player_x, player_y))

                    ####################

     

                    # Draw blocks
                    for y in range(int(screen_height/bls)):
                        for x in range(int(screen_width /bls)):
                            relative_x = x - player_x
                            relative_y = y - player_y
                            screen.blit(block_images[relative_x + relative_y * int(screen_width/bls)], (x * bls, y * bls))
                            #screen.blit(scaled_block_images[relative_x + relative_y * int(screen_width // (bls * scale_factor))], (x * bls * scale_factor, y * bls * scale_factor))

                    if(typei == 'n'):
                        #Draw2 player
                        screen.blit(player_image2, (player_x * bls, player_y * bls))
                        #Draw Command pointer
                        screen.blit(player_image, (command_point_x * bls, command_point_y * bls))
                        #screen.blit(scaled_player_image, (player_x * bls * scale_factor, player_y * bls * scale_factor))

                    # Update display
                    pygame.display.update()
                    
                    #cma = int(input("Enter command number ID (0 to 65535): "))
                    
                    ####################
                
        if(typei == 'd'):
            # Check for Xbox controller input
            if pygame.joystick.get_count() > 0:
                joystick = pygame.joystick.Joystick(0)
                joystick.init()
                # Check for D-Pad input
                dpad = joystick.get_hat(0)
                if dpad == (1, 0):
                    player_x += 1
                elif dpad == (-1, 0):
                    player_x -= 1
                elif dpad == (0, 1):
                    player_y -= 1
                elif dpad == (0, -1):
                    player_y += 1
                if player_x < 0:
                    player_x = 0
                if player_x >= int(screen_width / bls):
                    player_x = int(screen_width / bls) - 1
                if player_y < 0:
                    player_y = 0
                if player_y >= int(screen_height / bls):
                    player_y = int(screen_height / bls) - 1



        if(typei == 's'):
            
            ##################

            #LoadCommands
            xin = 0
            filnam = input("Enter name of Command Matrix file, 'filename.txt': ")
            quet = int(input("Enter 1 if file already exists [Read mode], Else Enter 2 [Write mode], choose carefully: "))
            
            bus = 255
            amount = (bus + 1) * (bus + 1)
            line_number = 0
            #ai = log10(amount)
            if(quet == 2):
                create_f = open(filnam, "w")
                while(line_number < amount):
                    #i = log10(line_number)
                    create_f.write("print(\"[Empty Command Slot] Change using a text-editor to Update this slot in Command_Template.txt after renaming it accordingly.\")\n")
                    line_number = line_number + 1

                create_f.close()
            
            with open(filnam, 'r') as file:
                commands = file.readlines()
                xin = xin + 1

            star = [0]

            for i, command in enumerate(commands):
                commands[i] = command.strip()
                #cmd = command.split(",")
                star.append(command)
            del star[0]
            
            #reset state of matrix
            typei = "k"
            player_x = 0
            player_y = 0
        
        if(typei == 'k'):
            # Get user keyboard input
            keys = pygame.key.get_pressed()

            # Update move flag based on keyboard input
            if keys[pygame.K_LEFT] or keys[pygame.K_RIGHT] or keys[pygame.K_UP] or keys[pygame.K_DOWN]:
                move = True
            else:
                move = False

            # Update player position based on keyboard input
            if(move):
                if keys[pygame.K_LEFT]:
                    player_x -= 1
                if keys[pygame.K_RIGHT]:
                    player_x += 1
                if keys[pygame.K_UP]:
                    player_y -= 1
                if keys[pygame.K_DOWN]:
                    player_y += 1
                if player_x < 0:
                    player_x = 0
                if player_x >= int(screen_width / bls):
                    player_x = int(screen_width / bls) - 1
                if player_y < 0:
                    player_y = 0
                if player_y >= int(screen_height / bls):
                    player_y = int(screen_height / bls) - 1
                
        if(typei == 'm'):
            # Get mouse position
            mouse_x, mouse_y = pygame.mouse.get_pos()

            # Update player position based on mouse position
            player_x = mouse_x // bls
            player_y = mouse_y // bls

    
    # Clear screen
    screen.fill((255, 255, 255))

    
    
    # Draw blocks
    if(typei == 'k' or typei == 'm' or typei == 'd'):
        for y in range(int(screen_height/bls)):
            for x in range(int(screen_width/bls)):
                relative_x = x - player_x
                relative_y = y - player_y
                screen.blit(block_images[relative_x + relative_y * int(screen_width // (bls))], (x * bls, y * bls))
        if(typei == 'k' or typei == 'm' or typei == 'd'):
            screen.blit(player_image, (player_x * bls, player_y * bls))


    if(typei == 'k' or typei == 'm' or typei == 'd'):
        # Update display
        pygame.display.update()
    

# Quit pygame
pygame.quit()


----- Content of conv_ps_png2-nlv.py -----
from PIL import Image
nof = input("Input number of files: ")
nof_ = int(nof)
ins_x = input("Enter first file id: ")
x = int(ins_x)
donu = input("Do you have more than one file (y [Yes], n [No]? ")
if(donu == 'y'):
    ins_y = input("Enter last file id: ")
    y = int(ins_y)
ins = input("Enter path of files: ")

#def convert_to_png(path):

if(nof_ > 1):
    for i in range(x,y+1):
        ixy = str(i)
        #pre = input("Enter filename-prefix: ")
        path= ins + "\\" + "Map_" + ixy + ".ps"
        img = Image.open(path)
        img.save("Map_" + ixy + ".png")
if(nof_ == 1):
    #pre = input("Enter filename-prefix: ")
    path = ins + "\\" + "Map_" + ins_x + ".ps"
    img = Image.open(path)
    img.save("Map_" + ins_x + ".png")

#path= ins
#convert_to_png(path)


----- Content of conv_ps_png2.py -----
from PIL import Image
nof = input("Input number of files: ")
nof_ = int(nof)
ins_x = input("Enter first file id: ")
x = int(ins_x)
donu = input("Do you have more than one file (y [Yes], n [No]? ")
if(donu == 'y'):
    ins_y = input("Enter last file id: ")
    y = int(ins_y)
ins = input("Enter path of files: ")

#def convert_to_png(path):

if(nof_ > 1):
    for i in range(x,y+1):
        ixy = str(i)
        #pre = input("Enter filename-prefix: ")
        path= ins + "\\" + "M" + ixy + ".ps"
        img = Image.open(path)
        img.save("M" + ixy + ".png")
if(nof_ == 1):
    #pre = input("Enter filename-prefix: ")
    path = ins + "\\" + "M" + ins_x + ".ps"
    img = Image.open(path)
    img.save("M" + ins_x + ".png")

#path= ins
#convert_to_png(path)


----- Content of conv_ps_png3.py -----
from PIL import Image
nof = input("Input number of files: ")
nof_ = int(nof)
ins_x = input("Enter first file id: ")
x = int(ins_x)
donu = input("Do you have more than one file (y [Yes], n [No]? ")
if(donu == 'y'):
    ins_y = input("Enter last file id: ")
    y = int(ins_y)
ins = input("Enter path of files: ")

#def convert_to_png(path):

if(nof_ > 1):
    for i in range(x,y+1):
        ixy = str(i)
        #pre = input("Enter filename-prefix: ")
        path= ins + "\\" + ixy + ".ps"
        img = Image.open(path)
        img.save(ixy + ".png")
if(nof_ == 1):
    #pre = input("Enter filename-prefix: ")
    path = ins + "\\" + ins_x + ".ps"
    img = Image.open(path)
    img.save(ins_x + ".png")

#path= ins
#convert_to_png(path)


----- Content of cpp.cpp -----
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int main() {
    std::string inputFileName, outputFileName;
    std::vector<std::string> lines;

    // Get input file name from the user
    std::cout << "Enter the input file name: ";
    std::cin >> inputFileName;

    // Get output file name from the user
    std::cout << "Enter the output file name: ";
    std::cin >> outputFileName;

    // Open the input file
    std::ifstream inputFile(inputFileName);
    if (!inputFile) {
        std::cerr << "Error opening input file: " << inputFileName << std::endl;
        return 1;
    }

    // Read the input file and store lines in the vector
    std::string line;
    while (std::getline(inputFile, line)) {
        lines.push_back(line);
    }

    inputFile.close();

    bool continueEditing = true;

    while (continueEditing) {
        // Display the current contents of the file
        std::cout << "Current contents of the file:" << std::endl;
        for (size_t i = 0; i < lines.size(); ++i) {
            std::cout << "[" << i + 1 << "] " << lines[i] << std::endl;
        }

        int choice;
        std::cout << "Choose an option:" << std::endl;
        std::cout << "1. Edit a line" << std::endl;
        std::cout << "2. Delete a line" << std::endl;
        std::cout << "3. Add a line after a specified line" << std::endl;
        std::cout << "4. Exit" << std::endl;
        std::cin >> choice;

        if (choice == 1) {
            int lineToEdit;
            std::string newContent;

            // Get the line number to edit from the user
            std::cout << "Enter the line number to edit (1-based index): ";
            std::cin >> lineToEdit;

            // Make sure the line number is valid
            if (lineToEdit < 1 || lineToEdit > lines.size()) {
                std::cerr << "Invalid line number." << std::endl;
                continue;
            }

            // Display the current content of the line to be edited
            std::cout << "Current content of line " << lineToEdit << ": " << lines[lineToEdit - 1] << std::endl;

            // Get the new content from the user
            std::cin.ignore();  // Clear the newline character from the buffer
            std::cout << "Enter the new content for line " << lineToEdit << ": ";
            std::getline(std::cin, newContent);

            // Modify the specified line with the new content
            lines[lineToEdit - 1] = newContent;

            std::cout << "Line " << lineToEdit << " edited successfully." << std::endl;
        } else if (choice == 2) {
            int lineToDelete;

            // Get the line number to delete from the user
            std::cout << "Enter the line number to delete (1-based index): ";
            std::cin >> lineToDelete;

            // Make sure the line number is valid
            if (lineToDelete < 1 || lineToDelete > lines.size()) {
                std::cerr << "Invalid line number." << std::endl;
                continue;
            }

            // Delete the specified line
            lines.erase(lines.begin() + lineToDelete - 1);

            std::cout << "Line " << lineToDelete << " deleted successfully." << std::endl;
        } else if (choice == 3) {
            int lineToAddAfter;
            std::string newLineContent;

            // Get the line number to add a new line after from the user
            std::cout << "Enter the line number to add a new line after (1-based index): ";
            std::cin >> lineToAddAfter;

            // Make sure the line number is valid
            if (lineToAddAfter < 1 || lineToAddAfter > lines.size()) {
                std::cerr << "Invalid line number." << std::endl;
                continue;
            }

            // Get the new line content from the user
            std::cin.ignore();  // Clear the newline character from the buffer
            std::cout << "Enter the new line content: ";
            std::getline(std::cin, newLineContent);

            // Insert the new line after the specified line
            lines.insert(lines.begin() + lineToAddAfter, newLineContent);

            std::cout << "New line added successfully after line " << lineToAddAfter << "." << std::endl;
        } else if (choice == 4) {
            continueEditing = false;
        } else {
            std::cerr << "Invalid option. Please choose a valid option." << std::endl;
        }
    }

    // Open the output file
    std::ofstream outputFile(outputFileName);
    if (!outputFile) {
        std::cerr << "Error opening output file: " << outputFileName << std::endl;
        return 1;
    }

    // Write the modified content to the output file
    for (const std::string& modifiedLine : lines) {
        outputFile << modifiedLine << "\n";
    }

    outputFile.close();

    std::cout << "File edited and saved successfully." << std::endl;

    return 0;
}


----- Content of CPPDatabase.cpp -----
#include <iostream>
#include <fstream>
#include <set>
#include <string>

int main() {
    std::set<std::string> database;
    std::string filename = "database.txt";
    std::string line;

    // Load existing entries from the file
    std::ifstream infile(filename);
    if (infile.is_open()) {
        while (getline(infile, line)) {
            database.insert(line);
        }
        infile.close();
    }

    // Get new entries from the user
    while (true) {
        std::cout << "Enter a new entry (or '0' to quit): ";
        getline(std::cin, line);

        if (line == "0") {
            break;
        }

        // Check for duplicate entry
        if (database.find(line) != database.end()) {
            std::cout << "Duplicate entry. Entry not added to the database.\n";
        } else {
            // Add new entry to the set and the file
            database.insert(line);
            std::ofstream outfile(filename, std::ios_base::app);
            if (outfile.is_open()) {
                outfile << line << "\n";
                outfile.close();
                std::cout << "Entry added to the database.\n";
            } else {
                std::cout << "Unable to open file for writing.\n";
            }
        }
    }

    return 0;
}


----- Content of cpptoexe.cpp -----
#include <iostream>
#include <cstdlib>
#include <filesystem>

int main() {
    // Get the current working directory
    std::filesystem::path current_path = std::filesystem::current_path();

    // Iterate through each file in the current directory
    for (const auto& entry : std::filesystem::directory_iterator(current_path)) {
        std::filesystem::path file_path = entry.path();
        
        // Check if the file has a .cpp extension
        if (file_path.extension() == ".cpp") {
            std::string compile_command = "g++ " + file_path.string() + " -o " + file_path.stem().string();
            
            // Compile the .cpp file
            std::cout << "Compiling: " << file_path.string() << std::endl;
            std::system(compile_command.c_str());
        }
    }

    return 0;
}


----- Content of CPP_C_Source_Code_Generator.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){ 
	//FILE *p; p = fopen("SOLUTION.c","w"); 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int k, kprompt, fnum;
	k = sizeof(a) - 1;
	int soe = 0;
	puts("Set Of Elements");
	do{
		printf("\n\tElement %d = %c", soe, a[soe]);
		soe++;
	}while(soe <= k);
	printf("\n\tNumber Of Elements = %d", k + 1);
	printf("\n\tK = Number of Elements - 1");
	printf("\n\tTherefore k = %d", k);
	int noc, assert, go;
	printf("\n\tn = Number Of Cells Per File To Be Generated");
	printf("\n\n\t(k+1)^n = Number of Files To Be Generated");
	printf("\n\tEnter 2 = Search For A Specific File\n\tEnter 1 = Generate Files\n\tEnter 0 = Abort\n\n\t"); scanf("%d", &go);
	if(go == 1){
		assert = 2;
	}else if(go == 2){
		assert = 1;
	}else if(go == 0){
		assert = 0;
	}else
		assert = 3;
	//Get Files From Database and save to directory
	if(assert == 2){
		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc); printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int n = noc; int row, col; int cell; int rdiv; unsigned long long id; id = 0; 
		int nbr_comb = pow(k+1, n);
		for (row=0; row < nbr_comb; row++){
			char filename[500];
			sprintf(filename, "%dC%d.c",n,id);
			//FILE *p; p = fopen("SOLUTION.txt","w");
			FILE *p; p = fopen(filename,"w");
			id++; 
			//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
			for (col=n-1; col>=0; col--){
				rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
			}
			
			//if(id == nbr_comb){
			//	fprintf(p,"\n\n\t(k+1)^n = (%d + 1)^%d = %d", k, n, id);
			//}
			
			fclose(p);
			printf("\n");	
		}
	}
	//Get One Specific File From Database and save to active Directory
	if(assert == 1){

		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc);
		int n = noc;
		int nbr_comb = pow(k+1, n);
		printf("\n\n\tPlease Enter file number wanted between 0 and %d Inclusively:\t", nbr_comb-1);
		scanf("%d", &fnum);
		printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int row, col; int cell; int rdiv; unsigned long long id; id = fnum; 
		
		int sw = 1;
		for (row=0; row < nbr_comb; row++){
			if(row == fnum){
				char filename[500];
				sprintf(filename, "DQUERY%dC%d.c",n,id);
				//FILE *p; p = fopen("SOLUTION.txt","w");
				FILE *p; p = fopen(filename,"w");
				id++;
				//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
				for (col=n-1; col>=0; col--){
					rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				sw = 0;
				}
			if(sw == 0)
				break;
				
			}
				
		}
		
		
	}
	
	
	if(assert == 0 || assert == 3){
		puts("exiting");
	}
	return 0;
} 


----- Content of CPP_Source_Code_Generator.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){ 
	//FILE *p; p = fopen("SOLUTION.c","w"); 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int k, kprompt, fnum;
	k = sizeof(a) - 1;
	int soe = 0;
	puts("Set Of Elements");
	do{
		printf("\n\tElement %d = %c", soe, a[soe]);
		soe++;
	}while(soe <= k);
	printf("\n\tNumber Of Elements = %d", k + 1);
	printf("\n\tK = Number of Elements - 1");
	printf("\n\tTherefore k = %d", k);
	int noc, assert, go;
	printf("\n\tn = Number Of Cells Per File To Be Generated");
	printf("\n\n\t(k+1)^n = Number of Files To Be Generated");
	printf("\n\tEnter 2 = Search For A Specific File\n\tEnter 1 = Generate Files\n\tEnter 0 = Abort\n\n\t"); scanf("%d", &go);
	if(go == 1){
		assert = 2;
	}else if(go == 2){
		assert = 1;
	}else if(go == 0){
		assert = 0;
	}else
		assert = 3;
	//Get Files From Database and save to directory
	if(assert == 2){
		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc); printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int n = noc; int row, col; int cell; int rdiv; unsigned long long id; id = 0; 
		int nbr_comb = pow(k+1, n);
		for (row=0; row < nbr_comb; row++){
			char filename[500];
			sprintf(filename, "%dC%d.cpp",n,id);
			//FILE *p; p = fopen("SOLUTION.txt","w");
			FILE *p; p = fopen(filename,"w");
			id++; 
			//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
			for (col=n-1; col>=0; col--){
				rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
			}
			
			//if(id == nbr_comb){
			//	fprintf(p,"\n\n\t(k+1)^n = (%d + 1)^%d = %d", k, n, id);
			//}
			
			fclose(p);
			printf("\n");	
		}
	}
	//Get One Specific File From Database and save to active Directory
	if(assert == 1){

		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc);
		int n = noc;
		int nbr_comb = pow(k+1, n);
		printf("\n\n\tPlease Enter file number wanted between 0 and %d Inclusively:\t", nbr_comb-1);
		scanf("%d", &fnum);
		printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int row, col; int cell; int rdiv; unsigned long long id; id = fnum; 
		
		int sw = 1;
		for (row=0; row < nbr_comb; row++){
			if(row == fnum){
				char filename[500];
				sprintf(filename, "DQUERY%dC%d.cpp",n,id);
				//FILE *p; p = fopen("SOLUTION.txt","w");
				FILE *p; p = fopen(filename,"w");
				id++;
				//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
				for (col=n-1; col>=0; col--){
					rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				sw = 0;
				}
			if(sw == 0)
				break;
				
			}
				
		}
		
		
	}
	
	
	if(assert == 0 || assert == 3){
		puts("exiting");
	}
	return 0;
} 


----- Content of ctoexe.cpp -----
#include <iostream>
#include <cstdlib>
#include <filesystem>

int main() {
    // Get the current working directory
    std::filesystem::path current_path = std::filesystem::current_path();

    // Iterate through each file in the current directory
    for (const auto& entry : std::filesystem::directory_iterator(current_path)) {
        std::filesystem::path file_path = entry.path();
        
        // Check if the file has a .c extension
        if (file_path.extension() == ".c") {
            std::string compile_command = "gcc " + file_path.string() + " -o " + file_path.stem().string();
            
            // Compile the .c file
            std::cout << "Compiling: " << file_path.string() << std::endl;
            std::system(compile_command.c_str());
        }
    }

    return 0;
}


----- Content of C_CPP_Source_Code_Generator.c -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){ 
	//FILE *p; p = fopen("SOLUTION.c","w"); 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int k, kprompt, fnum;
	k = sizeof(a) - 1;
	int soe = 0;
	puts("Set Of Elements");
	do{
		printf("\n\tElement %d = %c", soe, a[soe]);
		soe++;
	}while(soe <= k);
	printf("\n\tNumber Of Elements = %d", k + 1);
	printf("\n\tK = Number of Elements - 1");
	printf("\n\tTherefore k = %d", k);
	int noc, assert, go;
	printf("\n\tn = Number Of Cells Per File To Be Generated");
	printf("\n\n\t(k+1)^n = Number of Files To Be Generated");
	printf("\n\tEnter 2 = Search For A Specific File\n\tEnter 1 = Generate Files\n\tEnter 0 = Abort\n\n\t"); scanf("%d", &go);
	if(go == 1){
		assert = 2;
	}else if(go == 2){
		assert = 1;
	}else if(go == 0){
		assert = 0;
	}else
		assert = 3;
	//Get Files From Database and save to directory
	if(assert == 2){
		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc); printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int n = noc; int row, col; int cell; int rdiv; int id; id = 0; 
		int nbr_comb = pow(k+1, n);
		for (row=0; row < nbr_comb; row++){
			char filename[500];
			sprintf(filename, "%dC%d.cpp",n,id);
			//FILE *p; p = fopen("SOLUTION.txt","w");
			FILE *p; p = fopen(filename,"w");
			id++; 
			//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
			for (col=n-1; col>=0; col--){
				rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
			}
			
			//if(id == nbr_comb){
			//	fprintf(p,"\n\n\t(k+1)^n = (%d + 1)^%d = %d", k, n, id);
			//}
			
			fclose(p);
			printf("\n");	
		}
	}
	//Get One Specific File From Database and save to active Directory
	if(assert == 1){

		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc);
		int n = noc;
		int nbr_comb = pow(k+1, n);
		printf("\n\n\tPlease Enter file number wanted between 0 and %d Inclusively:\t", nbr_comb-1);
		scanf("%d", &fnum);
		printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int row, col; int cell; int rdiv; int id; id = fnum; 
		
		int sw = 1;
		for (row=0; row < nbr_comb; row++){
			if(row == fnum){
				char filename[500];
				sprintf(filename, "DQUERY%dC%d.cpp",n,id);
				//FILE *p; p = fopen("SOLUTION.txt","w");
				FILE *p; p = fopen(filename,"w");
				id++;
				//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
				for (col=n-1; col>=0; col--){
					rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				sw = 0;
				}
			if(sw == 0)
				break;
				
			}
				
		}
		
		
	}
	
	
	if(assert == 0 || assert == 3){
		puts("exiting");
	}
	return 0;
} 


----- Content of C_Source_Code_Generator.c -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){ 
	//FILE *p; p = fopen("SOLUTION.c","w"); 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int k, kprompt, fnum;
	k = sizeof(a) - 1;
	int soe = 0;
	puts("Set Of Elements");
	do{
		printf("\n\tElement %d = %c", soe, a[soe]);
		soe++;
	}while(soe <= k);
	printf("\n\tNumber Of Elements = %d", k + 1);
	printf("\n\tK = Number of Elements - 1");
	printf("\n\tTherefore k = %d", k);
	int noc, assert, go;
	printf("\n\tn = Number Of Cells Per File To Be Generated");
	printf("\n\n\t(k+1)^n = Number of Files To Be Generated");
	printf("\n\tEnter 2 = Search For A Specific File\n\tEnter 1 = Generate Files\n\tEnter 0 = Abort\n\n\t"); scanf("%d", &go);
	if(go == 1){
		assert = 2;
	}else if(go == 2){
		assert = 1;
	}else if(go == 0){
		assert = 0;
	}else
		assert = 3;
	//Get Files From Database and save to directory
	if(assert == 2){
		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc); printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int n = noc; int row, col; int cell; int rdiv; int id; id = 0; 
		int nbr_comb = pow(k+1, n);
		for (row=0; row < nbr_comb; row++){
			char filename[500];
			sprintf(filename, "%dC%d.c",n,id);
			//FILE *p; p = fopen("SOLUTION.txt","w");
			FILE *p; p = fopen(filename,"w");
			id++; 
			//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
			for (col=n-1; col>=0; col--){
				rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
			}
			
			//if(id == nbr_comb){
			//	fprintf(p,"\n\n\t(k+1)^n = (%d + 1)^%d = %d", k, n, id);
			//}
			
			fclose(p);
			printf("\n");	
		}
	}
	//Get One Specific File From Database and save to active Directory
	if(assert == 1){

		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc);
		int n = noc;
		int nbr_comb = pow(k+1, n);
		printf("\n\n\tPlease Enter file number wanted between 0 and %d Inclusively:\t", nbr_comb-1);
		scanf("%d", &fnum);
		printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int row, col; int cell; int rdiv; int id; id = fnum; 
		
		int sw = 1;
		for (row=0; row < nbr_comb; row++){
			if(row == fnum){
				char filename[500];
				sprintf(filename, "DQUERY%dC%d.c",n,id);
				//FILE *p; p = fopen("SOLUTION.txt","w");
				FILE *p; p = fopen(filename,"w");
				id++;
				//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
				for (col=n-1; col>=0; col--){
					rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				sw = 0;
				}
			if(sw == 0)
				break;
				
			}
				
		}
		
		
	}
	
	
	if(assert == 0 || assert == 3){
		puts("exiting");
	}
	return 0;
} 


----- Content of DaT-hts.cpp -----
//DaT-hts.cpp is an executable suitable for designing, manufacturing, and distributing, hardware, tools and software. That gives 9 workflows.
/*
0	Design and Technology for Hardware, tools, software. The Design, manufacture and distribution of each.
1	Design 'Hardware'
2	Design 'Tool'
3	Design 'Software'
4	Manufacture 'Hardware'
5	Manufacture 'Tool'
6	Manufacture 'Software'
7	Distribute 'Hardware'
8	Distribute 'Tool'
9	Distribute 'Software'
*/

----- Content of database-texed.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	puts("(pt) == Universal Set = Computer");
	puts("(pt)i = sub-set of (pt)");
	puts("(pt)ia = element of sub-set of (pt)");
	puts("ti = ia");
	puts("t = i of (pt)ia ");
	puts("i = a of ((pt)ia)");
	puts("\nProgressive Abstract Numerical Solution");
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("PROGRESSIVE_ANS_px_RENAME.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int a[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999};
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 1000;
	for(pr = 0; pr < pc; pr++){
		printf("%d	%d\n", pr, a[pr]);
	}
	char choice;
	cout << "Enter a to uniquely use the 1 to 1000 identifiers for the Default Library or c to create a custom Library: ";
	cin >> choice;
	
	cout << "Enter the size of your array: ";
	cin >> pin;
		
	int array[pin], inn, position;
	int generate;
	cout << "\nDo you want manually create your array (0) or, do you want to generate your array for a range of numbers (1):	";
	cin >> generate;
	int lbrange;
	int ubrange;
	//int i_lbrange, i_ubrange;
	int r_check;
	r_check = 0;
	
	if(choice == 'c'){
		//cout << "Enter the size of your array: ";
		//cin >> pin;
		//int array[pin], inn, position;
		
	
		
		if(generate == 0){
			cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
			for(inn = 0; inn < pin; inn++){
				cin >> array[inn];
			}
		}
		if(generate == 1){
			cout << "\nEnter the lower inclusive bound of the array range of numbers:	";
			cin >> lbrange;
			//i_lbrange = int(lbrange);
			cout << "\nEnter the upper inclusive bound of the array range of numbers:	";
			cin >> ubrange;
			//i_ubrange = ubrange;
			r_check = lbrange;
			//generate custom array from user input;
			for(inn = 0; inn < pin; inn++){
			//	r_check = r_check + 1;
				array[inn] = r_check;
				printf("\n%d", r_check);
				r_check = r_check + 1;
				if (r_check > ubrange){
					break;
				}
			}
			
		}
//		for(inn = 0; inn < pin; inn++){
//			cin >> array[inn];
//		}
	}
	
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	if(choice == 'c'){
		k = pin - 1;
	}
	if(choice == 'a'){
		k = 1000 - 1;
	}
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	int id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	int ai, ci, switch_c, switch_a;
	
	

	
	if(choice == 'c'){
		
		switch_c = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ci;
		
		for(ci; n < ci + 1; n++){
			
			if(switch_c == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"%d\t", id);
				for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					rin = array[cell];
					if(col == 0){
						fprintf(p,"%d\n", a[rin]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[rin]);
					}
					
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_c = 1;
		}
	}
	int check;
	check = pin - 1000;
	

	
		
	if(choice == 'a' && check == 0){
	
		switch_a = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ai;
	
		for(n; n < ai + 1; n++){
			if(switch_a == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n, id);
				for (col=n-1; col>=0; col--){
					
					rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					//rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[cell]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[cell]);
					}
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_a = 1;
		}
	}
	
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of Data_Strings_Generator.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("SOLUTION_RENAME_MAX.txt","w");
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 100;
	puts("26 = SPACE");
	puts("27 = NEWLINE");
	puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"%d ", (id - 1));
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			fprintf(p,"\n");
			//printf("\n");
		}
	}
	if(cheque == 0){
	for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"%d ", (id - 1));
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				cell = (row/rdiv) % (k+1);
				fprintf(p,"%c", a[cell]);
			}
			fprintf(p,"\n");
			//printf("\n");
		}	
	}
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of documentation-gen.py -----
import os
from fpdf import FPDF

def list_text_files():
    extensions = ['.txt', '.py', '.c', '.cpp', '.rb']
    # Filter files in the current directory based on specified extensions
    return [f for f in os.listdir() if any(f.endswith(ext) for ext in extensions)]

def read_file_content(filename):
    try:
        with open(filename, 'rb') as file:
            content = file.read().decode('utf-8', errors='ignore')
        return content
    except Exception as e:
        return str(e)


def create_txt(files):
    # Create a text file and write contents of each listed file
    with open("BTOS_Documentation.txt", "w", encoding='utf-8') as txt_file:
        for file in files:
            txt_file.write(f"----- Content of {file} -----\n")
            txt_file.write(read_file_content(file))
            txt_file.write("\n\n")

def create_pdf(files):
    pdf = FPDF(format='a5')  # Create PDF object
    pdf.set_auto_page_break(auto=1, margin=8)
    pdf.add_page()
    pdf.set_font("Arial", size=10)
    
    cell_width = 130  # Adjusted width for content cells
    line_height = 6
    
    for file in files:
        pdf.cell(200, 10, f"----- Content of {file} -----", ln=1)
        content = read_file_content(file)

        is_even_line = True  # Toggle for alternating background colors

        for line in content.split('\n'):
            words = line.split(' ')
            current_line = ''

            for word in words:
                next_line = f"{current_line} {word}".strip()
                next_line_width = pdf.get_string_width(next_line)
                
                if next_line_width <= cell_width:
                    current_line = next_line
                else:
                    if is_even_line:
                        pdf.set_fill_color(173, 216, 230)  # Light blue RGB
                    else:
                        pdf.set_fill_color(255, 255, 0)  # Yellow RGB
                    pdf.multi_cell(cell_width, line_height, current_line, fill=True)
                    is_even_line = not is_even_line
                    current_line = word

            if current_line:  # Output any remaining text in current_line
                if is_even_line:
                    pdf.set_fill_color(173, 216, 230)  # Light blue RGB
                else:
                    pdf.set_fill_color(255, 255, 0)  # Yellow RGB
                pdf.multi_cell(cell_width, line_height, current_line, fill=True)
                is_even_line = not is_even_line

        pdf.add_page()

    pdf.output("BTOS_Documentation.pdf", 'F')  # Save PDF to file


if __name__ == "__main__":
    text_files = list_text_files()

    create_txt(text_files)  # Generate the text file
    #create_pdf(text_files)  # Generate the PDF file

    print("Documentation updated: Created 'BTOS_documentation.txt' and 'BTOS_documentation.pdf'")


----- Content of Encode.cpp -----
#include <iostream>
#include <fstream>
#include <vector>
#include <filesystem>
#include <string>
#include <unordered_map>

using namespace std;
namespace fs = std::filesystem;

vector<unordered_map<string, string>> readMappings() {
    vector<unordered_map<string, string>> mappings(4);
    for (int i = 1; i <= 4; ++i) {
        ifstream file(to_string(i) + ".txt");
        if (!file) {
            cerr << "Error opening file " << i << ".txt" << endl;
            exit(EXIT_FAILURE);
        }
        string line;
        while (getline(file, line)) {
            int spacePos = line.find(' ');
            if (spacePos != string::npos) {
                string numberStr = line.substr(0, spacePos);
                string str = line.substr(spacePos + 1);
                mappings[i - 1][str] = numberStr;
            }
        }
    }
    return mappings;
}



int main() {
    auto mappings = readMappings();

    int start, end;
    cout << "Enter the range of files to read (e.g., 5 15 to read from 5.txt to 15.txt): ";
    cin >> start >> end;

    int maxFileNumber = -1;

    for (const auto& entry : fs::directory_iterator("./")) {
        string filename = entry.path().filename().string();
        if (filename.find(".txt") != string::npos) {
            int fileNumber = stoi(filename.substr(0, filename.find(".txt")));
            maxFileNumber = max(maxFileNumber, fileNumber);
        }
    }

    for (int i = start; i <= end; ++i) {
        ifstream inputFile("inputs/" + to_string(i) + ".txt");
        if (!inputFile) {
            cerr << "Could not open the file " + to_string(i) + ".txt" << endl;
            continue;
        }

        string line, content;
        while (getline(inputFile, line)) {
            content += line + "\n";
        }
        inputFile.close();

        string outputContent;
        for (size_t i = 0; i < content.size(); ++i) {
			if (content[i] == '\n') {
				outputContent += "1.27 "; // Assuming 27 is the mapping for newline character
				continue;
			}
			bool found = false;
			for (int len = 4; len >= 1; --len) {
				if (i + len - 1 < content.size()) {
					string substr = content.substr(i, len);
					if (mappings[len - 1].find(substr) != mappings[len - 1].end()) {
						int number = stoi(mappings[len - 1][substr]);
						outputContent += to_string(len) + "." + to_string(number + 1) + " ";
						i += len - 1;
						found = true;
						break;
					}
				}
			}
			if (!found) {
				outputContent += "0 ";
			}
		}


        ofstream outputFile(to_string(maxFileNumber + 1) + ".txt");
        if (outputFile) {
            outputFile << outputContent;
            outputFile.close();
            maxFileNumber++;
        } else {
            cerr << "Could not create the file " + to_string(maxFileNumber + 1) + ".txt" << endl;
        }
    }

    return 0;
}


----- Content of Encoded_Image.py -----
from tkinter import Tk, Label, Button, Entry, filedialog
from PIL import Image
from PIL import ImageDraw
import json
import itertools
import math

class App:
    def __init__(self, master):
        self.master = master
        master.title("Hex Color Picker")

        self.label = Label(master, text="Choose Text File")
        self.label.pack()

        self.open_file_button = Button(master, text="Open File", command=self.open_file)
        self.open_file_button.pack()

        self.close_button = Button(master, text="Generate Image", command=self.generate_image)
        self.close_button.pack()

    def open_file(self):
        file_path = filedialog.askopenfilename()
        with open(file_path, 'r') as file:
            self.data = file.read().split()

    def generate_image(self):
        print("Generating ...")
        if hasattr(self, 'data'):
            self.label.config(text="Generating, please wait...")
            self.master.update_idletasks()  # Force update of the GUI
            
            # Convert data to colors
            color_data = [self.data_to_color(datum) for datum in self.data]

            self.label.config(text="Data converted to colors. Creating image...")
            self.master.update_idletasks()  # Force update of the GUI

            create_image(color_data, self.data)
            
            self.label.config(text="Image successfully generated.")
            self.master.quit()
        else:
            self.label.config(text="Please select a file first.")
    
    def data_to_color(self, datum):
        # Use hash to convert the string to a unique integer value
        unique_number = hash(datum) & 0xFFFFFF  # Limit to 24 bits to match RGB
        return '#{:06X}'.format(unique_number)

def create_image(color_data, data):
    #Count unique string encodings
    unique_encodings = set(data)
    num_unique_encodings = len(unique_encodings)
    total_encodings = len(data)  # This will count all the encodings
    print(f"Number of unique encodings: {num_unique_encodings}")
    print(f"Total number of encodings: {total_encodings}")  # Added this line
    print(f"If {total_encodings} = A square number, continue, else, reformat the encoded file accordingly..")
    
        
    pixel_side_length = int(input("Enter the square side length of each pixel to be created.. "))
    num_pixels_width = int(input("Enter the pixel width of the image, by number of (custom sized) pixels.. "))
    num_pixels_height = num_pixels_width
    
    img_width = pixel_side_length * num_pixels_width
    img_height = img_width
    # Create an empty white canvas
    image = Image.new('RGB', (img_width, img_height), color="white")
    
    # Create a drawing context for the image
    draw = ImageDraw.Draw(image)

    data_idx = 0  # Index to track data position
    for i in range(num_pixels_height):
        for j in range(num_pixels_width):
            if data_idx < len(color_data):
                hex_value = color_data[data_idx]
                # Define the top-left and bottom-right coordinates for the rectangle
                top_left = (j * pixel_side_length, i * pixel_side_length)
                bottom_right = ((j + 1) * pixel_side_length, (i + 1) * pixel_side_length)
                # Draw the rectangle
                draw.rectangle([top_left, bottom_right], fill=hex_value)
                data_idx += 1

    image.show()
    image.save('output_image.png')

    return image



print("Output is named 'output_image.png'")
root = Tk()
app = App(root)
root.mainloop()


----- Content of Engineering.py -----
import tkinter as tk
import random
from PIL import ImageGrab
import pickle
from tkinter import simpledialog
import os
from tkinter import Menu, Checkbutton, BooleanVar
from tkinter.colorchooser import askcolor
import logging
import time
import json
import os
import pyautogui
import keyboard
from tkinter import filedialog
from PIL import Image, ImageTk

current_col = 0
current_row = 0
resized_images = []  # Global variable to store resized images

# Rest of your code...
# Global variable for the image selection frame
image_selection_frame = None
selected_image = None  # Global variable to hold the currently selected image
# Global variable to keep track of the current mode
current_mode = "draw_char"  # Possible values: "draw_char", "image_mode"

def toggle_mode():
    global current_mode, canvas
    if current_mode == "draw_char":
        current_mode = "image_mode"
        canvas.unbind("<Button-1>")  # Unbind draw_char function
        canvas.bind("<Button-1>", on_canvas_click_for_image)  # Bind image drawing function
    else:
        current_mode = "draw_char"
        canvas.unbind("<Button-1>")  # Unbind image drawing function
        #canvas.bind("<Button-1>", lambda event: draw_char(event.x // square_size, event.y // square_size))  # Bind draw_char function
        canvas.bind("<Button-1>", lambda event: draw_char(event.y // square_size, event.x // square_size))

        
def select_image(img):
    global selected_image
    selected_image = img
    # You can add additional logic here, e.g., updating the UI to indicate the selected image

def resize_and_add_image(file_path, size):
    try:
        with Image.open(file_path) as img:
            # Resize and add to the list
            #resized_img = img.resize(size, Image.Resampling.LANCZOS)  # For Pillow versions 8.0.0 and later
            # resized_img = img.resize(size, Image.LANCZOS)  # For older versions of Pillow
            resized_img = img.resize(size, Image.LANCZOS)
            resized_images.append(resized_img)
        update_image_selection_area()
    except Exception as e:
        print(f"Error loading image: {e}")

'''
def on_canvas_click(event):
    # Calculate the sub-square coordinates
    col = event.x // square_size
    row = event.y // square_size

    if selected_image:
        draw_image_on_canvas(row, col, selected_image)
'''

def on_canvas_click_for_image(event):
    global selected_image
    if selected_image:
        col = event.x // square_size
        row = event.y // square_size
        draw_image_on_canvas(row, col, selected_image)


def draw_image_on_canvas(row, col, image):
    x = col * square_size
    y = row * square_size

    resized_image = image.resize((square_size, square_size), Image.LANCZOS)
    tk_image = ImageTk.PhotoImage(resized_image)

    canvas.create_image(x, y, image=tk_image, anchor='nw')

    if not hasattr(canvas, 'images'):
        canvas.images = []
    canvas.images.append(tk_image)  # Keep a reference


'''
# Function to update the image selection area
def update_image_selection_area():
    for img in resized_images:
        # Convert PIL image to Tkinter PhotoImage
        tk_image = ImageTk.PhotoImage(img)
        btn = tk.Button(image_selection_frame, image=tk_image, command=lambda img=img: select_image(img))
        btn.image = tk_image  # Keep a reference to avoid garbage collection
        btn.pack(side='left')
'''

def update_image_selection_area():
    global image_selection_frame

    # Clear existing buttons in the frame
    for widget in image_selection_frame.winfo_children():
        widget.destroy()

    # Create buttons for each image
    for img in resized_images:
        tk_image = ImageTk.PhotoImage(img)
        btn = tk.Button(image_selection_frame, image=tk_image, command=lambda img=img: select_image(img))
        btn.image = tk_image  # Keep a reference to avoid garbage collection
        btn.pack(side='left')


def select_and_add_images():

    # Define a target size for the images
    wid = int(input("Target Width: "))
    hei = int(input("Target Height: "))
    target_size = (wid, hei)  # You can change this size as needed

    
    file_paths = filedialog.askopenfilenames(filetypes=[("PNG files", "*.png")])  # Enable multi-file selection
    if file_paths:
        for file_path in file_paths:
            # Assuming you have a predefined target size for the images
            resize_and_add_image(file_path, target_size)

def resize_and_add_image(file_path, size):
    try:
        with Image.open(file_path) as img:
            # Use Image.Resampling.LANCZOS for Pillow versions 8.0.0 and later
            resized_img = img.resize(size, Image.Resampling.LANCZOS)
            # For older versions of Pillow, use Image.LANCZOS
            # resized_img = img.resize(size, Image.LANCZOS)
            resized_images.append(resized_img)
        update_image_selection_area()  # Update the display area with new images
    except Exception as e:
        print(f"Error loading image: {e}")

def select_and_resize_image():
    # Ask the user to select an image file
    file_path = filedialog.askopenfilename(filetypes=[("PNG files", "*.png")])
    if not file_path:
        return  # User cancelled the dialog

    # Prompt the user for the new size
    new_size = simpledialog.askstring("Resize Image", "Enter new size (width,height):")
    if not new_size:
        return  # User cancelled the dialog

    try:
        # Parse the size input and resize the image
        width, height = map(int, new_size.split(','))
        resize_image(file_path, (width, height))
    except Exception as e:
        tk.messagebox.showerror("Error", f"An error occurred: {e}")

def resize_image(input_path, size):
    try:
        # Construct a new file name based on the original path
        dir_name, file_name = os.path.split(input_path)
        name, ext = os.path.splitext(file_name)
        output_path = os.path.join(dir_name, f"{name}_resized{ext}")

        # Open, resize, and save the image
        with Image.open(input_path) as img:
            # Use Image.Resampling.LANCZOS for Pillow versions 8.0.0 and later
            img = img.resize(size, Image.Resampling.LANCZOS)
            # For older versions of Pillow, use Image.LANCZOS
            # img = img.resize(size, Image.LANCZOS)
            img.save(output_path)

        tk.messagebox.showinfo("Success", f"Image saved successfully to {output_path}")
    except Exception as e:
        tk.messagebox.showerror("Error", f"An error occurred: {e}")



def get_random_color():
    r = lambda: random.randint(0,255)
    return '#%02X%02X%02X' % (r(),r(),r())

def get_random_char():
    random_int = random.randint(0x0021, 0x007E)
    return chr(random_int)

def draw_grid():
    for i in range(grid_size):
        for j in range(grid_size):
            color = get_random_color()
            square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
            char = get_random_char()
            text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", 18), anchor="center")


def draw_grid_IDE():
    global col
    try:
        for i in range(grid_size):
            for j in range(grid_size):
                color = "blue"
                square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color, outline = "white")
        if typing_mode:
            # In the function where you create the canvas...
            canvas.bind("<Key>", on_key_press)
            canvas.focus_set()
    except:
        print("Submit an app mode ...")


def toggle_color_mode():
    """Toggles between manual color mode and random color mode"""
    global color_mode_var
    color_mode_var.set(not color_mode_var.get())

font_size = 9

def draw_char1(canvas, char, row, col, font_size, color):
    global cell_size, font_color, square_size, grid_size, last_drawn, note, char_note

    '''
    def draw_char1(canvas, char, row, col, font_size):
    
    Draws a character on the Tkinter canvas at the specified row and column with the specified font size.
    
    Parameters:
    canvas (tk.Canvas): The Tkinter canvas to draw on.
    char (str): The character to draw.
    row (int): The row to draw the character at.
    col (int): The column to draw the character at.
    font_size (int): The font size to use for the character.
    
    '''


    try:
        x = col * square_size + square_size / 2
        y = row * square_size + square_size / 2
        
        print(f"Drawing char '{char}' at ({x}, {y})")  # Debug print to check coordinates
        canvas.create_rectangle(col * square_size, row * square_size, (col+1) * square_size, (row+1) * square_size, fill=color)
        canvas.create_text(x, y, text=char, fill=font_color, font=('Calibri', int(font_size)))
        note = char_note.get()
        # Log the color and character info
        logging.info(f"Position:'{x};{y}',Xp:'{x}',Yp:'{y}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{x},{y},{char},{color},{font_color},{note}", file=login)

    except Exception as e:
        print(f"Something Went Wrong... Error: {e}")



def draw_char(i=None, j=None):
    try:
        """Draws a character from input field in a specific square"""
        global char_count, IDE_mode, typing_mode, last_drawn, font_color
        if(mode == 'IDE'):
            IDE_mode = True
        # Check if last_drawn is defined, otherwise define it
        if 'last_drawn' not in globals():
            last_drawn = []

        # If i, j are not provided, calculate them based on char_count
        if i is None or j is None:
            i, j = divmod(char_count, grid_size)
            # Handle out-of-grid situations
            if i >= grid_size or j >= grid_size:
                print('Out of grid!')
                return

        # Generate a random color if not in typing mode, white otherwise
        ##color = get_random_color() if not typing_mode else "white"

        # Check color mode
        if color_mode_var.get():
            # Manual color mode
            # Show a color picker and get the chosen color for the square
            color = askcolor(title="Choose square color")[1]

            # Ask for the font color
            color_result = askcolor(title="Choose font color")
            if color_result is not None:
                font_color = color_result[1]
            else:
                # Handle the case when the user cancelled the color selection
                font_color = "#000000"  # default to black, for example


        else:
            # Random color mode
            color = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            color1 = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            font_color = color1 #"#000000"


        square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
        char = char_entry.get()[:1]
        note = char_note.get()
        text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", font_size), fill=font_color, anchor="center")

        '''
        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}'")
        # Log the color and character info in a text file
        with open("color_log.txt", "a") as login:
            print(f"{i},{j},{char},{color},{font_color}", file=login)
        '''

        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{i},{j},{char},{color},{font_color},{note}", file=login)

        
        if len(char_entry.get()) > 0:  # Check if there's more than one character
            char_entry.delete(0, 1)  # Delete the first character

        last_drawn.append((square, text))

        if not IDE_mode:
            char_count = (char_count + 1) % (grid_size * grid_size)
            if char_count == 0:  # If we've filled the canvas, clear it
                canvas.delete('all')

        return square, text
    except:
        print("Submit an app mode ...")


def adjust_grid_and_font():
    global grid_size, square_size, font_size, canvas_width, current_row, current_col

    n_g_s = simpledialog.askstring("Change Grid Size (Grid Width)", "Enter New Grid Size (+Integer):")
    if(n_g_s != ''):
        new_grid_size = n_g_s
    n_f_s = simpledialog.askstring("Change Font Size (Default = 9)", "Enter New Font Size (+Integer):")
    if(n_f_s != ''):
        new_font_size = n_f_s
        # Update the global variables
    if(new_grid_size==None and new_font_size==None):
        grid_size = 10
        font_size = 9
    if((not new_grid_size==None) and (not new_font_size==None)):
        try: 
            grid_size = int(new_grid_size)
            square_size = canvas_width / grid_size
            font_size = int(new_font_size)
        except:
            print("positive integers please")
        
    '''
    # Get new values from input fields
    new_grid_size = grid_size_entry.get()
    new_font_size = font_size_entry.get()
    
    # Update the global variables
    grid_size = int(new_grid_size)
    square_size = canvas_width // grid_size
    font_size = int(new_font_size)
    '''

    # Redraw the grid
    refresh_canvas()
    qit = input("Are you in typing mode, or want to enter typing mode? 1 for (No), 2 for (yes): ")
    if(qit == '2'):
        current_row = 0
        current_col = 0
        show_typing_mode_menu()

def refresh_canvas():
    """Clears the canvas and resets the char_count"""
    global char_count
    canvas.delete('all')
    char_count = 0
    draw_grid_IDE()
    last_drawn.clear()

def undo_last():
    """Undoes the last drawing operation"""
    if last_drawn:
        square, text = last_drawn.pop()
        canvas.delete(square)
        canvas.delete(text)

def update_canvas():
    if not paused.get():
        canvas.delete('all')
        draw_grid()
    root.after(8000, update_canvas)

def toggle_typing_mode():
    global typing_mode, canvas

    typing_mode = not typing_mode
    if typing_mode:
        canvas.focus_set()  # Set focus to the canvas for keyboard input



def on_canvas_click(event):
    try:
        global mode, typing_mode
        if mode == 'IDE' and not typing_mode:
            j = event.x // square_size
            i = event.y // square_size
            draw_char(i, j)
        else:
            paused.set(not paused.get())
    except:
        print("Submit an app mode ...")

def on_key_press(event):
    global char_count, typing_mode
    if typing_mode:
        char_entry.delete(0, 'end')  # Clear the entry box
        try:
            utf8_char = event.char.encode('utf-8').decode('utf-8')
            char_entry.insert(0, utf8_char)  # Insert the typed character
        except UnicodeDecodeError:
            print("Non UTF-8 character detected")
            return
        draw_char()  # Draw the character
        char_count += 1  # Increment the count

        # If char_count exceeds the total number of squares in the grid, reset it
        if char_count >= grid_size ** 2:
            char_count = 0




def submit_mode():

    global char_count, mode, typing_mode
    
    mode = mode_entry.get().upper()
    
    '''
    if mode in ['editor']:

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        draw_grid()
        char_label.pack()
        char_entry.pack()
        char_button.pack()

    '''    
        
    # Draw the initial grid
    if(mode != 'IDE'):
        print("A valid mode ...")

    '''
    if(mode == 'normal'):

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()

        draw_grid()
        create_menu_1()

    if mode == 'normal':
        # Schedule the first update
        root.after(8000, update_canvas)
    '''
    
    if mode == 'IDE':

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        char_count = 0
        draw_grid_IDE()
        
        control_frame.pack()
        char_label.pack()
        char_entry.pack()
        #grid_size_label.pack()
        #grid_size_entry.pack()
        #font_size_label.pack()
        #font_size_entry.pack()
        #adjust_button.pack()
        char_note_label.pack()
        char_note.pack()
        #refresh_button.pack(side="left")
        #undo_button.pack(side="left")
        #save_button = tk.Button(root, text='Save', command=save_canvas, bg="white", padx=5, pady=0)
        #save_button.pack(side="left")
        #save_Sbutton.pack(side="left")
        #load_button.pack(side="left")
        create_menu()


    return mode



def save_canvas():
    global IC_value, xSwitch, ing
    xSwitch = 1
    ing = 1
    if(ing == 0):
        ing = 2
    ing = 1
    if(xSwitch == 1 and ing == 1):
        IC_value = 0
        ing = 0
    """Save the current state of the canvas to a .png file"""
    #filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    filename = f"ImageCanvas{IC_value}_rename"
    
    if filename:  # Only save the canvas if a filename was entered
        # Get the bounding box of the canvas
        x = root.winfo_rootx() + canvas.winfo_x()
        y = root.winfo_rooty() + canvas.winfo_y()
        x1 = x + canvas.winfo_width()
        y1 = y + canvas.winfo_height()
        time.sleep(3)
        # Grab the image, crop it to the bounding box, and save it
        ImageGrab.grab().crop((x, y, x1, y1)).save(filename + ".png")


def save_session():
    """Save the current session to a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Save Session", "Enter filename:")
    if filename:  # Only save the session if a filename was entered
        session_data = [(canvas.coords(square), canvas.itemcget(square, "fill"),
                        canvas.coords(text), canvas.itemcget(text, "text"), canvas.itemcget(text, "fill"))
                        for square, text in last_drawn]
        with open(filename + ".pkl", "wb") as f:
            pickle.dump(session_data, f)


def load_session():
    """Load a saved session from a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Load Session", "Enter filename:")
    if filename:  # Only try to load a session if a filename was entered
        try:
            with open(filename + ".pkl", "rb") as f:
                session_data = pickle.load(f)
                # Clear the canvas and redraw all elements from the loaded session
                canvas.delete('all')
                draw_grid_IDE()
                last_drawn = []
                for square_coords, square_fill, text_coords, text_content, text_fill in session_data:
                    square = canvas.create_rectangle(*square_coords, fill=square_fill)
                    text = canvas.create_text(*text_coords, text=text_content, fill=text_fill, font=("Arial", font_size), anchor="center")
                    last_drawn.append((square, text))
        except FileNotFoundError:
            print(f"No session named '{filename}' found.")

#def exit_app():
#    exit()

def show_about():
    about_window = tk.Toplevel(root)
    about_window.title("About")
    about_msg = "This is a program created to learn and experiment with Tkinter. In IDE mode, you can draw characters on a grid (By typing or copying and pasting then clicking the squares you want to draw each character on), adjust the grid and font size, save and load sessions, and more, like saving the grid as an image (For example). C(num) was written with the aid of Chat GPT. Enjoy!\n\nNote: the workflow ... IDE to color_log.txt (Compiled by compile#.exe or compile#.py);\nindex_1.txt contains fields of study or research and development and\nindex_2.txt contains fields of study or research and development also ...\n\nBertotools Digital"
    tk.Message(about_window, text=about_msg, width=500).pack()
    tk.Button(about_window, text="OK", command=about_window.destroy).pack()

def compileGOSmX():
    MAX_LINE_LENGTH = 256
    MAX_TOPICS = 256

    global index_1, index_2
    
    index_1 = [
        "Axiom",
        "Theorem",
        "Lemma",
        "Proposition",
        "Corollary",
        "Conjecture",
        "Proof",
        "Premise",
        "Conclusion",
        "Hypothesis",
        "Counterexample",
        "Direct Proof",
        "Indirect Proof",
        "Proof by Contradiction (Reductio ad absurdum)",
        "Proof by Induction",
        "Proof by Contrapositive",
        "Deductive Reasoning",
        "Inference",
        "Assumption",
        "Statement",
        "Postulate",
        "Proof by Exhaustion",
        "Syllogism",
        "Constructive Proof",
        "Non-Constructive Proof",
        "Trivial Proof",
        "Vacuous Proof",
        "Biconditional",
        "Condition",
        "Sufficiency",
        "Necessity",
        "Quantifier",
        "Universal Quantifier",
        "Existential Quantifier",
        "Bound Variable",
        "Free Variable",
        "Predicate",
        "Propositional Logic",
        "Modus Ponens",
        "Modus Tollens",
        "Discrete Mathematics",
        "Set Theory",
        "Function",
        "Bijection",
        "Injection",
        "Surjection",
        "Equivalence Relation",
        "Partial Order",
        "Total Order",
        "Well-Order",
        "Reflexivity",
        "Symmetry",
        "Transitivity",
        "Antisymmetry",
        "Completeness",
        "Compactness",
        "Connectedness",
        "Convergence",
        "Divergence",
        "Limit",
        "Sequence",
        "Series",
        "Monotonicity",
        "Cauchy Sequence",
        "Infinite Set",
        "Finite Set",
        "Cardinality",
        "Countable Set",
        "Uncountable Set",
        "Subset",
        "Superset",
        "Intersection",
        "Union",
        "Empty Set",
        "Power Set",
        "Cartesian Product",
        "Equivalence Class",
        "Partition",
        "Field",
        "Ring",
        "Group",
        "Abelian Group",
        "Non-abelian Group",
        "Matrix",
        "Vector Space",
        "Linear Transformation",
        "Eigenvalue",
        "Eigenvector",
        "Norm",
        "Inner Product",
        "Orthogonality",
        "Basis",
        "Dimension",
        "Rank",
        "Nullity",
        "Determinant",
        "Graph Theory",
        "Vertex",
        "Edge",
        "Connectivity",
        "Cycle",
        "Path",
        "Degree",
        "Subgraph",
        "Tree",
        "Forest",
        "Planar Graph",
        "Bipartite Graph",
        "Directed Graph (Digraph)",
        "Eulerian Graph",
        "Hamiltonian Graph",
        "Adjacency Matrix",
        "Incidence Matrix",
        "Isomorphism",
        "Homeomorphism",
        "Topology",
        "Open Set",
        "Closed Set",
        "Boundary",
        "Compact Space",
        "Hausdorff Space",
        "Continuity",
        "Differential",
        "Derivative",
        "Integral",
        "Partial Derivative",
        "Multivariable Calculus",
        "Laplace Transform",
        "Fourier Transform",
        "Taylor Series",
        "Maclaurin Series",
        "Conic Sections",
        "Hyperbola",
        "Ellipse",
        "Parabola",
        "Asymptote",
        "Limits at Infinity",
        "Complex Number",
        "Imaginary Unit",
        "Real Number",
        "Rational Number",
        "Irrational Number",
        "Prime Number",
        "Composite Number",
        "GCD (Greatest Common Divisor)",
        "LCM (Least Common Multiple)",
        "Permutation",
        "Combination",
        "Probability",
        "Statistics",
        "Expected Value",
        "Variance",
        "Standard Deviation",
        "Normal Distribution",
        "Poisson Distribution",
        "Binomial Distribution",
        "Hypothesis Testing",
        "Regression",
        "Correlation",
        "Matrix Algebra",
        "Linear Algebra",
        "Vector Calculus",
        "Optimization",
        "Algorithm",
        "Computational Complexity",
        "Big O Notation",
        "Pigeonhole Principle",
        "Principle of Inclusion-Exclusion",
        "Turing Machine",
        "Computability",
        "Unsolvability",
        "Parity",
        "Diophantine Equations",
        "Cryptography",
        "Fermat's Last Theorem",
        "Pythagorean Theorem",
        "Triangle Inequality",
        "Trigonometric Functions",
        "Trigonometric Identities",
        "Polar Coordinates",
        "Euler's Formula",
        "Riemann Zeta Function",
        "P vs NP Problem",
        "NP-complete Problem",
        "Stochastic Process",
        "Markov Chain",
        "Random Variable",
        "Conditional Probability",
        "Bayes' Theorem",
        "Monte Carlo Method",
        "Fractal",
        "Chaos Theory",
        "Game Theory",
        "Nash Equilibrium",
        "Zero-Sum Game",
        "Non-Zero-Sum Game",
        "Linear Programming",
        "Nonlinear Programming",
        "Quadratic Programming",
        "Dynamic Programming",
        "Integer Programming",
        "Graph Coloring",
        "Network Flow",
        "Spanning Tree",
        "Bellman-Ford Algorithm",
        "Dijkstra's Algorithm",
        "Kruskal's Algorithm",
        "Prim's Algorithm",
        "Floyd-Warshall Algorithm",
        "Euler's Method",
        "Runge-Kutta Method",
        "Numerical Integration",
        "Numerical Differentiation",
        "Bisection Method",
        "Newton's Method",
        "Secant Method",
        "Fixed Point Iteration",
        "Linear Interpolation",
        "Polynomial Interpolation",
        "Lagrange Interpolation",
        "Splines",
        "Fourier Series",
        "Laplace's Equation",
        "Heat Equation",
        "Wave Equation",
        "Schrodinger Equation",
        "Ordinary Differential Equation (ODE)",
        "Partial Differential Equation (PDE)",
        "Boundary Value Problem",
        "Initial Value Problem",
        "Green's Theorem",
        "Stoke's Theorem",
        "Divergence Theorem",
        "Curl",
        "Gradient",
        "Divergence",
        "Tensor",
        "Manifold",
        "Topological Space",
        "Measure Theory",
        "Lebesgue Integral",
        "Borel Set",
        "Hilbert Space",
        "Banach Space",
        "Category Theory",
        "Functor",
        "Natural Transformation",
        "Sheaf",
        "Homotopy",
        "Homology",
        "Cohomology",
        "Galois Theory",
        "Algebraic Geometry",
        "Topological K-Theory",
        "Knot Theory",
        "Lattice Theory"
    ]

    index_2 = [
        "Biochemistry",
        "Biophysics",
        "Molecular biology",
        "Genetics",
        "Immunology",
        "Cell biology",
        "Microbiology",
        "Neuroscience",
        "Pharmacology",
        "Bioinformatics",
        "Biotechnology",
        "Proteomics",
        "Genomics",
        "Structural biology",
        "Virology",
        "Systems biology",
        "Developmental biology",
        "Evolutionary biology",
        "Synthetic biology",
        "Metabolomics",
        "Epigenetics",
        "Tissue engineering",
        "Nanotechnology",
        "Materials science",
        "Quantum physics",
        "Condensed matter physics",
        "Particle physics",
        "Astrophysics",
        "Cosmology",
        "Optics",
        "Atomic and molecular physics",
        "Fluid mechanics",
        "Thermodynamics",
        "Environmental science",
        "Climate science",
        "Geology",
        "Oceanography",
        "Atmospheric science",
        "Ecology",
        "Conservation biology",
        "Botany",
        "Zoology",
        "Entomology",
        "Marine biology",
        "Paleontology",
        "Anthropology",
        "Archaeology",
        "Psychology",
        "Cognitive science",
        "Social psychology",
        "Linguistics",
        "Artificial intelligence",
        "Machine learning",
        "Computer vision",
        "Natural language processing",
        "Human-computer interaction",
        "Robotics",
        "Computer graphics",
        "Data science",
        "Mathematical modeling",
        "Mathematical physics",
        "Number theory",
        "Algebraic geometry",
        "Differential equations",
        "Computational physics",
        "Mathematical biology",
        "Operations research",
        "Biostatistics",
        "Epidemiology",
        "Cancer research",
        "Diabetes research",
        "Heart disease research",
        "Infectious diseases research",
        "Immunotherapy",
        "Stem cell research",
        "Gene therapy",
        "Drug discovery",
        "Precision medicine",
        "Health informatics",
        "Renewable energy",
        "Energy storage",
        "Sustainable materials",
        "Environmental engineering",
        "Water management",
        "Transportation engineering",
        "Civil engineering",
        "Chemical engineering",
        "Aerospace engineering",
        "Biomedical engineering",
        "Electrical engineering",
        "Mechanical engineering",
        "Robotics engineering",
        "Quantum computing",
        "Cryptography",
        "Cybersecurity",
        "Network engineering",
        "Telecommunications",
        "Human genetics",
        "Forensic science",
        "Space exploration and research",
        "Planetary science",
        "Astrobiology",
        "Astrochemistry",
        "Astrogeology",
        "Astroinformatics",
        "Exoplanet research",
        "Stellar evolution",
        "Galactic astronomy",
        "Observational astronomy",
        "Computational astrophysics",
        "Quantum chemistry",
        "Computational chemistry",
        "Organic chemistry",
        "Inorganic chemistry",
        "Physical chemistry",
        "Environmental chemistry",
        "Analytical chemistry",
        "Agricultural science",
        "Food science",
        "Nutritional science",
        "Exercise physiology",
        "Sports science",
        "Biomechanics",
        "Plant physiology",
        "Plant genetics",
        "Plant pathology",
        "Soil science",
        "Hydrology",
        "Geochemistry",
        "Geophysics",
        "Geomorphology",
        "Remote sensing",
        "Geotechnical engineering",
        "Petroleum engineering",
        "Aerospace materials",
        "Nanomaterials",
        "Polymer science",
        "Computational materials science",
        "Photonics",
        "Physical optics",
        "Quantum optics",
        "Neuroengineering",
        "Brain imaging",
        "Cognitive neuroscience",
        "Neuroinformatics",
        "Psychophysics",
        "Developmental psychology",
        "Personality psychology",
        "Clinical psychology",
        "Industrial-organizational psychology",
        "Educational psychology",
        "Psycholinguistics",
        "Human genetics",
        "Evolutionary genetics",
        "Population genetics",
        "Genetic engineering",
        "Genetic counseling",
        "Epigenomics",
        "Cardiovascular research",
        "Respiratory research",
        "Gastroenterology research",
        "Endocrinology research",
        "Nephrology research",
        "Hematology research",
        "Ophthalmology research",
        "Orthopedic research",
        "Dermatology research",
        "Veterinary medicine",
        "Animal behavior",
        "Conservation ecology",
        "Wildlife biology",
        "Environmental microbiology",
        "Agricultural economics",
        "Development economics",
        "Behavioral economics",
        "Econometrics",
        "Financial mathematics",
        "Operations management",
        "Supply chain management",
        "Industrial engineering",
        "Human-computer interaction",
        "Virtual reality",
        "Augmented reality",
        "Data mining",
        "Text mining",
        "Big data analytics",
        "Computational linguistics",
        "Quantum information science",
        "Quantum cryptography",
        "Biometrics",
        "Information retrieval",
        "Software engineering",
        "Computer networks",
        "Embedded systems",
        "Human-robot interaction",
        "Control systems",
        "Biopharmaceuticals",
        "Drug delivery systems",
        "Clinical trials",
        "Regenerative medicine",
        "Agricultural biotechnology",
        "Plant breeding",
        "Animal breeding",
        "Food technology",
        "Sensory science",
        "Poultry science",
        "Aquaculture",
        "Marine ecology",
        "Limnology",
        "Population ecology",
        "Landscape ecology",
        "Evolutionary ecology",
        "Environmental toxicology",
        "Environmental chemistry",
        "Environmental microbiology",
        "Ecotoxicology",
        "Green chemistry",
        "Space physics",
        "Space weather",
        "Astrostatistics",
        "Computational fluid dynamics",
        "Mathematical optimization",
        "Operations research",
        "Human genetics",
        "Functional genomics",
        "Molecular genetics",
        "Cancer genetics",
        "Psychiatric genetics",
        "Population genomics",
        "Bioengineering",
        "Biomaterials",
        "Biomechatronics",
        "Cardiovascular engineering",
        "Neural engineering",
        "Rehabilitation engineering",
        "Genetic engineering",
        "Environmental engineering",
        "Water resources engineering",
        "Structural engineering",
        "Robotics engineering",
        "Quantum information theory",
        "Quantum simulation",
        "Quantum sensing",
        "Geographical information systems (GIS)",
        "Urban planning",
        "Renewable energy systems",
        "Solar cell technology",
        "Wind energy research",
        "Energy policy and economics",
        "Computational neuroscience",
        "Neurobiology",
        "Cognitive neuroscience",
        "Systems neuroscience",
        "Human-robot interaction",
        "Evolutionary psychology",
        "Social network analysis"
    ]



    def square_print_topic_indices(r_value, g_value, b_value, file):
        index1 = r_value % len(index_1)
        index2 = g_value % len(index_1)
        index3 = b_value % len(index_1)
        '''
        file.write(f"\t\t\t{topics[index1]}\n")
        file.write(f"\t\t\t{topics[index2]}\n")
        file.write(f"\t\t\t{topics[index3]}\n")
        '''
        file.write(f"\t\t\t{index_1[index1]}\n")
        file.write(f"\t\t\t{index_1[index2]}\n")
        file.write(f"\t\t\t{index_1[index3]}\n")
                
        squareRatio = str(index1) + ":" + str(index2) + ":" + str(index3)
        return squareRatio

    def font_print_topic_indices(r_value, g_value, b_value, file):
        index1_ = r_value % len(index_2)
        index2_ = g_value % len(index_2)
        index3_ = b_value % len(index_2)
        file.write(f"\t\t\t{index_2[index1_]}\n")
        file.write(f"\t\t\t{index_2[index2_]}\n")
        file.write(f"\t\t\t{index_2[index3_]}\n")

        fontRatio = str(index1_) + ":" + str(index2_) + ":" + str(index3_)
        return fontRatio



    def get_index(i, j, grid_size):
        return i * grid_size + j

    def extract_rgb_values(color):
        if len(color) != 7 or color[0] != '#':
            raise ValueError('Input should be a hex color code in the format "#RRGGBB"')
        try:
            red = int(color[1:3], 16)
            green = int(color[3:5], 16)
            blue = int(color[5:7], 16)
            return red, green, blue
        except ValueError:
            raise ValueError('Invalid color code. RGB values should be hex digits (0-9, A-F)')


    def GO():
        log_file = "color_log.txt"
##        topic_file = "index_1.txt"
##        topic2_file = "index_2.txt"  # Corrected this line to read from a different file
        gridWidth = int(input("Enter gridWidth: "))
        # Read topic files to get the topics and topic2s
##        with open(topic_file, "r", encoding='utf8') as file:
##            topics = [line.strip() for line in file]
##
##        with open(topic2_file, "r", encoding='utf8') as file:
##            topic2s = [line.strip() for line in file]

        numTopics = len(index_1)
        numTopic2s = len(index_2)

        # Read color log file
        with open(log_file, "r") as file:
            lines = file.readlines()

        lineNumber = 0
        # Save output to a file
        output_file = "output.txt"
        with open(output_file, "w") as file:
            print()
        for line in lines:
            parts = line.strip().split(",")
            if len(parts) >= 5:
                xcoor = int(parts[1])
                ycoor = int(parts[0])
                index_ = (gridWidth * ycoor) + xcoor
                character = parts[2]
                squareColor = parts[3]
                fontColor = parts[4]
                notes = parts[5]

                # Extract RGB values from squareColor
                red, green, blue = extract_rgb_values(squareColor)

                # Extract RGB values from fontColor
                fontRed, fontGreen, fontBlue = extract_rgb_values(fontColor)

                # Calculate the grid size
                grid_size = int(parts[0])

                # Select topics based on RGB values from squareColor
                topicIndices = [(red + get_index(i, j, grid_size)) % numTopics for i in range(grid_size) for j in range(grid_size)]
                
                lineNumber += 1

                
                with open(output_file, "a") as file:
                    file.write(f"Compiling Line/s: {lineNumber}\n\n")
                    file.write(f"Line({lineNumber})\n\n")
                    file.write(f"0\tLineNumber: {lineNumber}\tx-coordinate: {xcoor}\ty-coordinate: {ycoor}\t Character: {character}\tRGB: {squareColor}\tRGB: {fontColor}\t Note: {notes}\t GridDimensions: {gridWidth}x{gridWidth}\n\n")
                    #print(topicIndices)
                    file.write(f"Line/s({lineNumber}) Output:\n\n")
                    file.write(f"#define Line({lineNumber}){{\n\n")
                    # Inside the main function
                    file.write(f"\ti_1_0(squareColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {red}, G: {green}, B: {blue})\n")
                    s_ratio = square_print_topic_indices(red, green, blue, file)
                    #square_print_topic_indices(red, green, blue, topics, file)   # Modify this line
                    file.write("\t\t)\n")
                    file.write("\t};\n\n")
                    file.write(f"\ti_1_1(fontColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {fontRed}, G: {fontGreen}, B: {fontBlue})\n")
                    f_ratio = font_print_topic_indices(fontRed, fontGreen, fontBlue, file)
                    #font_print_topic_indices(fontRed, fontGreen, fontBlue, topic2s, file)   # And this line
                    file.write("\t\t)\n")
                    file.write(f"\treturn squareRatio({s_ratio}), fontRatio({f_ratio}), sqaureIndex({index_})\n")
                    #file.write(f"\treturn fontRatio({f_ratio})\n")
                    file.write("}\n\n")


    GO()


def create_menu():
    global control_frame
    def home():
        canvas.pack_forget()
        menubar.destroy()
        control_frame.pack()
        char_entry.pack_forget()
        char_label.pack_forget()
        #grid_size_label.pack_forget()
        #grid_size_entry.pack_forget()
        #font_size_label.pack_forget()
        #font_size_entry.pack_forget()
        #adjust_button.pack_forget()
        char_note.pack_forget()
        char_note_label.pack_forget()

        root.destroy()
        switch = 1
        setup_mode(switch)
    
    # Create a menubar
    menubar = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu = tk.Menu(menubar, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="Toggle Manual/Random Colour", command=manual_colour)

    dropdown.add_command(label="Refresh", command=refresh_canvas)
    dropdown.add_command(label="Undo", command=undo_last)
    dropdown.add_command(label="Save Session", command=save_session)
    dropdown.add_command(label="Load Session", command=load_session)
    dropdown.add_command(label="Save as Image", command=save_canvas)
    dropdown.add_command(label="Compile Canvas", command=compileGOSmX)
    # Add the new command for resizing images
    dropdown.add_command(label="Select and Resize Image", command=select_and_resize_image)
    # Add the command for selecting images
    dropdown.add_command(label="Select Images", command=select_and_add_images)
    # Add the toggle mode command
    dropdown.add_command(label="Toggle Draw Chars/Images", command=toggle_mode)
    #dropdown.add_command(label="Exit", command=exit_app)
    #dropdown.add_command(label="Toggle Type/Click Mode", command=toggle_typing_mode)
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Go Home", command=home)
    dropdown.add_command(label="Edit Grid Dimensions", command=adjust_grid_and_font)
    dropdown.add_command(label="Typing Mode", command=show_typing_mode_menu)


    # Set the menubar
    root.config(menu=menubar)

    

def create_menu_1():
    global control_frame
    def home1():
        canvas.pack_forget()
        menubar1.destroy()
        root.destroy()
        switch = 1
        setup_mode(switch)
        
    
    # Create a menubar
    menubar1 = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu1 = tk.Menu(menubar1, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar1, tearoff=0)
    menubar1.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Change Mode", command=home1)

    # Set the menubar
    root.config(menu=menubar1)


def manual_colour():
    # Toggle the value of color_mode_var
    current_value = color_mode_var.get()
    color_mode_var.set(not current_value)


'''
# Create a tkinter window
root = tk.Tk()
root.title("General Operating System")
root.iconbitmap("logo.ico")
'''

def show_typing_mode_menu():
    global color_
    while True:
        print("1. Use default UTF-8 mapping")
        print("4. Exit")
        choice = input("Choose an option: ")
        
        if choice == "1":
            # Use default UTF-8 mapping
            print("Using default UTF-8 mapping.")
            color_ = input("Use Default Colour Scheme (1): ")
            if(color_ == '1'):
                # Initialize bg_color and font_color with default values at the global scope
                bg_color = "#FFFFFF"  # Default white background color
                font_color = "#000000"  # Default black font color
                break
        else:
            print("Invalid choice. Please try again.")

    canvas.bind("<Key>", type_character)
    canvas.focus_set()





def set_background_color():
    global color
    #bg_color = tk.colorchooser.askcolor()[1]
    color = input("Enter background color (#FFFFFF for example):")
    
def set_font_color():
    global font_color, font_size
    #font_color = tk.colorchooser.askcolor()[1]
    font_color = input("Enter background color (#000000 for example): ")
    font_size = input("Enter font_size: ")


def type_character(event):
    global current_row, current_col, col, font_size, font_color, color, canvas_width, square_size
    color = "#FFFFFF"
    font_color = "#000000"
    char = event.char
    if char:  # Ignore non-character events
        try:
            
            draw_char1(canvas, char, current_row, current_col, font_size, color)
            current_col += 1
            if (current_col >= canvas_width/square_size):
                current_col = 0
                current_row += 1
            if(current_row >= canvas_width/square_size):
                current_col = 0
                current_row = 0
        except Exception as e:
            print("Something Went Wrong...")
            print(e)

        
        


def setup_mode(sw):

    global mode_entry, mode_label, square_size, grid_size, char_count, last_drawn
    global root, color_mode_var, logging, paused, canvas_width, canvas_height, canvas
    global grid_size_label, grid_size_entry, font_size_label, font_size_entry, adjust_button
    global save_Sbutton, load_button, char_label, char_entry, char_note_label, char_note, char_button
    global refresh_button, undo_button, control_frame, submit_button, col, color_
    global image_selection_frame  # Use the global variable



    current_row = 0
    current_col = 0
    color_ = 1
    
    # Define the size of the squares and the grid
    #square_size = 70
    square_size = int(input("Enter sub-square size: "))
    #grid_size = 10
    grid_size = int(input("Enter grid size by the number of sub-squares: "))
    char_count = 0
    last_drawn = []

    window_height = square_size * grid_size + (square_size * 2)
    window_width = square_size * grid_size
    

    if(sw == 1):
        # Create a tkinter window
        root = tk.Tk()
        # Define the frame for displaying the image selection
        image_selection_frame = tk.Frame(root)
        image_selection_frame.pack(side='top')  # Adjust the side as per your layout
        root.title("C")
        #root.iconbitmap("logo.ico")
        sw = 0
        switch = 0

    ###


    # Get screen width and height
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    # Calculate position of the window
    position_top = int(screen_height / 2 - window_height / 2)
    position_right = int(screen_width / 2 - window_width / 2)
    
    # Set the dimensions of the window and where it is placed
    root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')

    ###

    # Create a BooleanVar for the color mode and set it to False initially
    color_mode_var = BooleanVar(value=False)

    # Setup logging
    logging.basicConfig(filename='logging.txt', level=logging.INFO)

    paused = tk.BooleanVar()
    paused.set(False)

    canvas_width = grid_size * square_size
    canvas_height = grid_size * square_size
    canvas = tk.Canvas(root, width=canvas_width, height=canvas_height)
    col = canvas_width
    canvas.pack()
    canvas.bind("<Button-1>", on_canvas_click)
    
    # In the function where you create the canvas...
    canvas.bind("<Key>", on_key_press)
    canvas.focus_set()
    
    # Create input fields and buttons for grid and font size input
    grid_size_label = tk.Label(root, text="Grid size:")
    grid_size_entry = tk.Entry(root, width=5)
    font_size_label = tk.Label(root, text="Font size:")
    font_size_entry = tk.Entry(root, width=5)
    adjust_button = tk.Button(root, text='Adjust Grid & Font', command=adjust_grid_and_font)

    # Create the save and load buttons
    save_Sbutton = tk.Button(root, text='Save Session', command=save_session, bg="white", padx=5, pady=0)
    load_button = tk.Button(root, text='Load Session', command=load_session, bg="white", padx=5, pady=0)

    # Create input fields and buttons for mode and character input
    mode_label = tk.Label(root, text="Enter ... 'IDE' for an\nInteractive Development Environment\nfor Learning anything!")
    mode_entry = tk.Entry(root)
    submit_button = tk.Button(root, text='LEARN', command=submit_mode)


    '''
    filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    if filename:
    '''
    
    char_label = tk.Label(root, text="Enter symbol/s to draw: ")
    char_entry = tk.Entry(root, width=12)
    char_note_label = tk.Label(root, text="Enter Note: ")
    char_note = tk.Entry(root, width=12)
    #char_button = tk.Button(root, text='Draw Character', command=draw_char)

    refresh_button = tk.Button(root, text='Refresh', command=refresh_canvas, bg="white", padx=5, pady=0)
    undo_button = tk.Button(root, text='Undo', command=undo_last, bg="white", padx=5, pady=0)

    control_frame = tk.Frame(root)

    mode_label.pack()
    mode_entry.pack()
    submit_button.pack()
    # create_menu(root)

    # Run the tkinter main loop
    root.mainloop()

global switch
switch = 1


setup_mode(switch)


----- Content of Enumeration_of_DSG.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	puts("(pt) == Universal Set = Computer");
	puts("(pt)i = sub-set of (pt)");
	puts("(pt)ia = element of sub-set of (pt)");
	puts("ti = ia");
	puts("t = i of (pt)ia ");
	puts("i = a of ((pt)ia)");
	puts("\nProgressive Abstract Numerical Solution");
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("PROGRESSIVE_ANS_px_RENAME.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int a[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999};
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 1000;
	for(pr = 0; pr < pc; pr++){
		printf("%d	%d\n", pr, a[pr]);
	}
	char choice;
	cout << "Enter a to uniquely use the 1 to 1000 identifiers for the Default Library or c to create a custom Library: ";
	cin >> choice;
	
	cout << "Enter the size of your array: ";
	cin >> pin;
		
	int array[pin], inn, position;
	int generate;
	cout << "\nDo you want manually create your array (0) or, do you want to generate your array for a range of numbers (1):	";
	cin >> generate;
	int lbrange;
	int ubrange;
	//int i_lbrange, i_ubrange;
	int r_check;
	r_check = 0;
	
	if(choice == 'c'){
		//cout << "Enter the size of your array: ";
		//cin >> pin;
		//int array[pin], inn, position;
		
	
		
		if(generate == 0){
			cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
			for(inn = 0; inn < pin; inn++){
				cin >> array[inn];
			}
		}
		if(generate == 1){
			cout << "\nEnter the lower inclusive bound of the array range of numbers:	";
			cin >> lbrange;
			//i_lbrange = int(lbrange);
			cout << "\nEnter the upper inclusive bound of the array range of numbers:	";
			cin >> ubrange;
			//i_ubrange = ubrange;
			r_check = lbrange;
			//generate custom array from user input;
			for(inn = 0; inn < pin; inn++){
			//	r_check = r_check + 1;
				array[inn] = r_check;
				printf("\n%d", r_check);
				r_check = r_check + 1;
				if (r_check > ubrange){
					break;
				}
			}
			
		}
//		for(inn = 0; inn < pin; inn++){
//			cin >> array[inn];
//		}
	}
	
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	if(choice == 'c'){
		k = pin - 1;
	}
	if(choice == 'a'){
		k = 1000 - 1;
	}
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	int id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	int ai, ci, switch_c, switch_a;
	
	

	
	if(choice == 'c'){
		
		switch_c = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ci;
		
		for(ci; n < ci + 1; n++){
			
			if(switch_c == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n,id);
				for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[rin]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[rin]);
					}
					
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_c = 1;
		}
	}
	int check;
	check = pin - 1000;
	

	
		
	if(choice == 'a' && check == 0){
	
		switch_a = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ai;
	
		for(n; n < ai + 1; n++){
			if(switch_a == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n, id);
				for (col=n-1; col>=0; col--){
					
					rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					//rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[cell]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[cell]);
					}
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_a = 1;
		}
	}
	
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of ETA.py -----
import os
import subprocess

def main_menu():
    print("\nEnhanced Terminal Application")
    print("1. Execute Command")
    print("2. File System Operations")
    print("9. Exit")
    choice = input("Enter choice: ")
    return choice

def execute_command():
    command = input("Enter command: ")
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        print(result.stdout)
    except Exception as e:
        print(f"An error occurred: {e}")

def file_system_operations():
    print("File System Operations:")
    print("1. List Directory Contents")
    print("2. Change Directory")
    print("3. Create a Directory")
    print("4. Delete a Directory")
    print("9. Return to Main Menu")
    choice = input("Enter choice: ")
    return choice

def list_directory_contents():
    path = input("Enter directory path: ")
    try:
        contents = os.listdir(path)
        for item in contents:
            print(item)
    except FileNotFoundError:
        print("Directory not found.")

def change_directory():
    path = input("Enter path to change to: ")
    try:
        os.chdir(path)
        print(f"Changed to directory: {os.getcwd()}")
    except FileNotFoundError:
        print("Directory not found.")

def create_directory():
    path = input("Enter directory path to create: ")
    try:
        os.makedirs(path, exist_ok=True)
        print(f"Directory created: {path}")
    except OSError as e:
        print(f"An error occurred: {e}")

def delete_directory():
    path = input("Enter directory path to delete: ")
    try:
        os.rmdir(path)
        print(f"Directory deleted: {path}")
    except OSError as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    while True:
        user_choice = main_menu()
        if user_choice == "1":
            execute_command()
        elif user_choice == "2":
            while True:
                fs_choice = file_system_operations()
                if fs_choice == "1":
                    list_directory_contents()
                elif fs_choice == "2":
                    change_directory()
                elif fs_choice == "3":
                    create_directory()
                elif fs_choice == "4":
                    delete_directory()
                elif fs_choice == "9":
                    break
        elif user_choice == "9":
            break


----- Content of exctract1.py -----
import os
import re

def extract_characters_from_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        return re.findall(r'\bU\+[0-9A-F]{4,5}\b', file.read())

def write_characters_to_file(characters, output_file_path):
    with open(output_file_path, 'w', encoding='utf-8') as file:
        for char in characters:
            # Convert Unicode code point to character
            file.write(chr(int(char[2:], 16)) + '\n')

def main():
    directory = '.'  # Specify the directory where your files are located
    output_file_path = 'charSF1.txt'
    all_characters = []

    for filename in os.listdir(directory):
        if filename.startswith('Unihan_Readings') and filename.endswith('.txt'):
            file_path = os.path.join(directory, filename)
            characters = extract_characters_from_file(file_path)
            all_characters.extend(characters)

    write_characters_to_file(set(all_characters), output_file_path)
    print("Characters extracted and saved to", output_file_path)

if __name__ == "__main__":
    main()


----- Content of extract2.py -----
import os
import re

def extract_characters_from_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        return re.findall(r'\bU\+[0-9A-F]{4,5}\b', file.read())

def write_characters_to_file(characters, output_file_path):
    with open(output_file_path, 'w', encoding='utf-8') as file:
        for char in characters:
            file.write(chr(int(char[2:], 16)) + '\n')

def main():
    directory = '.'  # Specify the directory where your files are located
    output_file_path = 'charSF2.txt'
    all_characters = set()
    files_to_process = ['Unihan_Readings', 'Unihan_DictionaryLikeData', 'Unihan_IRGSources']  # Add more file names as needed

    for filename in os.listdir(directory):
        for file_prefix in files_to_process:
            if filename.startswith(file_prefix) and filename.endswith('.txt'):
                file_path = os.path.join(directory, filename)
                characters = extract_characters_from_file(file_path)
                all_characters.update(characters)

    write_characters_to_file(all_characters, output_file_path)
    print("Characters extracted and saved to", output_file_path)

if __name__ == "__main__":
    main()


----- Content of FIdentifier.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>

int main(){
	
	
	//char i[4] = {""};
	int j;
	int tmax;
	puts("Note: Program Output --> FIdentified.txt --> In current Directory\n");
	printf("\nStatement/Word Character Length = ");
	scanf("%d", &tmax);
	j = tmax;
	printf("\n\t%d it is", j);
	char ui[tmax];
	printf("\n\nInput String (Max Length = 4): ");
	int x;
	puts("\n");
	scanf("%s", &ui);
	printf("Your Input:\n\t");
	for(x = 0; x < j; x++){
		printf("%c", ui[x]);
	}
	
	/*
	fn(v,p) = (v(a + i)(p(n- k)) + ... + v(0)) - (p(n - l) + ... + p(0));
	i = {1,2,3,4 ...};
	k = {1,2,3,4 ...};
	l = {1,2,3,4 ...};
	a = 0;
	p(n - k) = e^(n-k);
	e = number of potential events in the set of potential events;
	v(0) =  NULL;
	p(0) = NULL;
	(v1)(NULL) = v1;
	NULL + NULL = 0;
	n = number of events of the statement or of the word;
	Read from left to right;
	
	God
	
	--->
	
	(v1(p2) + v2(p1) + v3(p(0)) + v(0)) - (p2 + p1 + p(0))
	((71*100^2) + (15*100^1) + (4*NULL) + NULL) - (100^2 + 100^1 + NULL);
	((71*100^2) + (15*100^1) + (4)) - (100^2 + 100^1)
	701404
	3CF701404
	*/
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	
	//puts("How many characters long is your input: ");
	//scanf("%d", &j);
	int e,kmax,item,v,a1,i,p,n,k,l,pros,psum,image;
	long N;
	e = 100;
	a1 = 0;
	k = 1;
	n = j;
	kmax = n - k;
	int pr,f;
	f = 0;
	N = 0;
	if(n <= 4 && n > 0){
			i = a1;
			item = a1 + i;
			while(f < n){
				for(image = 0; image < e; image++){
					if(ui[item] == a[image]){
						N = N + ((image + 1)*(pow(e,n - k)));
						image = e;
						k++;
						item++;
					}
						
					i++;
				}
				f++;
				
			}
		image = 0;
	}
	
	//N = N + v;
	int iter;
	for(iter = 0; iter < kmax; ++iter){
		N = N - (pow(e,kmax - iter));
	}
	
	FILE *pi;
	pi = fopen("FIdentified.txt","w");
	
	fprintf(pi,"%dCF%d\n\t",n,N);
	fprintf(pi,"%s", ui);
	printf("\n\nFile Identified:\n\t%dCF%d\n\n\t",n,N);
	
	fclose(pi);
	
	system("pause");
	
	return 0;
}


----- Content of File_Explorer.py -----
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
import os

def open_directory():
    folder_selected = filedialog.askdirectory()
    if folder_selected:
        update_file_list(folder_selected)

def update_file_list(folder_selected):
    for widget in file_canvas_frame.winfo_children():
        widget.destroy()

    for file_name in os.listdir(folder_selected):
        btn = ttk.Button(file_canvas_frame, text=file_name, command=lambda name=file_name: open_file_or_folder(folder_selected, name))
        btn.pack(side=tk.TOP, anchor=tk.W, padx=5, pady=5)

    file_canvas_frame.update_idletasks()
    file_canvas.config(scrollregion=file_canvas.bbox("all"))

def open_file_or_folder(folder, file_name):
    path = os.path.join(folder, file_name)
    if os.path.isdir(path):
        update_file_list(path)
    else:
        os.system(f'start "" "{path}"')

root = tk.Tk()
root.title("Simple File Explorer")

frame = tk.Frame(root, padx=10, pady=10)
frame.pack(padx=20, pady=20, fill=tk.BOTH, expand=True)

file_frame = tk.Frame(frame)
file_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

file_canvas = tk.Canvas(file_frame)
file_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

file_scrollbar = ttk.Scrollbar(file_frame, orient="vertical", command=file_canvas.yview)
file_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

file_canvas.configure(yscrollcommand=file_scrollbar.set)

file_canvas_frame = tk.Frame(file_canvas)
file_canvas.create_window((0,0), window=file_canvas_frame, anchor="nw")

button_open_directory = ttk.Button(frame, text="Open Directory", command=open_directory)
button_open_directory.pack(side=tk.LEFT, padx=10, pady=10)

root.mainloop()


----- Content of find_square_number.py -----
def closest_square(n):
    """
    Returns the closest square number to the given integer n.
    """
    # Calculate the square root of the number
    root = n ** 0.5

    # Find the two closest integers to the square root
    lower_integer = int(root)
    upper_integer = lower_integer + 1

    # Compare the distance of their squares to the original number
    if abs(n - lower_integer**2) <= abs(n - upper_integer**2):
        return lower_integer**2
    else:
        return upper_integer**2

def main():
    # Prompt the user for an integer
    num = int(input("Enter an integer for the closest square number to it: "))

    # Find and print the closest square number
    print(f"The closest square number to {num} is {closest_square(num)}.")

if __name__ == "__main__":
    main()


----- Content of Finite-Automata.py -----
#Computational Mechanics of Finite Elements Using Finite Automata

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import matplotlib.animation as animation
import numpy as np
import random

class MealyMachine:
    def __init__(self, state_table, output_table, initial_state):
        self.state_table = state_table
        self.output_table = output_table
        self.current_state = initial_state

    def transition(self, input_val):
        self.current_state = self.state_table[self.current_state][input_val]
        return self.output_table[self.current_state][input_val]

state_table = {
    'State1': {'input1': 'State2', 'input2': 'State3', 'input3': 'State4', 'input4': 'State1'},
    'State2': {'input1': 'State3', 'input2': 'State4', 'input3': 'State1', 'input4': 'State2'},
    'State3': {'input1': 'State4', 'input2': 'State1', 'input3': 'State2', 'input4': 'State3'},
    'State4': {'input1': 'State1', 'input2': 'State2', 'input3': 'State3', 'input4': 'State4'},
}


# Pad the hex color with zeros to ensure it has six digits
hex_color1 = input("Enter Hex Font Color, e.g. (#000000): ")
hex_color2 = input("Enter Hex Square Color, e.g. (#0E0000): ")

output_table = {
    'State1': {'input1': (0, 1, hex_color1), 'input2': (0, -1, 'blue'), 'input3': (1, 0, 'green'), 'input4': (-1, 0, 'yellow')},
    'State2': {'input1': (0, 1, 'yellow'), 'input2': (0, -1, 'green'), 'input3': (1, 0, 'blue'), 'input4': (-1, 0, 'red')},
    'State3': {'input1': (0, 1, 'blue'), 'input2': (0, -1, 'yellow'), 'input3': (1, 0, 'red'), 'input4': (-1, 0, 'green')},
    'State4': {'input1': (0, 1, 'green'), 'input2': (0, -1, 'red'), 'input3': (1, 0, 'yellow'), 'input4': (-1, 0, hex_color2)},
}

# Initialize plot
fig, ax = plt.subplots()

n = int(input("Enter GridWidth: "))  # Number of squares in one dimension
squares = []
machines = []
for i in range(n):
    for j in range(n):
        square = Rectangle((i*2, j*2), 1, 1, fill=None, edgecolor='r')
        ax.add_patch(square)
        squares.append(square)
        machines.append(MealyMachine(state_table, output_table, np.random.choice(['State1', 'State2', 'State3', 'State4'])))

ax.set_xlim(-2, 2*n)
ax.set_ylim(-2, 2*n)
ax.set_aspect('equal')  # ensures that the square remains a square

in1 = input("Enter word 1: ")
in2 = input("Enter word 2: ")
in3 = input("Enter word 3: ")
in4 = input("Enter word 4: ")



inputs = np.random.choice(['input1', 'input2', 'input3', 'input4'], size=20)  # Inputs for 20 iterations

def update(num, squares, machines):
    input_val = inputs[num]
    for square, machine in zip(squares, machines):
        dx, dy, color = machine.transition(input_val)
        
        # Check if the square is about to move outside of the frame
        new_x = square.get_x() + dx
        new_y = square.get_y() + dy
        if new_x < 0 or new_x > 2*n - 1 or new_y < 0 or new_y > 2*n - 1:
            continue

        square.set_x(new_x)
        square.set_y(new_y)
        square.set_edgecolor(color)


ani = animation.FuncAnimation(fig, update, frames=len(inputs), fargs=[squares, machines])

ani.save('animation.gif', writer='imagemagick', fps=1)

plt.show()





----- Content of Finite_Automata.py -----
import re

def read_file(filename):
    with open(filename, 'r') as file:
        return [line.strip() for line in file]


class FSM:
    def __init__(self, transitions, start_state, accept_states):
        self.transitions = transitions
        self.current_state = start_state
        self.accept_states = accept_states

    def transition(self, input_conditions):
        for transition, next_state in self.transitions.get(self.current_state, {}).items():
            if eval(transition.format(**input_conditions)):
                self.current_state = next_state
                return

    def is_accept_state(self):
        return self.current_state in self.accept_states

def evaluate_logic(logic_list, words_dict):
    binary_results = []
    for logic, truth_value, binary_id in logic_list:
        # Replace numbers in logic with corresponding words
        for num, word in words_dict.items():
            logic = logic.replace(num, f'"{word}"')
        # Evaluate the logic expression
        eval_result = eval(logic)
        # Compare the evaluation result to the desired truth value
        result = '1' if eval_result == (truth_value == '1') else '0'
        binary_results.append(result)
    return ''.join(binary_results)

# Parse logic.txt to create a list of tuples containing logic expressions, truth values, and binary identifiers
logic_file = read_file('logic.txt')
logic_list = []
for line in logic_file:
    parts = line.rsplit(' ', 2)
    if len(parts) == 3:
        logic_list.append(tuple(parts))
    else:
        print(f"Error: Unable to parse line: {line}")

# Parse words.txt to create a dictionary mapping binary digits to words
words_file = read_file('words.txt')
words_dict = {line.split()[0]: line.split()[1] for line in words_file}

# Evaluate logic for each logic expression and compare against truth value
result_string = evaluate_logic(logic_list, words_dict)
print(result_string)


----- Content of Generate-PDF-LaTeX.py -----
import os
import subprocess

def is_valid_content_file(file_name):
    valid_extensions = ['.txt', '.tex', '.png']
    return os.path.splitext(file_name)[1] in valid_extensions

def sort_files(files):
    return sorted(files, key=lambda x: int(os.path.splitext(os.path.basename(x))[0]))

def process_text_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return "\\paragraph{} " + content

def process_latex_file(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
    return content

def process_image_file(file_path):
    # Replace single backslashes with forward slashes
    formatted_path = file_path.replace('\\', '/')
    # No single quotes around the file path
    return f"\\begin{{figure}}[h!]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{{{formatted_path}}}\n\\end{{figure}}"


def process_file(file_path):
    extension = os.path.splitext(file_path)[1]
    if extension == '.txt':
        return process_text_file(file_path)
    elif extension == '.tex':
        return process_latex_file(file_path)
    elif extension == '.png':
        return process_image_file(file_path)
    else:
        return ""

def create_latex_document(directory):
    all_files = os.listdir(directory)
    content_files = [f for f in all_files if is_valid_content_file(f) and os.path.isfile(os.path.join(directory, f))]
    sorted_files = sort_files(content_files)
    document = "\\documentclass[a5paper]{book}\n\\usepackage[utf8]{inputenc}\n\\usepackage{graphicx}\n\\begin{document}\n"
    for file in sorted_files:
        file_path = os.path.join(directory, file)
        document += process_file(file_path) + "\n\n"
    document += "\\end{document}"
    return document

def write_to_file(file_name, content):
    with open(file_name, 'w') as file:
        file.write(content)

def compile_pdf(latex_file):
    pdflatex_command = 'C:/texlive/2023/bin/windows/pdflatex.exe'  # or the full path to pdflatex if it's not in your PATH
    try:
        subprocess.run([pdflatex_command, latex_file])
    except Exception as e:
        print(f"An error occurred: {e}")


def main():
    directory = 'D:/PhD/TextbookMathematics'  # Update with the path to your content directory
    docu = 'D:/PhD/TextbookMathematics'
    latex_document = create_latex_document(docu)
    latex_file_name = 'D:/PhD/TextbookMathematics/1000000.tex'
    write_to_file(latex_file_name, latex_document)
    compile_pdf(latex_file_name)

if __name__ == "__main__":
    main()


----- Content of generate_setupCommandMatrix.py -----
# Create the 'instructionSet.txt' file
with open('instructionSet.txt', 'w') as f:
    # Lines 1 to 13107: string_var# = input('Enter string_var: ')
    for i in range(13107):
        f.write(f"string_var{i} = input('Enter string_var: ')\n")
    
    # Lines 13108 to 26214: var_given# = input('Enter the variable name to be used: ')
    for i in range(13107, 26214):
        f.write(f"var_given{i} = input('Enter the variable name to be used: ')\n")
    
    # Lines 26215 to 39321: var_glob# = globals()[var_given#]
    for i in range(26214, 39321):
        f.write(f"var_glob{i} = globals().get(var_given{i}, 'Variable not found')  # Error handling: 'Variable not found'\n")
    
    # Lines 39322 to 52428: exec(var_glob#)
    for i in range(39321, 52428):
        f.write(f"if isinstance(var_glob{i}, str): exec(var_glob{i})  # Error handling: Execute only if it's a string\n")
    
    # Lines 52429 to 65535: eval(var_glob#)
    for i in range(52428, 65535):
        f.write(f"if isinstance(var_glob{i}, str): result = eval(var_glob{i})  # Error handling: Evaluate only if it's a string\n")
    
    # Line 65536: Hyperlink
    f.write("webbrowser.open('https://example.com')  # Opens hyperlink to this site\n")

# Note: For logging, you can add a line to write the executed or evaluated command to a log file.
# Note: For user authentication, you can add a line to check user credentials before executing or evaluating a command.


----- Content of Generate_valid_fileLengths.py -----
import math

count = 1
e = 12
n = 4
s = 2
p = 0

def is_square(n):
    if(n//2 == 0 or n//3 == 0 or n//4 == 0 or math.sqrt(n).is_integer()):
        return True
    return False

#h = int(input("Enter the character length of your file: "))
while count <= 1000000:
    
    b = ((e // n == 1) or (e / n == 3) or (e // n == 2)) or (e // n != 0) is True

    c1 = int(e/4)
    c2 = (c1)
    c3 = e - c1
    c4 = int(c3/3)
    c5 = e - (c1 + c4)
    c6 = int(c5/2)
    c7 = e - (c1 + c4 + c6)
    c8 = int(c7/1)
    c9 = c8 + c6 + c4 + c1
    
    ht = is_square(c9)
    hg = is_square(c9**(1/2))
    nulle = e
    v1 = (((e/n) + 1)**(1/2)) - ((e/n) + 1)**(1/2)
    #vx = ( (v1 == 0) or (v1 == 1) or (v1 == 2) or (v1 == 3) ) is True
    ex = c9**(1/2)*4
    if(b and (ht and hg)):
        print(f"The square {c9} of hash length {c9**(1/2)} corresponding to file length {ex - 0 - 3}, {ex - 1 - 3}, {ex - 2 - 3} or {ex - 3 - 3} including null ... is hashable")

        
    count += 1
    e += 1


----- Content of gfa.py -----
class FiniteAutomaton:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):
        self.states = states
        self.alphabet = alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.accept_states = accept_states
        self.current_state = start_state

    def define_transitions(self):
        for state in self.states:
            self.transitions[state] = {}
            for symbol in self.alphabet:
                while True:
                    next_state = input(f"From state '{state}' on input '{symbol}', enter next state (e.g., q0, q1,...): ")
                    if next_state in self.states:
                        self.transitions[state][symbol] = next_state
                        break
                    else:
                        print("Invalid state entered. Please try again, use format 'q<number>'.")

    def process_input(self, input_string):
        # Adjusting for double-barrelled input strings
        if len(input_string) % 2 != 0 or len(input_string) > 24:
            return "Input string is not properly formatted or too long (maximum 12 symbols)"

        symbols = [input_string[i:i+2] for i in range(0, len(input_string), 2)]  # Splitting into symbols
        
        for symbol in symbols:
            if symbol not in self.alphabet:
                return "Invalid input symbol"
            if symbol in self.transitions[self.current_state]:
                next_state = self.transitions[self.current_state][symbol]
                self.current_state = next_state
            else:
                return "Input string rejected due to missing transition"

        return "Input string accepted" if self.current_state in self.accept_states else "Input string rejected"

while True:
    yi = input("Continue? 1 (for yes) 2 (for no): ")
    if yi == '1':
        while True:
            try:
                u_states = int(input("Enter number of states (1 to 12): "))
                if not 1 <= u_states <= 12:
                    raise ValueError
                break
            except ValueError:
                print("Invalid input. Please enter a number between 1 and 12.")

        while True:
            try:
                low_a = int(input("Enter lower range of the alphabet (0 to 11): "))
                high_a = int(input("Enter higher range of the alphabet (0 to 11): "))
                if not 0 <= low_a <= 11 or not 0 <= high_a <= 11 or low_a > high_a:
                    raise ValueError
                break
            except ValueError:
                print("Invalid range. Please enter numbers between 0 and 11 with lower <= higher.")

        # Alphabet is defined to include symbols as two-digit strings
        u_alphabet = [f"{i:02}" for i in range(low_a, high_a + 1)]
        states = [f"q{i}" for i in range(u_states)]

        my_fa = FiniteAutomaton(states, u_alphabet, {}, "q0", [])
        my_fa.define_transitions()

        while True:
            start_state = input(f"Choose a start state from {states}: ")
            if start_state in states:
                break
            else:
                print("Invalid start state. Please choose from the listed states.")

        while True:
            accept_states_input = input(f"Enter accept states from {states} (comma-separated): ")
            accept_states = accept_states_input.split(",")
            if all(state in states for state in accept_states):
                break
            else:
                print("Invalid accept states. Please ensure all states are from the listed states.")

        my_fa.start_state = start_state
        my_fa.current_state = start_state
        my_fa.accept_states = accept_states

        input_string = input("Enter an input string: ")
        result = my_fa.process_input(input_string)
        print(result)
        
    elif yi == '2':
        break
    else:
        print("Invalid input, please enter 1 (yes) or 2 (no)")


----- Content of GOSm7.py -----
import tkinter as tk
import random
from PIL import ImageGrab
import pickle
from tkinter import simpledialog
import os
from tkinter import Menu, Checkbutton, BooleanVar
from tkinter.colorchooser import askcolor
import logging
import time
import json
import os
import pyautogui
import keyboard


current_col = 0
current_row = 0
            
def get_random_color():
    r = lambda: random.randint(0,255)
    return '#%02X%02X%02X' % (r(),r(),r())

def get_random_char():
    random_int = random.randint(0x0021, 0x007E)
    return chr(random_int)

def draw_grid():
    for i in range(grid_size):
        for j in range(grid_size):
            color = get_random_color()
            square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
            char = get_random_char()
            text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", 18), anchor="center")


def draw_grid_IDE():
    global col
    try:
        for i in range(grid_size):
            for j in range(grid_size):
                color = "blue"
                square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color, outline = "white")
        if typing_mode:
            # In the function where you create the canvas...
            canvas.bind("<Key>", on_key_press)
            canvas.focus_set()
    except:
        print("Submit an app mode ...")


def toggle_color_mode():
    """Toggles between manual color mode and random color mode"""
    global color_mode_var
    color_mode_var.set(not color_mode_var.get())

font_size = 9

def draw_char1(canvas, char, row, col, font_size, color):
    global cell_size, font_color, square_size, grid_size, last_drawn, note, char_note

    '''
    def draw_char1(canvas, char, row, col, font_size):
    
    Draws a character on the Tkinter canvas at the specified row and column with the specified font size.
    
    Parameters:
    canvas (tk.Canvas): The Tkinter canvas to draw on.
    char (str): The character to draw.
    row (int): The row to draw the character at.
    col (int): The column to draw the character at.
    font_size (int): The font size to use for the character.
    
    '''


    try:
        x = col * square_size + square_size / 2
        y = row * square_size + square_size / 2
        
        print(f"Drawing char '{char}' at ({x}, {y})")  # Debug print to check coordinates
        canvas.create_rectangle(col * square_size, row * square_size, (col+1) * square_size, (row+1) * square_size, fill=color)
        canvas.create_text(x, y, text=char, fill=font_color, font=('Calibri', int(font_size)))
        note = char_note.get()
        # Log the color and character info
        logging.info(f"Position:'{x};{y}',Xp:'{x}',Yp:'{y}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{x},{y},{char},{color},{font_color},{note}", file=login)

    except Exception as e:
        print(f"Something Went Wrong... Error: {e}")



def draw_char(i=None, j=None):
    try:
        """Draws a character from input field in a specific square"""
        global char_count, IDE_mode, typing_mode, last_drawn, font_color
        if(mode == 'IDE'):
            IDE_mode = True
        # Check if last_drawn is defined, otherwise define it
        if 'last_drawn' not in globals():
            last_drawn = []

        # If i, j are not provided, calculate them based on char_count
        if i is None or j is None:
            i, j = divmod(char_count, grid_size)
            # Handle out-of-grid situations
            if i >= grid_size or j >= grid_size:
                print('Out of grid!')
                return

        # Generate a random color if not in typing mode, white otherwise
        ##color = get_random_color() if not typing_mode else "white"

        # Check color mode
        if color_mode_var.get():
            # Manual color mode
            # Show a color picker and get the chosen color for the square
            color = askcolor(title="Choose square color")[1]

            # Ask for the font color
            color_result = askcolor(title="Choose font color")
            if color_result is not None:
                font_color = color_result[1]
            else:
                # Handle the case when the user cancelled the color selection
                font_color = "#000000"  # default to black, for example


        else:
            # Random color mode
            color = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            color1 = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            font_color = color1 #"#000000"


        square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
        char = char_entry.get()[:1]
        note = char_note.get()
        text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", font_size), fill=font_color, anchor="center")

        '''
        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}'")
        # Log the color and character info in a text file
        with open("color_log.txt", "a") as login:
            print(f"{i},{j},{char},{color},{font_color}", file=login)
        '''

        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{i},{j},{char},{color},{font_color},{note}", file=login)

        
        if len(char_entry.get()) > 0:  # Check if there's more than one character
            char_entry.delete(0, 1)  # Delete the first character

        last_drawn.append((square, text))

        if not IDE_mode:
            char_count = (char_count + 1) % (grid_size * grid_size)
            if char_count == 0:  # If we've filled the canvas, clear it
                canvas.delete('all')

        return square, text
    except:
        print("Submit an app mode ...")


def adjust_grid_and_font():
    global grid_size, square_size, font_size, canvas_width, current_row, current_col

    n_g_s = simpledialog.askstring("Change Grid Size (Grid Width)", "Enter New Grid Size (+Integer):")
    if(n_g_s != ''):
        new_grid_size = n_g_s
    n_f_s = simpledialog.askstring("Change Font Size (Default = 9)", "Enter New Font Size (+Integer):")
    if(n_f_s != ''):
        new_font_size = n_f_s
        # Update the global variables
    if(new_grid_size==None and new_font_size==None):
        grid_size = 10
        font_size = 9
    if((not new_grid_size==None) and (not new_font_size==None)):
        try: 
            grid_size = int(new_grid_size)
            square_size = canvas_width / grid_size
            font_size = int(new_font_size)
        except:
            print("positive integers please")
        
    '''
    # Get new values from input fields
    new_grid_size = grid_size_entry.get()
    new_font_size = font_size_entry.get()
    
    # Update the global variables
    grid_size = int(new_grid_size)
    square_size = canvas_width // grid_size
    font_size = int(new_font_size)
    '''

    # Redraw the grid
    refresh_canvas()
    qit = input("Are you in typing mode, or want to enter typing mode? 1 for (No), 2 for (yes): ")
    if(qit == '2'):
        current_row = 0
        current_col = 0
        show_typing_mode_menu()

def refresh_canvas():
    """Clears the canvas and resets the char_count"""
    global char_count
    canvas.delete('all')
    char_count = 0
    draw_grid_IDE()
    last_drawn.clear()

def undo_last():
    """Undoes the last drawing operation"""
    if last_drawn:
        square, text = last_drawn.pop()
        canvas.delete(square)
        canvas.delete(text)

def update_canvas():
    if not paused.get():
        canvas.delete('all')
        draw_grid()
    root.after(8000, update_canvas)

def toggle_typing_mode():
    global typing_mode, canvas

    typing_mode = not typing_mode
    if typing_mode:
        canvas.focus_set()  # Set focus to the canvas for keyboard input



def on_canvas_click(event):
    try:
        global mode, typing_mode
        if mode == 'IDE' and not typing_mode:
            j = event.x // square_size
            i = event.y // square_size
            draw_char(i, j)
        else:
            paused.set(not paused.get())
    except:
        print("Submit an app mode ...")

def on_key_press(event):
    global char_count, typing_mode
    if typing_mode:
        char_entry.delete(0, 'end')  # Clear the entry box
        try:
            utf8_char = event.char.encode('utf-8').decode('utf-8')
            char_entry.insert(0, utf8_char)  # Insert the typed character
        except UnicodeDecodeError:
            print("Non UTF-8 character detected")
            return
        draw_char()  # Draw the character
        char_count += 1  # Increment the count

        # If char_count exceeds the total number of squares in the grid, reset it
        if char_count >= grid_size ** 2:
            char_count = 0




def submit_mode():

    global char_count, mode, typing_mode
    
    mode = mode_entry.get().upper()
    
    '''
    if mode in ['editor']:

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        draw_grid()
        char_label.pack()
        char_entry.pack()
        char_button.pack()

    '''    
        
    # Draw the initial grid
    if(mode != 'IDE'):
        print("A valid mode ...")

    '''
    if(mode == 'normal'):

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()

        draw_grid()
        create_menu_1()

    if mode == 'normal':
        # Schedule the first update
        root.after(8000, update_canvas)
    '''
    
    if mode == 'IDE':

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        char_count = 0
        draw_grid_IDE()
        
        control_frame.pack()
        char_label.pack()
        char_entry.pack()
        #grid_size_label.pack()
        #grid_size_entry.pack()
        #font_size_label.pack()
        #font_size_entry.pack()
        #adjust_button.pack()
        char_note_label.pack()
        char_note.pack()
        #refresh_button.pack(side="left")
        #undo_button.pack(side="left")
        #save_button = tk.Button(root, text='Save', command=save_canvas, bg="white", padx=5, pady=0)
        #save_button.pack(side="left")
        #save_Sbutton.pack(side="left")
        #load_button.pack(side="left")
        create_menu()


    return mode



def save_canvas():
    global IC_value, xSwitch, ing
    xSwitch = 1
    ing = 1
    if(ing == 0):
        ing = 2
    ing = 1
    if(xSwitch == 1 and ing == 1):
        IC_value = 0
        ing = 0
    """Save the current state of the canvas to a .png file"""
    #filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    filename = f"ImageCanvas{IC_value}_rename"
    
    if filename:  # Only save the canvas if a filename was entered
        # Get the bounding box of the canvas
        x = root.winfo_rootx() + canvas.winfo_x()
        y = root.winfo_rooty() + canvas.winfo_y()
        x1 = x + canvas.winfo_width()
        y1 = y + canvas.winfo_height()
        time.sleep(3)
        # Grab the image, crop it to the bounding box, and save it
        ImageGrab.grab().crop((x, y, x1, y1)).save(filename + ".png")


def save_session():
    """Save the current session to a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Save Session", "Enter filename:")
    if filename:  # Only save the session if a filename was entered
        session_data = [(canvas.coords(square), canvas.itemcget(square, "fill"),
                        canvas.coords(text), canvas.itemcget(text, "text"), canvas.itemcget(text, "fill"))
                        for square, text in last_drawn]
        with open(filename + ".pkl", "wb") as f:
            pickle.dump(session_data, f)


def load_session():
    """Load a saved session from a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Load Session", "Enter filename:")
    if filename:  # Only try to load a session if a filename was entered
        try:
            with open(filename + ".pkl", "rb") as f:
                session_data = pickle.load(f)
                # Clear the canvas and redraw all elements from the loaded session
                canvas.delete('all')
                draw_grid_IDE()
                last_drawn = []
                for square_coords, square_fill, text_coords, text_content, text_fill in session_data:
                    square = canvas.create_rectangle(*square_coords, fill=square_fill)
                    text = canvas.create_text(*text_coords, text=text_content, fill=text_fill, font=("Arial", font_size), anchor="center")
                    last_drawn.append((square, text))
        except FileNotFoundError:
            print(f"No session named '{filename}' found.")

#def exit_app():
#    exit()

def show_about():
    about_window = tk.Toplevel(root)
    about_window.title("About")
    about_msg = "This is a program created to learn and experiment with Tkinter. In IDE mode, you can draw characters on a grid (By typing or copying and pasting then clicking the squares you want to draw each character on), adjust the grid and font size, save and load sessions, and more, like saving the grid as an image (For example). C(num) was written with the aid of Chat GPT. Enjoy!\n\nNote: the workflow ... IDE to color_log.txt (Compiled by compile#.exe or compile#.py);\nindex_1.txt contains fields of study or research and development and\nindex_2.txt contains fields of study or research and development also ...\n\nBertotools Digital"
    tk.Message(about_window, text=about_msg, width=500).pack()
    tk.Button(about_window, text="OK", command=about_window.destroy).pack()

def compileGOSmX():
    MAX_LINE_LENGTH = 256
    MAX_TOPICS = 256

    global index_1, index_2
    
    index_1 = [
        "Axiom",
        "Theorem",
        "Lemma",
        "Proposition",
        "Corollary",
        "Conjecture",
        "Proof",
        "Premise",
        "Conclusion",
        "Hypothesis",
        "Counterexample",
        "Direct Proof",
        "Indirect Proof",
        "Proof by Contradiction (Reductio ad absurdum)",
        "Proof by Induction",
        "Proof by Contrapositive",
        "Deductive Reasoning",
        "Inference",
        "Assumption",
        "Statement",
        "Postulate",
        "Proof by Exhaustion",
        "Syllogism",
        "Constructive Proof",
        "Non-Constructive Proof",
        "Trivial Proof",
        "Vacuous Proof",
        "Biconditional",
        "Condition",
        "Sufficiency",
        "Necessity",
        "Quantifier",
        "Universal Quantifier",
        "Existential Quantifier",
        "Bound Variable",
        "Free Variable",
        "Predicate",
        "Propositional Logic",
        "Modus Ponens",
        "Modus Tollens",
        "Discrete Mathematics",
        "Set Theory",
        "Function",
        "Bijection",
        "Injection",
        "Surjection",
        "Equivalence Relation",
        "Partial Order",
        "Total Order",
        "Well-Order",
        "Reflexivity",
        "Symmetry",
        "Transitivity",
        "Antisymmetry",
        "Completeness",
        "Compactness",
        "Connectedness",
        "Convergence",
        "Divergence",
        "Limit",
        "Sequence",
        "Series",
        "Monotonicity",
        "Cauchy Sequence",
        "Infinite Set",
        "Finite Set",
        "Cardinality",
        "Countable Set",
        "Uncountable Set",
        "Subset",
        "Superset",
        "Intersection",
        "Union",
        "Empty Set",
        "Power Set",
        "Cartesian Product",
        "Equivalence Class",
        "Partition",
        "Field",
        "Ring",
        "Group",
        "Abelian Group",
        "Non-abelian Group",
        "Matrix",
        "Vector Space",
        "Linear Transformation",
        "Eigenvalue",
        "Eigenvector",
        "Norm",
        "Inner Product",
        "Orthogonality",
        "Basis",
        "Dimension",
        "Rank",
        "Nullity",
        "Determinant",
        "Graph Theory",
        "Vertex",
        "Edge",
        "Connectivity",
        "Cycle",
        "Path",
        "Degree",
        "Subgraph",
        "Tree",
        "Forest",
        "Planar Graph",
        "Bipartite Graph",
        "Directed Graph (Digraph)",
        "Eulerian Graph",
        "Hamiltonian Graph",
        "Adjacency Matrix",
        "Incidence Matrix",
        "Isomorphism",
        "Homeomorphism",
        "Topology",
        "Open Set",
        "Closed Set",
        "Boundary",
        "Compact Space",
        "Hausdorff Space",
        "Continuity",
        "Differential",
        "Derivative",
        "Integral",
        "Partial Derivative",
        "Multivariable Calculus",
        "Laplace Transform",
        "Fourier Transform",
        "Taylor Series",
        "Maclaurin Series",
        "Conic Sections",
        "Hyperbola",
        "Ellipse",
        "Parabola",
        "Asymptote",
        "Limits at Infinity",
        "Complex Number",
        "Imaginary Unit",
        "Real Number",
        "Rational Number",
        "Irrational Number",
        "Prime Number",
        "Composite Number",
        "GCD (Greatest Common Divisor)",
        "LCM (Least Common Multiple)",
        "Permutation",
        "Combination",
        "Probability",
        "Statistics",
        "Expected Value",
        "Variance",
        "Standard Deviation",
        "Normal Distribution",
        "Poisson Distribution",
        "Binomial Distribution",
        "Hypothesis Testing",
        "Regression",
        "Correlation",
        "Matrix Algebra",
        "Linear Algebra",
        "Vector Calculus",
        "Optimization",
        "Algorithm",
        "Computational Complexity",
        "Big O Notation",
        "Pigeonhole Principle",
        "Principle of Inclusion-Exclusion",
        "Turing Machine",
        "Computability",
        "Unsolvability",
        "Parity",
        "Diophantine Equations",
        "Cryptography",
        "Fermat's Last Theorem",
        "Pythagorean Theorem",
        "Triangle Inequality",
        "Trigonometric Functions",
        "Trigonometric Identities",
        "Polar Coordinates",
        "Euler's Formula",
        "Riemann Zeta Function",
        "P vs NP Problem",
        "NP-complete Problem",
        "Stochastic Process",
        "Markov Chain",
        "Random Variable",
        "Conditional Probability",
        "Bayes' Theorem",
        "Monte Carlo Method",
        "Fractal",
        "Chaos Theory",
        "Game Theory",
        "Nash Equilibrium",
        "Zero-Sum Game",
        "Non-Zero-Sum Game",
        "Linear Programming",
        "Nonlinear Programming",
        "Quadratic Programming",
        "Dynamic Programming",
        "Integer Programming",
        "Graph Coloring",
        "Network Flow",
        "Spanning Tree",
        "Bellman-Ford Algorithm",
        "Dijkstra's Algorithm",
        "Kruskal's Algorithm",
        "Prim's Algorithm",
        "Floyd-Warshall Algorithm",
        "Euler's Method",
        "Runge-Kutta Method",
        "Numerical Integration",
        "Numerical Differentiation",
        "Bisection Method",
        "Newton's Method",
        "Secant Method",
        "Fixed Point Iteration",
        "Linear Interpolation",
        "Polynomial Interpolation",
        "Lagrange Interpolation",
        "Splines",
        "Fourier Series",
        "Laplace's Equation",
        "Heat Equation",
        "Wave Equation",
        "Schrodinger Equation",
        "Ordinary Differential Equation (ODE)",
        "Partial Differential Equation (PDE)",
        "Boundary Value Problem",
        "Initial Value Problem",
        "Green's Theorem",
        "Stoke's Theorem",
        "Divergence Theorem",
        "Curl",
        "Gradient",
        "Divergence",
        "Tensor",
        "Manifold",
        "Topological Space",
        "Measure Theory",
        "Lebesgue Integral",
        "Borel Set",
        "Hilbert Space",
        "Banach Space",
        "Category Theory",
        "Functor",
        "Natural Transformation",
        "Sheaf",
        "Homotopy",
        "Homology",
        "Cohomology",
        "Galois Theory",
        "Algebraic Geometry",
        "Topological K-Theory",
        "Knot Theory",
        "Lattice Theory"
    ]

    index_2 = [
        "Biochemistry",
        "Biophysics",
        "Molecular biology",
        "Genetics",
        "Immunology",
        "Cell biology",
        "Microbiology",
        "Neuroscience",
        "Pharmacology",
        "Bioinformatics",
        "Biotechnology",
        "Proteomics",
        "Genomics",
        "Structural biology",
        "Virology",
        "Systems biology",
        "Developmental biology",
        "Evolutionary biology",
        "Synthetic biology",
        "Metabolomics",
        "Epigenetics",
        "Tissue engineering",
        "Nanotechnology",
        "Materials science",
        "Quantum physics",
        "Condensed matter physics",
        "Particle physics",
        "Astrophysics",
        "Cosmology",
        "Optics",
        "Atomic and molecular physics",
        "Fluid mechanics",
        "Thermodynamics",
        "Environmental science",
        "Climate science",
        "Geology",
        "Oceanography",
        "Atmospheric science",
        "Ecology",
        "Conservation biology",
        "Botany",
        "Zoology",
        "Entomology",
        "Marine biology",
        "Paleontology",
        "Anthropology",
        "Archaeology",
        "Psychology",
        "Cognitive science",
        "Social psychology",
        "Linguistics",
        "Artificial intelligence",
        "Machine learning",
        "Computer vision",
        "Natural language processing",
        "Human-computer interaction",
        "Robotics",
        "Computer graphics",
        "Data science",
        "Mathematical modeling",
        "Mathematical physics",
        "Number theory",
        "Algebraic geometry",
        "Differential equations",
        "Computational physics",
        "Mathematical biology",
        "Operations research",
        "Biostatistics",
        "Epidemiology",
        "Cancer research",
        "Diabetes research",
        "Heart disease research",
        "Infectious diseases research",
        "Immunotherapy",
        "Stem cell research",
        "Gene therapy",
        "Drug discovery",
        "Precision medicine",
        "Health informatics",
        "Renewable energy",
        "Energy storage",
        "Sustainable materials",
        "Environmental engineering",
        "Water management",
        "Transportation engineering",
        "Civil engineering",
        "Chemical engineering",
        "Aerospace engineering",
        "Biomedical engineering",
        "Electrical engineering",
        "Mechanical engineering",
        "Robotics engineering",
        "Quantum computing",
        "Cryptography",
        "Cybersecurity",
        "Network engineering",
        "Telecommunications",
        "Human genetics",
        "Forensic science",
        "Space exploration and research",
        "Planetary science",
        "Astrobiology",
        "Astrochemistry",
        "Astrogeology",
        "Astroinformatics",
        "Exoplanet research",
        "Stellar evolution",
        "Galactic astronomy",
        "Observational astronomy",
        "Computational astrophysics",
        "Quantum chemistry",
        "Computational chemistry",
        "Organic chemistry",
        "Inorganic chemistry",
        "Physical chemistry",
        "Environmental chemistry",
        "Analytical chemistry",
        "Agricultural science",
        "Food science",
        "Nutritional science",
        "Exercise physiology",
        "Sports science",
        "Biomechanics",
        "Plant physiology",
        "Plant genetics",
        "Plant pathology",
        "Soil science",
        "Hydrology",
        "Geochemistry",
        "Geophysics",
        "Geomorphology",
        "Remote sensing",
        "Geotechnical engineering",
        "Petroleum engineering",
        "Aerospace materials",
        "Nanomaterials",
        "Polymer science",
        "Computational materials science",
        "Photonics",
        "Physical optics",
        "Quantum optics",
        "Neuroengineering",
        "Brain imaging",
        "Cognitive neuroscience",
        "Neuroinformatics",
        "Psychophysics",
        "Developmental psychology",
        "Personality psychology",
        "Clinical psychology",
        "Industrial-organizational psychology",
        "Educational psychology",
        "Psycholinguistics",
        "Human genetics",
        "Evolutionary genetics",
        "Population genetics",
        "Genetic engineering",
        "Genetic counseling",
        "Epigenomics",
        "Cardiovascular research",
        "Respiratory research",
        "Gastroenterology research",
        "Endocrinology research",
        "Nephrology research",
        "Hematology research",
        "Ophthalmology research",
        "Orthopedic research",
        "Dermatology research",
        "Veterinary medicine",
        "Animal behavior",
        "Conservation ecology",
        "Wildlife biology",
        "Environmental microbiology",
        "Agricultural economics",
        "Development economics",
        "Behavioral economics",
        "Econometrics",
        "Financial mathematics",
        "Operations management",
        "Supply chain management",
        "Industrial engineering",
        "Human-computer interaction",
        "Virtual reality",
        "Augmented reality",
        "Data mining",
        "Text mining",
        "Big data analytics",
        "Computational linguistics",
        "Quantum information science",
        "Quantum cryptography",
        "Biometrics",
        "Information retrieval",
        "Software engineering",
        "Computer networks",
        "Embedded systems",
        "Human-robot interaction",
        "Control systems",
        "Biopharmaceuticals",
        "Drug delivery systems",
        "Clinical trials",
        "Regenerative medicine",
        "Agricultural biotechnology",
        "Plant breeding",
        "Animal breeding",
        "Food technology",
        "Sensory science",
        "Poultry science",
        "Aquaculture",
        "Marine ecology",
        "Limnology",
        "Population ecology",
        "Landscape ecology",
        "Evolutionary ecology",
        "Environmental toxicology",
        "Environmental chemistry",
        "Environmental microbiology",
        "Ecotoxicology",
        "Green chemistry",
        "Space physics",
        "Space weather",
        "Astrostatistics",
        "Computational fluid dynamics",
        "Mathematical optimization",
        "Operations research",
        "Human genetics",
        "Functional genomics",
        "Molecular genetics",
        "Cancer genetics",
        "Psychiatric genetics",
        "Population genomics",
        "Bioengineering",
        "Biomaterials",
        "Biomechatronics",
        "Cardiovascular engineering",
        "Neural engineering",
        "Rehabilitation engineering",
        "Genetic engineering",
        "Environmental engineering",
        "Water resources engineering",
        "Structural engineering",
        "Robotics engineering",
        "Quantum information theory",
        "Quantum simulation",
        "Quantum sensing",
        "Geographical information systems (GIS)",
        "Urban planning",
        "Renewable energy systems",
        "Solar cell technology",
        "Wind energy research",
        "Energy policy and economics",
        "Computational neuroscience",
        "Neurobiology",
        "Cognitive neuroscience",
        "Systems neuroscience",
        "Human-robot interaction",
        "Evolutionary psychology",
        "Social network analysis"
    ]



    def square_print_topic_indices(r_value, g_value, b_value, file):
        index1 = r_value % len(index_1)
        index2 = g_value % len(index_1)
        index3 = b_value % len(index_1)
        '''
        file.write(f"\t\t\t{topics[index1]}\n")
        file.write(f"\t\t\t{topics[index2]}\n")
        file.write(f"\t\t\t{topics[index3]}\n")
        '''
        file.write(f"\t\t\t{index_1[index1]}\n")
        file.write(f"\t\t\t{index_1[index2]}\n")
        file.write(f"\t\t\t{index_1[index3]}\n")
                
        squareRatio = str(index1) + ":" + str(index2) + ":" + str(index3)
        return squareRatio

    def font_print_topic_indices(r_value, g_value, b_value, file):
        index1_ = r_value % len(index_2)
        index2_ = g_value % len(index_2)
        index3_ = b_value % len(index_2)
        file.write(f"\t\t\t{index_2[index1_]}\n")
        file.write(f"\t\t\t{index_2[index2_]}\n")
        file.write(f"\t\t\t{index_2[index3_]}\n")

        fontRatio = str(index1_) + ":" + str(index2_) + ":" + str(index3_)
        return fontRatio



    def get_index(i, j, grid_size):
        return i * grid_size + j

    def extract_rgb_values(color):
        if len(color) != 7 or color[0] != '#':
            raise ValueError('Input should be a hex color code in the format "#RRGGBB"')
        try:
            red = int(color[1:3], 16)
            green = int(color[3:5], 16)
            blue = int(color[5:7], 16)
            return red, green, blue
        except ValueError:
            raise ValueError('Invalid color code. RGB values should be hex digits (0-9, A-F)')


    def GO():
        log_file = "color_log.txt"
##        topic_file = "index_1.txt"
##        topic2_file = "index_2.txt"  # Corrected this line to read from a different file
        gridWidth = int(input("Enter gridWidth: "))
        # Read topic files to get the topics and topic2s
##        with open(topic_file, "r", encoding='utf8') as file:
##            topics = [line.strip() for line in file]
##
##        with open(topic2_file, "r", encoding='utf8') as file:
##            topic2s = [line.strip() for line in file]

        numTopics = len(index_1)
        numTopic2s = len(index_2)

        # Read color log file
        with open(log_file, "r") as file:
            lines = file.readlines()

        lineNumber = 0
        # Save output to a file
        output_file = "output.txt"
        with open(output_file, "w") as file:
            print()
        for line in lines:
            parts = line.strip().split(",")
            if len(parts) >= 5:
                xcoor = int(parts[1])
                ycoor = int(parts[0])
                index_ = (gridWidth * ycoor) + xcoor
                character = parts[2]
                squareColor = parts[3]
                fontColor = parts[4]
                notes = parts[5]

                # Extract RGB values from squareColor
                red, green, blue = extract_rgb_values(squareColor)

                # Extract RGB values from fontColor
                fontRed, fontGreen, fontBlue = extract_rgb_values(fontColor)

                # Calculate the grid size
                grid_size = int(parts[0])

                # Select topics based on RGB values from squareColor
                topicIndices = [(red + get_index(i, j, grid_size)) % numTopics for i in range(grid_size) for j in range(grid_size)]
                
                lineNumber += 1

                
                with open(output_file, "a") as file:
                    file.write(f"Compiling Line/s: {lineNumber}\n\n")
                    file.write(f"Line({lineNumber})\n\n")
                    file.write(f"0\tLineNumber: {lineNumber}\tx-coordinate: {xcoor}\ty-coordinate: {ycoor}\t Character: {character}\tRGB: {squareColor}\tRGB: {fontColor}\t Note: {notes}\t GridDimensions: {gridWidth}x{gridWidth}\n\n")
                    #print(topicIndices)
                    file.write(f"Line/s({lineNumber}) Output:\n\n")
                    file.write(f"#define Line({lineNumber}){{\n\n")
                    # Inside the main function
                    file.write(f"\ti_1_0(squareColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {red}, G: {green}, B: {blue})\n")
                    s_ratio = square_print_topic_indices(red, green, blue, file)
                    #square_print_topic_indices(red, green, blue, topics, file)   # Modify this line
                    file.write("\t\t)\n")
                    file.write("\t};\n\n")
                    file.write(f"\ti_1_1(fontColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {fontRed}, G: {fontGreen}, B: {fontBlue})\n")
                    f_ratio = font_print_topic_indices(fontRed, fontGreen, fontBlue, file)
                    #font_print_topic_indices(fontRed, fontGreen, fontBlue, topic2s, file)   # And this line
                    file.write("\t\t)\n")
                    file.write(f"\treturn squareRatio({s_ratio}), fontRatio({f_ratio}), sqaureIndex({index_})\n")
                    #file.write(f"\treturn fontRatio({f_ratio})\n")
                    file.write("}\n\n")


    GO()


def create_menu():
    global control_frame
    def home():
        canvas.pack_forget()
        menubar.destroy()
        control_frame.pack()
        char_entry.pack_forget()
        char_label.pack_forget()
        #grid_size_label.pack_forget()
        #grid_size_entry.pack_forget()
        #font_size_label.pack_forget()
        #font_size_entry.pack_forget()
        #adjust_button.pack_forget()
        char_note.pack_forget()
        char_note_label.pack_forget()

        root.destroy()
        switch = 1
        setup_mode(switch)
    
    # Create a menubar
    menubar = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu = tk.Menu(menubar, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="Toggle Manual/Random Colour", command=manual_colour)

    dropdown.add_command(label="Refresh", command=refresh_canvas)
    dropdown.add_command(label="Undo", command=undo_last)
    dropdown.add_command(label="Save Session", command=save_session)
    dropdown.add_command(label="Load Session", command=load_session)
    dropdown.add_command(label="Save as Image", command=save_canvas)
    dropdown.add_command(label="Compile Canvas", command=compileGOSmX)
    #dropdown.add_command(label="Exit", command=exit_app)
    #dropdown.add_command(label="Toggle Type/Click Mode", command=toggle_typing_mode)
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Go Home", command=home)
    dropdown.add_command(label="Edit Grid Dimensions", command=adjust_grid_and_font)
    dropdown.add_command(label="Typing Mode", command=show_typing_mode_menu)


    # Set the menubar
    root.config(menu=menubar)

    

def create_menu_1():
    global control_frame
    def home1():
        canvas.pack_forget()
        menubar1.destroy()
        root.destroy()
        switch = 1
        setup_mode(switch)
        
    
    # Create a menubar
    menubar1 = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu1 = tk.Menu(menubar1, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar1, tearoff=0)
    menubar1.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Change Mode", command=home1)

    # Set the menubar
    root.config(menu=menubar1)


def manual_colour():
    # Toggle the value of color_mode_var
    current_value = color_mode_var.get()
    color_mode_var.set(not current_value)


'''
# Create a tkinter window
root = tk.Tk()
root.title("General Operating System")
root.iconbitmap("logo.ico")
'''

def show_typing_mode_menu():
    global color_
    while True:
        print("1. Use default UTF-8 mapping")
        print("4. Exit")
        choice = input("Choose an option: ")
        
        if choice == "1":
            # Use default UTF-8 mapping
            print("Using default UTF-8 mapping.")
            color_ = input("Use Default Colour Scheme (1): ")
            if(color_ == '1'):
                # Initialize bg_color and font_color with default values at the global scope
                bg_color = "#FFFFFF"  # Default white background color
                font_color = "#000000"  # Default black font color
                break
        else:
            print("Invalid choice. Please try again.")

    canvas.bind("<Key>", type_character)
    canvas.focus_set()





def set_background_color():
    global color
    #bg_color = tk.colorchooser.askcolor()[1]
    color = input("Enter background color (#FFFFFF for example):")
    
def set_font_color():
    global font_color, font_size
    #font_color = tk.colorchooser.askcolor()[1]
    font_color = input("Enter background color (#000000 for example): ")
    font_size = input("Enter font_size: ")


def type_character(event):
    global current_row, current_col, col, font_size, font_color, color, canvas_width, square_size
    color = "#FFFFFF"
    font_color = "#000000"
    char = event.char
    if char:  # Ignore non-character events
        try:
            
            draw_char1(canvas, char, current_row, current_col, font_size, color)
            current_col += 1
            if (current_col >= canvas_width/square_size):
                current_col = 0
                current_row += 1
            if(current_row >= canvas_width/square_size):
                current_col = 0
                current_row = 0
        except Exception as e:
            print("Something Went Wrong...")
            print(e)

        
        


def setup_mode(sw):

    global mode_entry, mode_label, square_size, grid_size, char_count, last_drawn
    global root, color_mode_var, logging, paused, canvas_width, canvas_height, canvas
    global grid_size_label, grid_size_entry, font_size_label, font_size_entry, adjust_button
    global save_Sbutton, load_button, char_label, char_entry, char_note_label, char_note, char_button
    global refresh_button, undo_button, control_frame, submit_button, col, color_


    current_row = 0
    current_col = 0
    color_ = 1
    
    # Define the size of the squares and the grid
    square_size = 70
    grid_size = 10
    char_count = 0
    last_drawn = []

    window_height = square_size * grid_size + (square_size * 2)
    window_width = square_size * grid_size
    

    if(sw == 1):
        # Create a tkinter window
        root = tk.Tk()
        root.title("C22")
        #root.iconbitmap("logo.ico")
        sw = 0
        switch = 0

    ###

    # Get screen width and height
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    # Calculate position of the window
    position_top = int(screen_height / 2 - window_height / 2)
    position_right = int(screen_width / 2 - window_width / 2)

    # Set the dimensions of the window and where it is placed
    root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')

    ###

    # Create a BooleanVar for the color mode and set it to False initially
    color_mode_var = BooleanVar(value=False)

    # Setup logging
    logging.basicConfig(filename='logging.txt', level=logging.INFO)

    paused = tk.BooleanVar()
    paused.set(False)

    canvas_width = grid_size * square_size
    canvas_height = grid_size * square_size
    canvas = tk.Canvas(root, width=canvas_width, height=canvas_height)
    col = canvas_width
    canvas.pack()
    canvas.bind("<Button-1>", on_canvas_click)
    
    # In the function where you create the canvas...
    canvas.bind("<Key>", on_key_press)
    canvas.focus_set()
    
    # Create input fields and buttons for grid and font size input
    grid_size_label = tk.Label(root, text="Grid size:")
    grid_size_entry = tk.Entry(root, width=5)
    font_size_label = tk.Label(root, text="Font size:")
    font_size_entry = tk.Entry(root, width=5)
    adjust_button = tk.Button(root, text='Adjust Grid & Font', command=adjust_grid_and_font)

    # Create the save and load buttons
    save_Sbutton = tk.Button(root, text='Save Session', command=save_session, bg="white", padx=5, pady=0)
    load_button = tk.Button(root, text='Load Session', command=load_session, bg="white", padx=5, pady=0)

    # Create input fields and buttons for mode and character input
    mode_label = tk.Label(root, text="Enter ... 'IDE' for an\nInteractive Development Environment\nfor Learning anything!")
    mode_entry = tk.Entry(root)
    submit_button = tk.Button(root, text='LEARN', command=submit_mode)


    '''
    filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    if filename:
    '''
    
    char_label = tk.Label(root, text="Enter symbol/s to draw: ")
    char_entry = tk.Entry(root, width=12)
    char_note_label = tk.Label(root, text="Enter Note: ")
    char_note = tk.Entry(root, width=12)
    #char_button = tk.Button(root, text='Draw Character', command=draw_char)

    refresh_button = tk.Button(root, text='Refresh', command=refresh_canvas, bg="white", padx=5, pady=0)
    undo_button = tk.Button(root, text='Undo', command=undo_last, bg="white", padx=5, pady=0)

    control_frame = tk.Frame(root)

    mode_label.pack()
    mode_entry.pack()
    submit_button.pack()
    # create_menu(root)

    # Run the tkinter main loop
    root.mainloop()

global switch
switch = 1

setup_mode(switch)


----- Content of GraphPlotter.py -----
import tkinter as tk
from tkinter import ttk, filedialog
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.lines import Line2D  # Import this at the top of your file


class PlotterApp:
    def __init__(self, master):
        self.master = master
        self.master.title("2D & 3D Graph Plotter")

        self.plot_mode = tk.StringVar(value="2D")

        self.frame_input = ttk.Frame(self.master, padding="10")
        self.frame_input.grid(row=0, column=0, sticky=(tk.W, tk.E))

        ttk.Label(self.frame_input, text="Function:").grid(row=0, column=0, sticky=tk.W)
        self.entry_function = ttk.Entry(self.frame_input, width=30)
        self.entry_function.grid(row=0, column=1)

        ttk.Label(self.frame_input, text="Label:").grid(row=1, column=0, sticky=tk.W)
        self.entry_label = ttk.Entry(self.frame_input, width=30)
        self.entry_label.grid(row=1, column=1)

        self.button_add = ttk.Button(self.frame_input, text="Add", command=self.add_function)
        self.button_add.grid(row=0, column=2, rowspan=2)

        self.button_plot = ttk.Button(self.frame_input, text="Plot All", command=self.plot_graph)
        self.button_plot.grid(row=0, column=3, rowspan=2)

        self.button_save = ttk.Button(self.frame_input, text="Save Plot", command=self.save_plot)
        self.button_save.grid(row=0, column=4, rowspan=2)

        self.radio_2d = ttk.Radiobutton(self.frame_input, text="2D", variable=self.plot_mode, value="2D")
        self.radio_2d.grid(row=0, column=5)

        self.radio_3d = ttk.Radiobutton(self.frame_input, text="3D", variable=self.plot_mode, value="3D")
        self.radio_3d.grid(row=1, column=5)

        self.functions = []
        self.labels = []

        self.fig = Figure(figsize=(12, 6), dpi=100)
        self.ax_2d = self.fig.add_subplot(122)
        self.ax_3d = self.fig.add_subplot(121, projection='3d')

        self.canvas = FigureCanvasTkAgg(self.fig, self.master)
        self.canvas.get_tk_widget().grid(row=1, column=0)

    def add_function(self):
        func = self.entry_function.get()
        label = self.entry_label.get()
        self.functions.append((func, self.plot_mode.get()))
        self.labels.append(label)
        self.entry_function.delete(0, tk.END)
        self.entry_label.delete(0, tk.END)

    def plot_graph(self):
        self.ax_2d.clear()
        self.ax_3d.clear()
        plotted_2d = False
        proxy_3d = []

        for i in range(len(self.functions)):
            func, mode = self.functions[i]
            label = self.labels[i]

            if mode == "2D":
                x = np.linspace(-10, 10, 400)
                y = eval(func.replace("x", "x"))
                line, = self.ax_2d.plot(x, y)
                line.set_label(label)  # Set label for 2D plot
                plotted_2d = True

            elif mode == "3D":
                x = np.linspace(-10, 10, 40)
                y = np.linspace(-10, 10, 40)
                x, y = np.meshgrid(x, y)
                z = eval(func.replace("x", "x").replace("y", "y"))
                surface = self.ax_3d.plot_surface(x, y, z)
                proxy = Line2D([0], [0], linestyle='none', c='b', marker='o')  # Create a proxy artist for the legend
                proxy_3d.append((proxy, label))

        if plotted_2d:
            self.ax_2d.legend()

        if proxy_3d:
            self.ax_3d.legend([x[0] for x in proxy_3d], [x[1] for x in proxy_3d])

        self.canvas.draw()

    def save_plot(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG files", "*.png")])
        if file_path:
            self.fig.savefig(file_path)

if __name__ == "__main__":
    root = tk.Tk()
    app = PlotterApp(root)
    root.mainloop()


----- Content of html-creator.py -----
import tkinter as tk
from tkinter import simpledialog, messagebox

def generate_html():
    # Fetch the integer values
    try:
        int1 = int(entry_int1.get())
        int2 = int(entry_int2.get())
    except ValueError:
        messagebox.showerror("Error", "Please enter valid integers!")
        return

    # Fetch the corresponding text
    text = entry_text.get()

    # Remove undesired character combinations
    chars_to_remove = entry_remove.get().split(',')
    for char in chars_to_remove:
        text = text.replace(char, "")

    # Format the HTML content
    html_content = f"""
{int1}.{int2}<br><br>
{text}
<br><br>
"""

    # Append to the existing content
    textarea.insert(tk.END, html_content)

def save_html():
    content = textarea.get("1.0", tk.END)
    with open('output.html', 'a') as f:
        f.write(content)
    messagebox.showinfo("Info", "HTML saved as output.html")

# GUI setup
root = tk.Tk()
root.title("HTML Generator")

# Label and Entry for Integer1
label_int1 = tk.Label(root, text="Enter first integer:")
label_int1.pack(pady=5)
entry_int1 = tk.Entry(root)
entry_int1.pack(pady=5)

# Label and Entry for Integer2
label_int2 = tk.Label(root, text="Enter second integer:")
label_int2.pack(pady=5)
entry_int2 = tk.Entry(root)
entry_int2.pack(pady=5)

# Label and Entry for text
label_text = tk.Label(root, text="Enter the text:")
label_text.pack(pady=5)
entry_text = tk.Entry(root, width=50)
entry_text.pack(pady=5)

# Label and Entry for characters to remove
label_remove = tk.Label(root, text="Enter characters/combinations to remove (comma-delimited):")
label_remove.pack(pady=5)
entry_remove = tk.Entry(root, width=50)
entry_remove.pack(pady=5)

# Button to generate HTML
generate_btn = tk.Button(root, text="Generate HTML", command=generate_html)
generate_btn.pack(pady=10)

# Textarea to show the generated HTML
textarea = tk.Text(root, width=60, height=20)
textarea.pack(pady=10)

# Button to save the HTML content to a file
save_btn = tk.Button(root, text="Save to HTML File", command=save_html)
save_btn.pack(pady=10)

root.mainloop()


----- Content of html-formation.py -----
import tkinter as tk
from tkinter import simpledialog, messagebox

def generate_html():
    # Fetch the integer values
    try:
        int1 = int(entry_int1.get())
        int2 = int(entry_int2.get())
    except ValueError:
        messagebox.showerror("Error", "Please enter valid integers!")
        return

    # Fetch the corresponding text
    text = entry_text.get()

    # Format the HTML content
    html_content = f"""
{int1}.{int2}<br><br>
{text}
<br><br>
"""

    # Append to the existing content
    textarea.insert(tk.END, html_content)

def save_html():
    content = textarea.get("1.0", tk.END)
    with open('output.html', 'w') as f:
        f.write(content)
    messagebox.showinfo("Info", "HTML saved as output.html")

# GUI setup
root = tk.Tk()
root.title("HTML Generator")

# Label and Entry for Integer1
label_int1 = tk.Label(root, text="Enter first integer:")
label_int1.pack(pady=5)
entry_int1 = tk.Entry(root)
entry_int1.pack(pady=5)

# Label and Entry for Integer2
label_int2 = tk.Label(root, text="Enter second integer:")
label_int2.pack(pady=5)
entry_int2 = tk.Entry(root)
entry_int2.pack(pady=5)

# Label and Entry for text
label_text = tk.Label(root, text="Enter the text:")
label_text.pack(pady=5)
entry_text = tk.Entry(root, width=50)
entry_text.pack(pady=5)

# Button to generate HTML
generate_btn = tk.Button(root, text="Generate HTML", command=generate_html)
generate_btn.pack(pady=10)

# Textarea to show the generated HTML
textarea = tk.Text(root, width=60, height=20)
textarea.pack(pady=10)

# Button to save the HTML content to a file
save_btn = tk.Button(root, text="Save to HTML File", command=save_html)
save_btn.pack(pady=10)

root.mainloop()


----- Content of html-navigation.py -----
# GenerateNavigation.py

def generate_html_content(total_pages):
    html_content = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Navigation</title>
        <style>
            body, html {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                align-content: flex-start;
                overflow-y: auto;
            }
            .btn {
                flex: 1 1 calc(33.33% - 20px);
                height: calc(25% - 20px);
                margin: 10px;
                background-color: #007BFF;
                color: white;
                text-align: center;
                display: flex;
                justify-content: center;
                align-items: center;
                text-decoration: none;
                font-size: 1em;
                transition: background-color 0.3s;
            }
            .btn:hover {
                background-color: #0056b3;
            }
        </style>
    </head>
    <body>
    """

    for i in range(1, total_pages + 1):
        html_content += f'<a href="{i}.html" class="btn">{i}</a>\n'
    
    html_content += """
    </body>
    </html>
    """

    return html_content

def save_to_file(filename, content):
    with open(filename, 'w') as f:
        f.write(content)

if __name__ == "__main__":
    total_pages = int(input("Enter the total number of pages: "))
    html_content = generate_html_content(total_pages)
    save_to_file("navigation.html", html_content)
    print("Generated 'navigation.html'")


----- Content of imageProcessing.py -----
import cv2
import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk

class ShapeClassifierApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Shape Classifier")
        
        # Create widgets
        self.load_button = tk.Button(root, text="Load Image", command=self.load_image)
        self.detect_button = tk.Button(root, text="Detect Shapes", command=self.detect_shapes)
        self.canvas = tk.Canvas(root, width=400, height=400)
        self.canvas.pack()
        
        # Initialize variables
        self.image_path = None
        self.image = None
        
        # Place widgets in the GUI
        self.load_button.pack()
        self.detect_button.pack()
    
    def load_image(self):
        self.image_path = filedialog.askopenfilename(filetypes=[("Image files", "*.jpg *.png *.bmp")])
        if self.image_path:
            self.image = Image.open(self.image_path)
            self.display_image(self.image)
    
    def display_image(self, img):
        img = ImageTk.PhotoImage(img)
        self.canvas.create_image(0, 0, anchor=tk.NW, image=img)
        self.canvas.image = img  # Keep a reference to prevent garbage collection
    
    def detect_shapes(self):
        if self.image is None:
            messagebox.showwarning("Warning", "Please load an image first.")
            return
        
        # Convert the image to grayscale
        gray = cv2.cvtColor(np.array(self.image), cv2.COLOR_RGB2GRAY)

        # Apply edge detection to find contours
        edges = cv2.Canny(gray, threshold1=30, threshold2=100)

        # Find contours in the image
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Loop through the contours and classify shapes
        for contour in contours:
            epsilon = 0.04 * cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, epsilon, True)
            num_vertices = len(approx)
            
            x, y, _, _ = cv2.boundingRect(contour)
            shape = self.classify_shape(num_vertices)
            
            # Draw the shape name on the image
            cv2.putText(np.array(self.image), shape, (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
        
        # Display the image with classified shapes
        self.display_image(self.image)
    
    def classify_shape(self, num_vertices):
        if num_vertices == 3:
            return "Triangle"
        elif num_vertices == 4:
            return "Rectangle"
        elif num_vertices == 5:
            return "Pentagon"
        else:
            return "Unknown"

if __name__ == "__main__":
    root = tk.Tk()
    app = ShapeClassifierApp(root)
    root.mainloop()


----- Content of json-Mathematics.py -----
import json
import os

def process_math_data(data):
    # Process the mathematical data
    # This function is a placeholder for whatever processing you need to do
    # For example, you could perform calculations or modify the data in some way
    return data

# Reading JSON data
userd = input("Path to .json file: ")

# Check if the file exists
if not os.path.exists(userd):
    print("File not found. Please check the path and try again.")
else:
    try:
        with open(userd, 'r') as file:
            math_data = json.load(file)

        # Processing the data
        processed_data = process_math_data(math_data)

        # Writing JSON data
        new_filename = "result_" + os.path.basename(userd)
        with open(new_filename, 'w') as file:
            json.dump(processed_data, file, indent=4)

        print(f"Processed data has been saved to {new_filename}")
    except json.JSONDecodeError:
        print("Error reading JSON file. Please ensure the file contains valid JSON.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


----- Content of json-to-csv.py -----
import json
import pandas as pd
import os

def convert_json_to_csv(json_path):
    # Check if the file exists
    if not os.path.exists(json_path):
        print("File not found. Please check the path and try again.")
        return

    # Attempt to load JSON data
    try:
        with open(json_path, 'r') as file:
            data = json.load(file)

        # Convert to DataFrame
        df = pd.DataFrame(data)

        # Generate CSV file name
        csv_filename = os.path.basename(json_path).replace('.json', '.csv')

        # Save to CSV
        df.to_csv(csv_filename, index=False)
        print(f"CSV file saved as {csv_filename}")
    except json.JSONDecodeError:
        print("Error reading JSON file. Please ensure the file contains valid JSON.")
    except ValueError as ve:
        print(f"Error converting to DataFrame: {ve}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# Load JSON file
userd = input("Enter path to .json file: ")
convert_json_to_csv(userd)


----- Content of json-txt.py -----
import json
import os

def process_json_to_txt(json_file, txt_file):
    # Open the JSON file and read data
    with open(json_file, 'r') as file:
        data = json.load(file)

    # Open the text file for writing
    with open(txt_file, 'w') as file:
        def write_data(key, value, indent_level):
            # Write the key if it's not empty
            if key:
                file.write(' ' * indent_level + key + '\n')

            # Check the type of value
            if isinstance(value, dict):
                for sub_key, sub_value in value.items():
                    write_data(sub_key, sub_value, indent_level + 1)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, (dict, list)):
                        write_data('', item, indent_level + 1)
                    else:
                        file.write(' ' * (indent_level + 1) + str(item) + '\n')
            else:
                file.write(' ' * (indent_level + 1) + str(value) + '\n')

            # Write a blank line
            file.write('\n')

        # Start writing data recursively
        if isinstance(data, dict):
            for k, v in data.items():
                write_data(k, v, 0)
        elif isinstance(data, list):
            for item in data:
                write_data('', item, 0)

    print(f"Data has been written to {txt_file}")

# Ask the user for the JSON file path
user_json_file = input("Enter path to .json file: ")

# Check if the file exists
if os.path.exists(user_json_file):
    # Construct the output file name
    output_txt_file = os.path.splitext(user_json_file)[0] + '.txt'
    process_json_to_txt(user_json_file, output_txt_file)
else:
    print("File not found. Please check the path and try again.")


----- Content of Knuth-Morris-Pratt-fsm-n-state.py -----
def compute_lps_array(sequence):
    lps = [0] * len(sequence)
    length = 0
    i = 1

    while i < len(sequence):
        if sequence[i] == sequence[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(input_stream, sequence):
    lps = compute_lps_array(sequence)
    output = []

    i, j = 0, 0
    while i < len(input_stream):
        if sequence[j] == input_stream[i]:
            i += 1
            j += 1
        if j == len(sequence):
            output.append(1)
            j = lps[j - 1]
        elif i < len(input_stream) and sequence[j] != input_stream[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                output.append(0)
                i += 1
    while len(output) < len(input_stream):
        output.append(0)
    return output

def main():
    sequence = input("Enter the binary sequence to be detected: ")
    while not all(c in '01' for c in sequence):
        sequence = input("Invalid input. Enter a valid binary sequence: ")

    input_stream = input("Enter the input stream: ")

    print(f"Input Stream: {input_stream}")
    print("Output Stream: ", end="")

    output_stream = kmp_search(input_stream, sequence)
    for output in output_stream:
        print(output, end="")

    print()

if __name__ == "__main__":
    main()


----- Content of Language.py -----
def read_file(filename):
    with open(filename, 'r') as file:
        return [line.strip() for line in file]

def parse_logic_line(line):
    statement, truth_value, binary_id = line.rsplit(' ', 2)
    return statement, truth_value, binary_id

def evaluate_logic(logic_list, words_dict):
    for logic, truth_value, binary_id in logic_list:
        # Evaluate the logic expression
        eval_result = eval(logic)
        # If the evaluation result matches the desired truth value, process the statement
        if eval_result == (truth_value == '1'):
            # Substitute numbers with words
            for num, word in words_dict.items():
                logic = logic.replace(num, word)
            # Output the result
            with open('enumerated_outputs.txt', 'a') as output_file:
                output_file.write(f"{logic} {binary_id}\n")

def evaluate_logic_sen(logic_list, words_dict):
    for logic, truth_value, binary_id in logic_list:
        # Evaluate the logic expression
        eval_result = eval(logic)
        # If the evaluation result matches the desired truth value, process the statement
        if eval_result == (truth_value == '1'):
            # Substitute numbers with words
            sentence = logic
            for num, word in words_dict.items():
                sentence = sentence.replace(num, word)
            '''
            # Output the result to enumerated_outputs.txt
            with open('enumerated_outputs.txt', 'a') as output_file:
                output_file.write(f"{sentence} {binary_id}\n")
            '''

            # Output the sentence to sentences.txt
            with open('e_sentences.txt', 'a') as sentences_file:
                sentences_file.write(f"{sentence}\n")

# Parse logic.txt to create a list of tuples containing logic expressions, truth values, and binary identifiers
logic_file = read_file('logic.txt')
logic_list = [parse_logic_line(line) for line in logic_file if line]

# Parse words.txt to create a dictionary mapping numbers to words
words_file = read_file('words.txt')
words_dict = {line.split()[0]: line.split()[1] for line in words_file if line}

# Evaluate logic for each logic expression and compare against truth value
evaluate_logic(logic_list, words_dict)
evaluate_logic_sen(logic_list, words_dict)


----- Content of languageCreator.py -----
import tkinter as tk
from tkinter import filedialog, simpledialog, Text
from tkinter.colorchooser import askcolor

class CombinedApp:

    def __init__(self, root):
        self.root = root
        self.root.title("Custom Language & Drawing App")

        self.canvas_bg = "#ffffff"
        self.ink_color = "#000000"
        self.character_map = {}  # Key: key_combination, Value: filename

        self.canvas = tk.Canvas(root, bg=self.canvas_bg, width=800, height=600)
        self.canvas.pack(pady=20, padx=20, side=tk.LEFT)
        self.canvas.bind("<B1-Motion>", self.paint)

        self.text_editor = Text(self.root, wrap='word')
        self.text_editor.pack(pady=20, padx=20, side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.root.bind("<Key>", self.insert_custom_character)

        menu = tk.Menu(root)
        root.config(menu=menu)

        file_menu = tk.Menu(menu)
        menu.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Save Character", command=self.save_character)
        file_menu.add_command(label="Load Character", command=self.load_character)

        colorMenu = tk.Menu(menu)
        menu.add_cascade(label="Colors", menu=colorMenu)
        colorMenu.add_command(label="Canvas Background", command=self.change_canvas_bg)
        colorMenu.add_command(label="Ink Color", command=self.change_ink_color)

        editMenu = tk.Menu(menu)
        menu.add_cascade(label="Edit", menu=editMenu)
        editMenu.add_command(label="Clear Canvas", command=self.clear_canvas)

    def paint(self, event):
        x1, y1 = (event.x - 1), (event.y - 1)
        x2, y2 = (event.x + 1), (event.y + 1)
        self.canvas.create_oval(x1, y1, x2, y2, fill=self.ink_color, outline=self.ink_color, width=2)

    def change_canvas_bg(self):
        color = askcolor()[1]
        if color:
            self.canvas_bg = color
            self.canvas.config(bg=self.canvas_bg)

    def change_ink_color(self):
        color = askcolor()[1]
        if color:
            self.ink_color = color

    def clear_canvas(self):
        self.canvas.delete("all")

    def save_character(self):
        filename = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG files", "*.png")])
        if filename:
            x = self.root.winfo_rootx() + self.canvas.winfo_x()
            y = self.root.winfo_rooty() + self.canvas.winfo_y()
            x1 = x + self.canvas.winfo_width()
            y1 = y + self.canvas.winfo_height()
            self.root.grab_set()  # Prevent interaction with other windows
            self.root.after(100, self.root.grab_release)  # Release after 100ms

            self.root.update()
            from PIL import ImageGrab
            img = ImageGrab.grab(bbox=(x, y, x1, y1))
            img.save(filename)

            key_combination = simpledialog.askstring("Input", "Which key should this character map to?")
            if key_combination:
                self.character_map[key_combination] = filename

    def load_character(self):
        filename = filedialog.askopenfilename(filetypes=[("PNG files", "*.png")])
        if filename:
            key_combination = simpledialog.askstring("Input", "Which key should this character map to?")
            if key_combination:
                self.character_map[key_combination] = filename

    def insert_custom_character(self, event):
        key_combination = event.keysym
        if key_combination in self.character_map:
            filename = self.character_map[key_combination]
            img = tk.PhotoImage(file=filename)
            self.text_editor.image_create(tk.END, image=img)
            # To prevent garbage collection of the image
            self.text_editor.img = img

if __name__ == "__main__":
    root = tk.Tk()
    app = CombinedApp(root)
    root.mainloop()


----- Content of LE.py -----
import tkinter as tk
import random
from PIL import ImageGrab
import pickle
from tkinter import simpledialog
import os
from tkinter import Menu, Checkbutton, BooleanVar
from tkinter.colorchooser import askcolor
import logging
import time
import json
import os
import pyautogui
import keyboard
from tkinter import filedialog
from PIL import Image, ImageTk

current_col = 0
current_row = 0
resized_images = []  # Global variable to store resized images

# Rest of your code...
# Global variable for the image selection frame
image_selection_frame = None
selected_image = None  # Global variable to hold the currently selected image
# Global variable to keep track of the current mode
current_mode = "draw_char"  # Possible values: "draw_char", "image_mode"

def toggle_mode():
    global current_mode, canvas
    if current_mode == "draw_char":
        current_mode = "image_mode"
        canvas.unbind("<Button-1>")  # Unbind draw_char function
        canvas.bind("<Button-1>", on_canvas_click_for_image)  # Bind image drawing function
    else:
        current_mode = "draw_char"
        canvas.unbind("<Button-1>")  # Unbind image drawing function
        #canvas.bind("<Button-1>", lambda event: draw_char(event.x // square_size, event.y // square_size))  # Bind draw_char function
        canvas.bind("<Button-1>", lambda event: draw_char(event.y // square_size, event.x // square_size))

        
def select_image(img):
    global selected_image
    selected_image = img
    # You can add additional logic here, e.g., updating the UI to indicate the selected image

def resize_and_add_image(file_path, size):
    try:
        with Image.open(file_path) as img:
            # Resize and add to the list
            #resized_img = img.resize(size, Image.Resampling.LANCZOS)  # For Pillow versions 8.0.0 and later
            # resized_img = img.resize(size, Image.LANCZOS)  # For older versions of Pillow
            resized_img = img.resize(size, Image.LANCZOS)
            resized_images.append(resized_img)
        update_image_selection_area()
    except Exception as e:
        print(f"Error loading image: {e}")

'''
def on_canvas_click(event):
    # Calculate the sub-square coordinates
    col = event.x // square_size
    row = event.y // square_size

    if selected_image:
        draw_image_on_canvas(row, col, selected_image)
'''

def on_canvas_click_for_image(event):
    global selected_image
    if selected_image:
        col = event.x // square_size
        row = event.y // square_size
        draw_image_on_canvas(row, col, selected_image)


def draw_image_on_canvas(row, col, image):
    x = col * square_size
    y = row * square_size

    resized_image = image.resize((square_size, square_size), Image.LANCZOS)
    tk_image = ImageTk.PhotoImage(resized_image)

    canvas.create_image(x, y, image=tk_image, anchor='nw')

    if not hasattr(canvas, 'images'):
        canvas.images = []
    canvas.images.append(tk_image)  # Keep a reference


'''
# Function to update the image selection area
def update_image_selection_area():
    for img in resized_images:
        # Convert PIL image to Tkinter PhotoImage
        tk_image = ImageTk.PhotoImage(img)
        btn = tk.Button(image_selection_frame, image=tk_image, command=lambda img=img: select_image(img))
        btn.image = tk_image  # Keep a reference to avoid garbage collection
        btn.pack(side='left')
'''

def update_image_selection_area():
    global image_selection_frame

    # Clear existing buttons in the frame
    for widget in image_selection_frame.winfo_children():
        widget.destroy()

    # Create buttons for each image
    for img in resized_images:
        tk_image = ImageTk.PhotoImage(img)
        btn = tk.Button(image_selection_frame, image=tk_image, command=lambda img=img: select_image(img))
        btn.image = tk_image  # Keep a reference to avoid garbage collection
        btn.pack(side='left')


def select_and_add_images():

    # Define a target size for the images
    wid = int(input("Target Width: "))
    hei = int(input("Target Height: "))
    target_size = (wid, hei)  # You can change this size as needed

    
    file_paths = filedialog.askopenfilenames(filetypes=[("PNG files", "*.png")])  # Enable multi-file selection
    if file_paths:
        for file_path in file_paths:
            # Assuming you have a predefined target size for the images
            resize_and_add_image(file_path, target_size)

def resize_and_add_image(file_path, size):
    try:
        with Image.open(file_path) as img:
            # Use Image.Resampling.LANCZOS for Pillow versions 8.0.0 and later
            resized_img = img.resize(size, Image.Resampling.LANCZOS)
            # For older versions of Pillow, use Image.LANCZOS
            # resized_img = img.resize(size, Image.LANCZOS)
            resized_images.append(resized_img)
        update_image_selection_area()  # Update the display area with new images
    except Exception as e:
        print(f"Error loading image: {e}")

def select_and_resize_image():
    # Ask the user to select an image file
    file_path = filedialog.askopenfilename(filetypes=[("PNG files", "*.png")])
    if not file_path:
        return  # User cancelled the dialog

    # Prompt the user for the new size
    new_size = simpledialog.askstring("Resize Image", "Enter new size (width,height):")
    if not new_size:
        return  # User cancelled the dialog

    try:
        # Parse the size input and resize the image
        width, height = map(int, new_size.split(','))
        resize_image(file_path, (width, height))
    except Exception as e:
        tk.messagebox.showerror("Error", f"An error occurred: {e}")

def resize_image(input_path, size):
    try:
        # Construct a new file name based on the original path
        dir_name, file_name = os.path.split(input_path)
        name, ext = os.path.splitext(file_name)
        output_path = os.path.join(dir_name, f"{name}_resized{ext}")

        # Open, resize, and save the image
        with Image.open(input_path) as img:
            # Use Image.Resampling.LANCZOS for Pillow versions 8.0.0 and later
            img = img.resize(size, Image.Resampling.LANCZOS)
            # For older versions of Pillow, use Image.LANCZOS
            # img = img.resize(size, Image.LANCZOS)
            img.save(output_path)

        tk.messagebox.showinfo("Success", f"Image saved successfully to {output_path}")
    except Exception as e:
        tk.messagebox.showerror("Error", f"An error occurred: {e}")



def get_random_color():
    r = lambda: random.randint(0,255)
    return '#%02X%02X%02X' % (r(),r(),r())

def get_random_char():
    random_int = random.randint(0x0021, 0x007E)
    return chr(random_int)

def draw_grid():
    for i in range(grid_size):
        for j in range(grid_size):
            color = get_random_color()
            square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
            char = get_random_char()
            text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", 18), anchor="center")


def draw_grid_IDE():
    global col
    try:
        for i in range(grid_size):
            for j in range(grid_size):
                color = "blue"
                square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color, outline = "white")
        if typing_mode:
            # In the function where you create the canvas...
            canvas.bind("<Key>", on_key_press)
            canvas.focus_set()
    except:
        print("Submit an app mode ...")


def toggle_color_mode():
    """Toggles between manual color mode and random color mode"""
    global color_mode_var
    color_mode_var.set(not color_mode_var.get())

font_size = 9

def draw_char1(canvas, char, row, col, font_size, color):
    global cell_size, font_color, square_size, grid_size, last_drawn, note, char_note

    '''
    def draw_char1(canvas, char, row, col, font_size):
    
    Draws a character on the Tkinter canvas at the specified row and column with the specified font size.
    
    Parameters:
    canvas (tk.Canvas): The Tkinter canvas to draw on.
    char (str): The character to draw.
    row (int): The row to draw the character at.
    col (int): The column to draw the character at.
    font_size (int): The font size to use for the character.
    
    '''


    try:
        x = col * square_size + square_size / 2
        y = row * square_size + square_size / 2
        
        print(f"Drawing char '{char}' at ({x}, {y})")  # Debug print to check coordinates
        canvas.create_rectangle(col * square_size, row * square_size, (col+1) * square_size, (row+1) * square_size, fill=color)
        canvas.create_text(x, y, text=char, fill=font_color, font=('Calibri', int(font_size)))
        note = char_note.get()
        # Log the color and character info
        logging.info(f"Position:'{x};{y}',Xp:'{x}',Yp:'{y}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{x},{y},{char},{color},{font_color},{note}", file=login)

    except Exception as e:
        print(f"Something Went Wrong... Error: {e}")



def draw_char(i=None, j=None):
    try:
        """Draws a character from input field in a specific square"""
        global char_count, IDE_mode, typing_mode, last_drawn, font_color
        if(mode == 'IDE'):
            IDE_mode = True
        # Check if last_drawn is defined, otherwise define it
        if 'last_drawn' not in globals():
            last_drawn = []

        # If i, j are not provided, calculate them based on char_count
        if i is None or j is None:
            i, j = divmod(char_count, grid_size)
            # Handle out-of-grid situations
            if i >= grid_size or j >= grid_size:
                print('Out of grid!')
                return

        # Generate a random color if not in typing mode, white otherwise
        ##color = get_random_color() if not typing_mode else "white"

        # Check color mode
        if color_mode_var.get():
            # Manual color mode
            # Show a color picker and get the chosen color for the square
            color = askcolor(title="Choose square color")[1]

            # Ask for the font color
            color_result = askcolor(title="Choose font color")
            if color_result is not None:
                font_color = color_result[1]
            else:
                # Handle the case when the user cancelled the color selection
                font_color = "#000000"  # default to black, for example


        else:
            # Random color mode
            color = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            color1 = "#" + "".join([random.choice('0123456789ABCDEF') for i in range(6)])
            font_color = color1 #"#000000"


        square = canvas.create_rectangle(j*square_size, i*square_size, (j+1)*square_size, (i+1)*square_size, fill=color)
        char = char_entry.get()[:1]
        note = char_note.get()
        text = canvas.create_text(j*square_size + square_size/2, i*square_size + square_size/2, text=char, font=("Arial", font_size), fill=font_color, anchor="center")

        '''
        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}'")
        # Log the color and character info in a text file
        with open("color_log.txt", "a") as login:
            print(f"{i},{j},{char},{color},{font_color}", file=login)
        '''

        # Log the color and character info
        logging.info(f"Position:'{i};{j}',Xp:'{i}',Yp:'{j}',Character:'{char}',Square color:'{color}',Font color:'{font_color}',Note:'{note}'")
        # Log the color and character info in a text file
        if(note == ''):
            note = "emptyNote"
        with open("color_log.txt", "a", encoding='utf-8') as login:
            print(f"{i},{j},{char},{color},{font_color},{note}", file=login)

        
        if len(char_entry.get()) > 0:  # Check if there's more than one character
            char_entry.delete(0, 1)  # Delete the first character

        last_drawn.append((square, text))

        if not IDE_mode:
            char_count = (char_count + 1) % (grid_size * grid_size)
            if char_count == 0:  # If we've filled the canvas, clear it
                canvas.delete('all')

        return square, text
    except:
        print("Submit an app mode ...")


def adjust_grid_and_font():
    global grid_size, square_size, font_size, canvas_width, current_row, current_col

    n_g_s = simpledialog.askstring("Change Grid Size (Grid Width)", "Enter New Grid Size (+Integer):")
    if(n_g_s != ''):
        new_grid_size = n_g_s
    n_f_s = simpledialog.askstring("Change Font Size (Default = 9)", "Enter New Font Size (+Integer):")
    if(n_f_s != ''):
        new_font_size = n_f_s
        # Update the global variables
    if(new_grid_size==None and new_font_size==None):
        grid_size = 10
        font_size = 9
    if((not new_grid_size==None) and (not new_font_size==None)):
        try: 
            grid_size = int(new_grid_size)
            square_size = canvas_width / grid_size
            font_size = int(new_font_size)
        except:
            print("positive integers please")
        
    '''
    # Get new values from input fields
    new_grid_size = grid_size_entry.get()
    new_font_size = font_size_entry.get()
    
    # Update the global variables
    grid_size = int(new_grid_size)
    square_size = canvas_width // grid_size
    font_size = int(new_font_size)
    '''

    # Redraw the grid
    refresh_canvas()
    qit = input("Are you in typing mode, or want to enter typing mode? 1 for (No), 2 for (yes): ")
    if(qit == '2'):
        current_row = 0
        current_col = 0
        show_typing_mode_menu()

def refresh_canvas():
    """Clears the canvas and resets the char_count"""
    global char_count
    canvas.delete('all')
    char_count = 0
    draw_grid_IDE()
    last_drawn.clear()

def undo_last():
    """Undoes the last drawing operation"""
    if last_drawn:
        square, text = last_drawn.pop()
        canvas.delete(square)
        canvas.delete(text)

def update_canvas():
    if not paused.get():
        canvas.delete('all')
        draw_grid()
    root.after(8000, update_canvas)

def toggle_typing_mode():
    global typing_mode, canvas

    typing_mode = not typing_mode
    if typing_mode:
        canvas.focus_set()  # Set focus to the canvas for keyboard input



def on_canvas_click(event):
    try:
        global mode, typing_mode
        if mode == 'IDE' and not typing_mode:
            j = event.x // square_size
            i = event.y // square_size
            draw_char(i, j)
        else:
            paused.set(not paused.get())
    except:
        print("Submit an app mode ...")

def on_key_press(event):
    global char_count, typing_mode
    if typing_mode:
        char_entry.delete(0, 'end')  # Clear the entry box
        try:
            utf8_char = event.char.encode('utf-8').decode('utf-8')
            char_entry.insert(0, utf8_char)  # Insert the typed character
        except UnicodeDecodeError:
            print("Non UTF-8 character detected")
            return
        draw_char()  # Draw the character
        char_count += 1  # Increment the count

        # If char_count exceeds the total number of squares in the grid, reset it
        if char_count >= grid_size ** 2:
            char_count = 0




def submit_mode():

    global char_count, mode, typing_mode
    
    mode = mode_entry.get().upper()
    
    '''
    if mode in ['editor']:

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        draw_grid()
        char_label.pack()
        char_entry.pack()
        char_button.pack()

    '''    
        
    # Draw the initial grid
    if(mode != 'IDE'):
        print("A valid mode ...")

    '''
    if(mode == 'normal'):

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()

        draw_grid()
        create_menu_1()

    if mode == 'normal':
        # Schedule the first update
        root.after(8000, update_canvas)
    '''
    
    if mode == 'IDE':

        typing_mode = False  # Start in clicking mode
        mode_entry.delete(0, 'end')  # Clear the input field
        mode_label.pack_forget()
        mode_entry.pack_forget()
        submit_button.pack_forget()
        
        char_count = 0
        draw_grid_IDE()
        
        control_frame.pack()
        char_label.pack()
        char_entry.pack()
        #grid_size_label.pack()
        #grid_size_entry.pack()
        #font_size_label.pack()
        #font_size_entry.pack()
        #adjust_button.pack()
        char_note_label.pack()
        char_note.pack()
        #refresh_button.pack(side="left")
        #undo_button.pack(side="left")
        #save_button = tk.Button(root, text='Save', command=save_canvas, bg="white", padx=5, pady=0)
        #save_button.pack(side="left")
        #save_Sbutton.pack(side="left")
        #load_button.pack(side="left")
        create_menu()


    return mode



def save_canvas():
    global IC_value, xSwitch, ing
    xSwitch = 1
    ing = 1
    if(ing == 0):
        ing = 2
    ing = 1
    if(xSwitch == 1 and ing == 1):
        IC_value = 0
        ing = 0
    """Save the current state of the canvas to a .png file"""
    #filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    filename = f"ImageCanvas{IC_value}_rename"
    
    if filename:  # Only save the canvas if a filename was entered
        # Get the bounding box of the canvas
        x = root.winfo_rootx() + canvas.winfo_x()
        y = root.winfo_rooty() + canvas.winfo_y()
        x1 = x + canvas.winfo_width()
        y1 = y + canvas.winfo_height()
        time.sleep(3)
        # Grab the image, crop it to the bounding box, and save it
        ImageGrab.grab().crop((x, y, x1, y1)).save(filename + ".png")


def save_session():
    """Save the current session to a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Save Session", "Enter filename:")
    if filename:  # Only save the session if a filename was entered
        session_data = [(canvas.coords(square), canvas.itemcget(square, "fill"),
                        canvas.coords(text), canvas.itemcget(text, "text"), canvas.itemcget(text, "fill"))
                        for square, text in last_drawn]
        with open(filename + ".pkl", "wb") as f:
            pickle.dump(session_data, f)


def load_session():
    """Load a saved session from a file using pickle"""
    global last_drawn
    # Ask the user to enter a filename
    filename = simpledialog.askstring("Load Session", "Enter filename:")
    if filename:  # Only try to load a session if a filename was entered
        try:
            with open(filename + ".pkl", "rb") as f:
                session_data = pickle.load(f)
                # Clear the canvas and redraw all elements from the loaded session
                canvas.delete('all')
                draw_grid_IDE()
                last_drawn = []
                for square_coords, square_fill, text_coords, text_content, text_fill in session_data:
                    square = canvas.create_rectangle(*square_coords, fill=square_fill)
                    text = canvas.create_text(*text_coords, text=text_content, fill=text_fill, font=("Arial", font_size), anchor="center")
                    last_drawn.append((square, text))
        except FileNotFoundError:
            print(f"No session named '{filename}' found.")

#def exit_app():
#    exit()

def show_about():
    about_window = tk.Toplevel(root)
    about_window.title("About")
    about_msg = "This is a program created to learn and experiment with Tkinter. In IDE mode, you can draw characters on a grid (By typing or copying and pasting then clicking the squares you want to draw each character on), adjust the grid and font size, save and load sessions, and more, like saving the grid as an image (For example). C(num) was written with the aid of Chat GPT. Enjoy!\n\nNote: the workflow ... IDE to color_log.txt (Compiled by compile#.exe or compile#.py);\nindex_1.txt contains fields of study or research and development and\nindex_2.txt contains fields of study or research and development also ...\n\nBertotools Digital"
    tk.Message(about_window, text=about_msg, width=500).pack()
    tk.Button(about_window, text="OK", command=about_window.destroy).pack()

def compileGOSmX():
    MAX_LINE_LENGTH = 256
    MAX_TOPICS = 256

    global index_1, index_2
    
    index_1 = [
        "Axiom",
        "Theorem",
        "Lemma",
        "Proposition",
        "Corollary",
        "Conjecture",
        "Proof",
        "Premise",
        "Conclusion",
        "Hypothesis",
        "Counterexample",
        "Direct Proof",
        "Indirect Proof",
        "Proof by Contradiction (Reductio ad absurdum)",
        "Proof by Induction",
        "Proof by Contrapositive",
        "Deductive Reasoning",
        "Inference",
        "Assumption",
        "Statement",
        "Postulate",
        "Proof by Exhaustion",
        "Syllogism",
        "Constructive Proof",
        "Non-Constructive Proof",
        "Trivial Proof",
        "Vacuous Proof",
        "Biconditional",
        "Condition",
        "Sufficiency",
        "Necessity",
        "Quantifier",
        "Universal Quantifier",
        "Existential Quantifier",
        "Bound Variable",
        "Free Variable",
        "Predicate",
        "Propositional Logic",
        "Modus Ponens",
        "Modus Tollens",
        "Discrete Mathematics",
        "Set Theory",
        "Function",
        "Bijection",
        "Injection",
        "Surjection",
        "Equivalence Relation",
        "Partial Order",
        "Total Order",
        "Well-Order",
        "Reflexivity",
        "Symmetry",
        "Transitivity",
        "Antisymmetry",
        "Completeness",
        "Compactness",
        "Connectedness",
        "Convergence",
        "Divergence",
        "Limit",
        "Sequence",
        "Series",
        "Monotonicity",
        "Cauchy Sequence",
        "Infinite Set",
        "Finite Set",
        "Cardinality",
        "Countable Set",
        "Uncountable Set",
        "Subset",
        "Superset",
        "Intersection",
        "Union",
        "Empty Set",
        "Power Set",
        "Cartesian Product",
        "Equivalence Class",
        "Partition",
        "Field",
        "Ring",
        "Group",
        "Abelian Group",
        "Non-abelian Group",
        "Matrix",
        "Vector Space",
        "Linear Transformation",
        "Eigenvalue",
        "Eigenvector",
        "Norm",
        "Inner Product",
        "Orthogonality",
        "Basis",
        "Dimension",
        "Rank",
        "Nullity",
        "Determinant",
        "Graph Theory",
        "Vertex",
        "Edge",
        "Connectivity",
        "Cycle",
        "Path",
        "Degree",
        "Subgraph",
        "Tree",
        "Forest",
        "Planar Graph",
        "Bipartite Graph",
        "Directed Graph (Digraph)",
        "Eulerian Graph",
        "Hamiltonian Graph",
        "Adjacency Matrix",
        "Incidence Matrix",
        "Isomorphism",
        "Homeomorphism",
        "Topology",
        "Open Set",
        "Closed Set",
        "Boundary",
        "Compact Space",
        "Hausdorff Space",
        "Continuity",
        "Differential",
        "Derivative",
        "Integral",
        "Partial Derivative",
        "Multivariable Calculus",
        "Laplace Transform",
        "Fourier Transform",
        "Taylor Series",
        "Maclaurin Series",
        "Conic Sections",
        "Hyperbola",
        "Ellipse",
        "Parabola",
        "Asymptote",
        "Limits at Infinity",
        "Complex Number",
        "Imaginary Unit",
        "Real Number",
        "Rational Number",
        "Irrational Number",
        "Prime Number",
        "Composite Number",
        "GCD (Greatest Common Divisor)",
        "LCM (Least Common Multiple)",
        "Permutation",
        "Combination",
        "Probability",
        "Statistics",
        "Expected Value",
        "Variance",
        "Standard Deviation",
        "Normal Distribution",
        "Poisson Distribution",
        "Binomial Distribution",
        "Hypothesis Testing",
        "Regression",
        "Correlation",
        "Matrix Algebra",
        "Linear Algebra",
        "Vector Calculus",
        "Optimization",
        "Algorithm",
        "Computational Complexity",
        "Big O Notation",
        "Pigeonhole Principle",
        "Principle of Inclusion-Exclusion",
        "Turing Machine",
        "Computability",
        "Unsolvability",
        "Parity",
        "Diophantine Equations",
        "Cryptography",
        "Fermat's Last Theorem",
        "Pythagorean Theorem",
        "Triangle Inequality",
        "Trigonometric Functions",
        "Trigonometric Identities",
        "Polar Coordinates",
        "Euler's Formula",
        "Riemann Zeta Function",
        "P vs NP Problem",
        "NP-complete Problem",
        "Stochastic Process",
        "Markov Chain",
        "Random Variable",
        "Conditional Probability",
        "Bayes' Theorem",
        "Monte Carlo Method",
        "Fractal",
        "Chaos Theory",
        "Game Theory",
        "Nash Equilibrium",
        "Zero-Sum Game",
        "Non-Zero-Sum Game",
        "Linear Programming",
        "Nonlinear Programming",
        "Quadratic Programming",
        "Dynamic Programming",
        "Integer Programming",
        "Graph Coloring",
        "Network Flow",
        "Spanning Tree",
        "Bellman-Ford Algorithm",
        "Dijkstra's Algorithm",
        "Kruskal's Algorithm",
        "Prim's Algorithm",
        "Floyd-Warshall Algorithm",
        "Euler's Method",
        "Runge-Kutta Method",
        "Numerical Integration",
        "Numerical Differentiation",
        "Bisection Method",
        "Newton's Method",
        "Secant Method",
        "Fixed Point Iteration",
        "Linear Interpolation",
        "Polynomial Interpolation",
        "Lagrange Interpolation",
        "Splines",
        "Fourier Series",
        "Laplace's Equation",
        "Heat Equation",
        "Wave Equation",
        "Schrodinger Equation",
        "Ordinary Differential Equation (ODE)",
        "Partial Differential Equation (PDE)",
        "Boundary Value Problem",
        "Initial Value Problem",
        "Green's Theorem",
        "Stoke's Theorem",
        "Divergence Theorem",
        "Curl",
        "Gradient",
        "Divergence",
        "Tensor",
        "Manifold",
        "Topological Space",
        "Measure Theory",
        "Lebesgue Integral",
        "Borel Set",
        "Hilbert Space",
        "Banach Space",
        "Category Theory",
        "Functor",
        "Natural Transformation",
        "Sheaf",
        "Homotopy",
        "Homology",
        "Cohomology",
        "Galois Theory",
        "Algebraic Geometry",
        "Topological K-Theory",
        "Knot Theory",
        "Lattice Theory"
    ]

    index_2 = [
        "Biochemistry",
        "Biophysics",
        "Molecular biology",
        "Genetics",
        "Immunology",
        "Cell biology",
        "Microbiology",
        "Neuroscience",
        "Pharmacology",
        "Bioinformatics",
        "Biotechnology",
        "Proteomics",
        "Genomics",
        "Structural biology",
        "Virology",
        "Systems biology",
        "Developmental biology",
        "Evolutionary biology",
        "Synthetic biology",
        "Metabolomics",
        "Epigenetics",
        "Tissue engineering",
        "Nanotechnology",
        "Materials science",
        "Quantum physics",
        "Condensed matter physics",
        "Particle physics",
        "Astrophysics",
        "Cosmology",
        "Optics",
        "Atomic and molecular physics",
        "Fluid mechanics",
        "Thermodynamics",
        "Environmental science",
        "Climate science",
        "Geology",
        "Oceanography",
        "Atmospheric science",
        "Ecology",
        "Conservation biology",
        "Botany",
        "Zoology",
        "Entomology",
        "Marine biology",
        "Paleontology",
        "Anthropology",
        "Archaeology",
        "Psychology",
        "Cognitive science",
        "Social psychology",
        "Linguistics",
        "Artificial intelligence",
        "Machine learning",
        "Computer vision",
        "Natural language processing",
        "Human-computer interaction",
        "Robotics",
        "Computer graphics",
        "Data science",
        "Mathematical modeling",
        "Mathematical physics",
        "Number theory",
        "Algebraic geometry",
        "Differential equations",
        "Computational physics",
        "Mathematical biology",
        "Operations research",
        "Biostatistics",
        "Epidemiology",
        "Cancer research",
        "Diabetes research",
        "Heart disease research",
        "Infectious diseases research",
        "Immunotherapy",
        "Stem cell research",
        "Gene therapy",
        "Drug discovery",
        "Precision medicine",
        "Health informatics",
        "Renewable energy",
        "Energy storage",
        "Sustainable materials",
        "Environmental engineering",
        "Water management",
        "Transportation engineering",
        "Civil engineering",
        "Chemical engineering",
        "Aerospace engineering",
        "Biomedical engineering",
        "Electrical engineering",
        "Mechanical engineering",
        "Robotics engineering",
        "Quantum computing",
        "Cryptography",
        "Cybersecurity",
        "Network engineering",
        "Telecommunications",
        "Human genetics",
        "Forensic science",
        "Space exploration and research",
        "Planetary science",
        "Astrobiology",
        "Astrochemistry",
        "Astrogeology",
        "Astroinformatics",
        "Exoplanet research",
        "Stellar evolution",
        "Galactic astronomy",
        "Observational astronomy",
        "Computational astrophysics",
        "Quantum chemistry",
        "Computational chemistry",
        "Organic chemistry",
        "Inorganic chemistry",
        "Physical chemistry",
        "Environmental chemistry",
        "Analytical chemistry",
        "Agricultural science",
        "Food science",
        "Nutritional science",
        "Exercise physiology",
        "Sports science",
        "Biomechanics",
        "Plant physiology",
        "Plant genetics",
        "Plant pathology",
        "Soil science",
        "Hydrology",
        "Geochemistry",
        "Geophysics",
        "Geomorphology",
        "Remote sensing",
        "Geotechnical engineering",
        "Petroleum engineering",
        "Aerospace materials",
        "Nanomaterials",
        "Polymer science",
        "Computational materials science",
        "Photonics",
        "Physical optics",
        "Quantum optics",
        "Neuroengineering",
        "Brain imaging",
        "Cognitive neuroscience",
        "Neuroinformatics",
        "Psychophysics",
        "Developmental psychology",
        "Personality psychology",
        "Clinical psychology",
        "Industrial-organizational psychology",
        "Educational psychology",
        "Psycholinguistics",
        "Human genetics",
        "Evolutionary genetics",
        "Population genetics",
        "Genetic engineering",
        "Genetic counseling",
        "Epigenomics",
        "Cardiovascular research",
        "Respiratory research",
        "Gastroenterology research",
        "Endocrinology research",
        "Nephrology research",
        "Hematology research",
        "Ophthalmology research",
        "Orthopedic research",
        "Dermatology research",
        "Veterinary medicine",
        "Animal behavior",
        "Conservation ecology",
        "Wildlife biology",
        "Environmental microbiology",
        "Agricultural economics",
        "Development economics",
        "Behavioral economics",
        "Econometrics",
        "Financial mathematics",
        "Operations management",
        "Supply chain management",
        "Industrial engineering",
        "Human-computer interaction",
        "Virtual reality",
        "Augmented reality",
        "Data mining",
        "Text mining",
        "Big data analytics",
        "Computational linguistics",
        "Quantum information science",
        "Quantum cryptography",
        "Biometrics",
        "Information retrieval",
        "Software engineering",
        "Computer networks",
        "Embedded systems",
        "Human-robot interaction",
        "Control systems",
        "Biopharmaceuticals",
        "Drug delivery systems",
        "Clinical trials",
        "Regenerative medicine",
        "Agricultural biotechnology",
        "Plant breeding",
        "Animal breeding",
        "Food technology",
        "Sensory science",
        "Poultry science",
        "Aquaculture",
        "Marine ecology",
        "Limnology",
        "Population ecology",
        "Landscape ecology",
        "Evolutionary ecology",
        "Environmental toxicology",
        "Environmental chemistry",
        "Environmental microbiology",
        "Ecotoxicology",
        "Green chemistry",
        "Space physics",
        "Space weather",
        "Astrostatistics",
        "Computational fluid dynamics",
        "Mathematical optimization",
        "Operations research",
        "Human genetics",
        "Functional genomics",
        "Molecular genetics",
        "Cancer genetics",
        "Psychiatric genetics",
        "Population genomics",
        "Bioengineering",
        "Biomaterials",
        "Biomechatronics",
        "Cardiovascular engineering",
        "Neural engineering",
        "Rehabilitation engineering",
        "Genetic engineering",
        "Environmental engineering",
        "Water resources engineering",
        "Structural engineering",
        "Robotics engineering",
        "Quantum information theory",
        "Quantum simulation",
        "Quantum sensing",
        "Geographical information systems (GIS)",
        "Urban planning",
        "Renewable energy systems",
        "Solar cell technology",
        "Wind energy research",
        "Energy policy and economics",
        "Computational neuroscience",
        "Neurobiology",
        "Cognitive neuroscience",
        "Systems neuroscience",
        "Human-robot interaction",
        "Evolutionary psychology",
        "Social network analysis"
    ]



    def square_print_topic_indices(r_value, g_value, b_value, file):
        index1 = r_value % len(index_1)
        index2 = g_value % len(index_1)
        index3 = b_value % len(index_1)
        '''
        file.write(f"\t\t\t{topics[index1]}\n")
        file.write(f"\t\t\t{topics[index2]}\n")
        file.write(f"\t\t\t{topics[index3]}\n")
        '''
        file.write(f"\t\t\t{index_1[index1]}\n")
        file.write(f"\t\t\t{index_1[index2]}\n")
        file.write(f"\t\t\t{index_1[index3]}\n")
                
        squareRatio = str(index1) + ":" + str(index2) + ":" + str(index3)
        return squareRatio

    def font_print_topic_indices(r_value, g_value, b_value, file):
        index1_ = r_value % len(index_2)
        index2_ = g_value % len(index_2)
        index3_ = b_value % len(index_2)
        file.write(f"\t\t\t{index_2[index1_]}\n")
        file.write(f"\t\t\t{index_2[index2_]}\n")
        file.write(f"\t\t\t{index_2[index3_]}\n")

        fontRatio = str(index1_) + ":" + str(index2_) + ":" + str(index3_)
        return fontRatio



    def get_index(i, j, grid_size):
        return i * grid_size + j

    def extract_rgb_values(color):
        if len(color) != 7 or color[0] != '#':
            raise ValueError('Input should be a hex color code in the format "#RRGGBB"')
        try:
            red = int(color[1:3], 16)
            green = int(color[3:5], 16)
            blue = int(color[5:7], 16)
            return red, green, blue
        except ValueError:
            raise ValueError('Invalid color code. RGB values should be hex digits (0-9, A-F)')


    def GO():
        log_file = "color_log.txt"
##        topic_file = "index_1.txt"
##        topic2_file = "index_2.txt"  # Corrected this line to read from a different file
        gridWidth = int(input("Enter gridWidth: "))
        # Read topic files to get the topics and topic2s
##        with open(topic_file, "r", encoding='utf8') as file:
##            topics = [line.strip() for line in file]
##
##        with open(topic2_file, "r", encoding='utf8') as file:
##            topic2s = [line.strip() for line in file]

        numTopics = len(index_1)
        numTopic2s = len(index_2)

        # Read color log file
        with open(log_file, "r") as file:
            lines = file.readlines()

        lineNumber = 0
        # Save output to a file
        output_file = "output.txt"
        with open(output_file, "w") as file:
            print()
        for line in lines:
            parts = line.strip().split(",")
            if len(parts) >= 5:
                xcoor = int(parts[1])
                ycoor = int(parts[0])
                index_ = (gridWidth * ycoor) + xcoor
                character = parts[2]
                squareColor = parts[3]
                fontColor = parts[4]
                notes = parts[5]

                # Extract RGB values from squareColor
                red, green, blue = extract_rgb_values(squareColor)

                # Extract RGB values from fontColor
                fontRed, fontGreen, fontBlue = extract_rgb_values(fontColor)

                # Calculate the grid size
                grid_size = int(parts[0])

                # Select topics based on RGB values from squareColor
                topicIndices = [(red + get_index(i, j, grid_size)) % numTopics for i in range(grid_size) for j in range(grid_size)]
                
                lineNumber += 1

                
                with open(output_file, "a") as file:
                    file.write(f"Compiling Line/s: {lineNumber}\n\n")
                    file.write(f"Line({lineNumber})\n\n")
                    file.write(f"0\tLineNumber: {lineNumber}\tx-coordinate: {xcoor}\ty-coordinate: {ycoor}\t Character: {character}\tRGB: {squareColor}\tRGB: {fontColor}\t Note: {notes}\t GridDimensions: {gridWidth}x{gridWidth}\n\n")
                    #print(topicIndices)
                    file.write(f"Line/s({lineNumber}) Output:\n\n")
                    file.write(f"#define Line({lineNumber}){{\n\n")
                    # Inside the main function
                    file.write(f"\ti_1_0(squareColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {red}, G: {green}, B: {blue})\n")
                    s_ratio = square_print_topic_indices(red, green, blue, file)
                    #square_print_topic_indices(red, green, blue, topics, file)   # Modify this line
                    file.write("\t\t)\n")
                    file.write("\t};\n\n")
                    file.write(f"\ti_1_1(fontColor){{\n\n")
                    file.write(f"\t\t{character}\n")
                    file.write(f"\t\t(R: {fontRed}, G: {fontGreen}, B: {fontBlue})\n")
                    f_ratio = font_print_topic_indices(fontRed, fontGreen, fontBlue, file)
                    #font_print_topic_indices(fontRed, fontGreen, fontBlue, topic2s, file)   # And this line
                    file.write("\t\t)\n")
                    file.write(f"\treturn squareRatio({s_ratio}), fontRatio({f_ratio}), sqaureIndex({index_})\n")
                    #file.write(f"\treturn fontRatio({f_ratio})\n")
                    file.write("}\n\n")


    GO()


def create_menu():
    global control_frame
    def home():
        canvas.pack_forget()
        menubar.destroy()
        control_frame.pack()
        char_entry.pack_forget()
        char_label.pack_forget()
        #grid_size_label.pack_forget()
        #grid_size_entry.pack_forget()
        #font_size_label.pack_forget()
        #font_size_entry.pack_forget()
        #adjust_button.pack_forget()
        char_note.pack_forget()
        char_note_label.pack_forget()

        root.destroy()
        switch = 1
        setup_mode(switch)
    
    # Create a menubar
    menubar = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu = tk.Menu(menubar, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="Toggle Manual/Random Colour", command=manual_colour)

    dropdown.add_command(label="Refresh", command=refresh_canvas)
    dropdown.add_command(label="Undo", command=undo_last)
    dropdown.add_command(label="Save Session", command=save_session)
    dropdown.add_command(label="Load Session", command=load_session)
    dropdown.add_command(label="Save as Image", command=save_canvas)
    dropdown.add_command(label="Compile Canvas", command=compileGOSmX)
    # Add the new command for resizing images
    dropdown.add_command(label="Select and Resize Image", command=select_and_resize_image)
    # Add the command for selecting images
    dropdown.add_command(label="Select Images", command=select_and_add_images)
    # Add the toggle mode command
    dropdown.add_command(label="Toggle Draw Chars/Images", command=toggle_mode)
    #dropdown.add_command(label="Exit", command=exit_app)
    #dropdown.add_command(label="Toggle Type/Click Mode", command=toggle_typing_mode)
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Go Home", command=home)
    dropdown.add_command(label="Edit Grid Dimensions", command=adjust_grid_and_font)
    dropdown.add_command(label="Typing Mode", command=show_typing_mode_menu)


    # Set the menubar
    root.config(menu=menubar)

    

def create_menu_1():
    global control_frame
    def home1():
        canvas.pack_forget()
        menubar1.destroy()
        root.destroy()
        switch = 1
        setup_mode(switch)
        
    
    # Create a menubar
    menubar1 = tk.Menu(root)

    # Create an options menu and add it to the menubar
    options_menu1 = tk.Menu(menubar1, tearoff=0)
    #menubar.add_cascade(label="Options", menu=options_menu)

    # Create a dropdown menu and add it to the menubar
    dropdown = tk.Menu(menubar1, tearoff=0)
    menubar1.add_cascade(label="Options", menu=dropdown) # Use a different label, e.g., "Dropdown"

    # Add commands to dropdown menu
    
    # Add checkbutton to options menu
    dropdown.add_command(label="About Program", command=show_about)
    dropdown.add_command(label="Change Mode", command=home1)

    # Set the menubar
    root.config(menu=menubar1)


def manual_colour():
    # Toggle the value of color_mode_var
    current_value = color_mode_var.get()
    color_mode_var.set(not current_value)


'''
# Create a tkinter window
root = tk.Tk()
root.title("General Operating System")
root.iconbitmap("logo.ico")
'''

def show_typing_mode_menu():
    global color_
    while True:
        print("1. Use default UTF-8 mapping")
        print("4. Exit")
        choice = input("Choose an option: ")
        
        if choice == "1":
            # Use default UTF-8 mapping
            print("Using default UTF-8 mapping.")
            color_ = input("Use Default Colour Scheme (1): ")
            if(color_ == '1'):
                # Initialize bg_color and font_color with default values at the global scope
                bg_color = "#FFFFFF"  # Default white background color
                font_color = "#000000"  # Default black font color
                break
        else:
            print("Invalid choice. Please try again.")

    canvas.bind("<Key>", type_character)
    canvas.focus_set()





def set_background_color():
    global color
    #bg_color = tk.colorchooser.askcolor()[1]
    color = input("Enter background color (#FFFFFF for example):")
    
def set_font_color():
    global font_color, font_size
    #font_color = tk.colorchooser.askcolor()[1]
    font_color = input("Enter background color (#000000 for example): ")
    font_size = input("Enter font_size: ")


def type_character(event):
    global current_row, current_col, col, font_size, font_color, color, canvas_width, square_size
    color = "#FFFFFF"
    font_color = "#000000"
    char = event.char
    if char:  # Ignore non-character events
        try:
            
            draw_char1(canvas, char, current_row, current_col, font_size, color)
            current_col += 1
            if (current_col >= canvas_width/square_size):
                current_col = 0
                current_row += 1
            if(current_row >= canvas_width/square_size):
                current_col = 0
                current_row = 0
        except Exception as e:
            print("Something Went Wrong...")
            print(e)

        
        


def setup_mode(sw):

    global mode_entry, mode_label, square_size, grid_size, char_count, last_drawn
    global root, color_mode_var, logging, paused, canvas_width, canvas_height, canvas
    global grid_size_label, grid_size_entry, font_size_label, font_size_entry, adjust_button
    global save_Sbutton, load_button, char_label, char_entry, char_note_label, char_note, char_button
    global refresh_button, undo_button, control_frame, submit_button, col, color_
    global image_selection_frame  # Use the global variable



    current_row = 0
    current_col = 0
    color_ = 1
    
    # Define the size of the squares and the grid
    #square_size = 70
    square_size = int(input("Enter sub-square size: "))
    #grid_size = 10
    grid_size = int(input("Enter grid size by the number of sub-squares: "))
    char_count = 0
    last_drawn = []

    window_height = square_size * grid_size + (square_size * 2)
    window_width = square_size * grid_size
    

    if(sw == 1):
        # Create a tkinter window
        root = tk.Tk()
        # Define the frame for displaying the image selection
        image_selection_frame = tk.Frame(root)
        image_selection_frame.pack(side='top')  # Adjust the side as per your layout
        root.title("C")
        #root.iconbitmap("logo.ico")
        sw = 0
        switch = 0

    ###


    # Get screen width and height
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()

    # Calculate position of the window
    position_top = int(screen_height / 2 - window_height / 2)
    position_right = int(screen_width / 2 - window_width / 2)
    
    # Set the dimensions of the window and where it is placed
    root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')

    ###

    # Create a BooleanVar for the color mode and set it to False initially
    color_mode_var = BooleanVar(value=False)

    # Setup logging
    logging.basicConfig(filename='logging.txt', level=logging.INFO)

    paused = tk.BooleanVar()
    paused.set(False)

    canvas_width = grid_size * square_size
    canvas_height = grid_size * square_size
    canvas = tk.Canvas(root, width=canvas_width, height=canvas_height)
    col = canvas_width
    canvas.pack()
    canvas.bind("<Button-1>", on_canvas_click)
    
    # In the function where you create the canvas...
    canvas.bind("<Key>", on_key_press)
    canvas.focus_set()
    
    # Create input fields and buttons for grid and font size input
    grid_size_label = tk.Label(root, text="Grid size:")
    grid_size_entry = tk.Entry(root, width=5)
    font_size_label = tk.Label(root, text="Font size:")
    font_size_entry = tk.Entry(root, width=5)
    adjust_button = tk.Button(root, text='Adjust Grid & Font', command=adjust_grid_and_font)

    # Create the save and load buttons
    save_Sbutton = tk.Button(root, text='Save Session', command=save_session, bg="white", padx=5, pady=0)
    load_button = tk.Button(root, text='Load Session', command=load_session, bg="white", padx=5, pady=0)

    # Create input fields and buttons for mode and character input
    mode_label = tk.Label(root, text="Enter ... 'IDE' for an\nInteractive Development Environment\nfor Learning anything!")
    mode_entry = tk.Entry(root)
    submit_button = tk.Button(root, text='LEARN', command=submit_mode)


    '''
    filename = simpledialog.askstring("Save Canvas", "Enter filename:")
    if filename:
    '''
    
    char_label = tk.Label(root, text="Enter symbol/s to draw: ")
    char_entry = tk.Entry(root, width=12)
    char_note_label = tk.Label(root, text="Enter Note: ")
    char_note = tk.Entry(root, width=12)
    #char_button = tk.Button(root, text='Draw Character', command=draw_char)

    refresh_button = tk.Button(root, text='Refresh', command=refresh_canvas, bg="white", padx=5, pady=0)
    undo_button = tk.Button(root, text='Undo', command=undo_last, bg="white", padx=5, pady=0)

    control_frame = tk.Frame(root)

    mode_label.pack()
    mode_entry.pack()
    submit_button.pack()
    # create_menu(root)

    # Run the tkinter main loop
    root.mainloop()

global switch
switch = 1


setup_mode(switch)


----- Content of Major_Language_Model.py -----
import tkinter as tk
from tkinter import ttk

def create_table(op_type, n):
    for widget in table_frame.winfo_children():
        widget.destroy()

    counter = 0
    
    # Open logic.txt in write mode to save new logic statements
    with open('logicBuffer.txt', 'w') as logic_file:
        for i in range(1, n+1):  # start range from 1 to avoid zero division
            for j in range(1, n+1):
                # Generate a logic statement based on the operation type
                if op_type == "Addition":
                    statement = f"({i} + {j} % {n} == {i + j % n})"
                    res = i + j % n
                elif op_type == "Multiplication":
                    statement = f"({i} * {j} % {n} == {i * j % n})"
                    res = i + j % n
                binary_id = format(counter, '012b')
                counter += 1
                # Assume all statements are true and assign a binary ID (adjust as needed)
                logic_file.write(f"{statement} 1 {binary_id}\n")
                
                # Create labels for the GUI table
                label = tk.Label(table_frame, text=statement, width=20, height=2, borderwidth=1, relief="solid")
                label.grid(row=i, column=j)
        print("Output in logicBuffer.txt")

root = tk.Tk()
root.title("Modular Arithmetic Table")

control_frame = tk.Frame(root)
control_frame.pack(side=tk.TOP, padx=10, pady=10)

table_frame = tk.Frame(root)
table_frame.pack(side=tk.BOTTOM, padx=10, pady=10)

operation_label = tk.Label(control_frame, text="Operation:")
operation_label.pack(side=tk.LEFT)

operation_combobox = ttk.Combobox(control_frame, values=["Addition", "Multiplication"], state="readonly")
operation_combobox.pack(side=tk.LEFT)
operation_combobox.current(0)

n_label = tk.Label(control_frame, text="Modulo (n):")
n_label.pack(side=tk.LEFT)

n_entry = tk.Entry(control_frame, width=5)
n_entry.pack(side=tk.LEFT)
n_entry.insert(0, "6")

def update_table():
    op_type = operation_combobox.get()
    n = int(n_entry.get())
    create_table(op_type, n)

update_button = tk.Button(control_frame, text="Update Table", command=update_table)
update_button.pack(side=tk.LEFT)

create_table("Addition", 6)

root.mainloop()


----- Content of MealyMachine-n-state_3.py -----
#Written with Chat GPT-4 (OpenAI)
class MealyMachine:
    def __init__(self, sequence):
        self.state = 0
        self.sequence = sequence

    def transition(self, input_symbol):
        if input_symbol == self.sequence[self.state]:
            self.state += 1
            if self.state == len(self.sequence):
                self.state = 1 if input_symbol == self.sequence[0] else 0
                return 1
            else:
                return 0
        else:
            self.state = 1 if input_symbol == self.sequence[0] else 0
            return 0

def main():
    sequence = input("Enter the binary sequence to be detected: ")
    while not all(c in '01' for c in sequence):
        sequence = input("Invalid input. Enter a valid binary sequence: ")

    mealy_machine = MealyMachine(sequence)
    input_stream = input("Enter the input stream: ")

    print(f"Input Stream: {input_stream}")
    print("Output Stream: ", end="")

    for symbol in input_stream:
        output = mealy_machine.transition(symbol)
        print(output, end="")

    print()

if __name__ == "__main__":
    main()


----- Content of Mechanical Computer.py -----
import FreeCAD, Part

# Create a new document
doc = FreeCAD.newDocument("Stainless_Steel_Slab")

# Create the stainless steel slab
slab = Part.makeBox(135, 63, 6)
slab_obj = doc.addObject("Part::Feature", "Slab")
slab_obj.Shape = slab

# Create the first slot (one-third down from the top, starting from the top face)
slot1 = Part.makeBox(5, 63, 3, FreeCAD.Vector((135-5)/3, 0, 6 - 3))

# Create the second slot (two-thirds down from the top, starting from the top face)
slot2 = Part.makeBox(5, 63, 3, FreeCAD.Vector(2*(135-5)/3, 0, 6 - 3))

# Cut the slots from the slab
cut1 = slab.cut(slot1)
cut2 = cut1.cut(slot2)
slab_obj.Shape = cut2

# Recompute the document
doc.recompute()



----- Content of MechanicalComputer.py -----
import FreeCAD, Part

# Create a new document
doc = FreeCAD.newDocument("Stainless_Steel_Slab")

# Create the stainless steel slab
slab = Part.makeBox(135, 63, 6)
slab_obj = doc.addObject("Part::Feature", "Slab")
slab_obj.Shape = slab

# Create the first slot (one-third down from the top, starting from the top face)
slot1 = Part.makeBox(5, 63, 3, FreeCAD.Vector((135-5)/3, 0, 6 - 3))

# Create the second slot (two-thirds down from the top, starting from the top face)
slot2 = Part.makeBox(5, 63, 3, FreeCAD.Vector(2*(135-5)/3, 0, 6 - 3))

# Cut the slots from the slab
cut1 = slab.cut(slot1)
cut2 = cut1.cut(slot2)
slab_obj.Shape = cut2

# Recompute the document
doc.recompute()



----- Content of Music-1.py -----
from midiutil import MIDIFile

def generate_ambient_percussive_music(file_path, filter_set={2, 3, 5}, mod_values=[2, 3, 5]):
    with open(file_path, 'r') as file:
        content = file.read().split()
    
    filtered_content = [float(num) for num in content if any((int(digit) in filter_set) for digit in str(num) if digit.isdigit())]
    
    # Initialize MIDI file with two tracks
    midi = MIDIFile(2)
    
    # Track for ambient sounds
    ambient_track = 0
    midi.addTrackName(ambient_track, 0, "Ambient Track")
    midi.addTempo(ambient_track, 0, 60)  # Slower tempo for ambient part
    
    # Track for percussive sounds
    percussive_track = 1
    midi.addTrackName(percussive_track, 0, "Percussive Track")
    midi.addTempo(percussive_track, 0, 120)  # Faster tempo for rhythm
    
    # Program change for ambient and percussive instruments
    ambient_instrument = 91  # Pad, for example
    percussive_instrument = 114  # Steel Drums, for example
    midi.addProgramChange(ambient_track, 0, 0, ambient_instrument)
    midi.addProgramChange(percussive_track, 0, 0, percussive_instrument)
    
    time = 0
    for i, value in enumerate(filtered_content):
        for mod_value in mod_values:
            pitch = (int(value * i) + int(value)) % mod_value + 60
            
            if mod_value in [2, 5]:  # Example condition for ambient sounds
                duration = 4  # Longer duration for ambient notes
                volume = 100
                midi.addNote(ambient_track, 0, pitch, time, duration, volume)
            else:  # For percussive sounds
                duration = 1  # Shorter, percussive duration
                volume = 100
                midi.addNote(percussive_track, 9, pitch, time, duration, volume)  # Channel 9 is typically used for percussion
                
            time += 1

    # Output MIDI file
    output_file = file_path.replace('.txt', '_ambient_percussive.mid')
    with open(output_file, 'wb') as outf:
        midi.writeFile(outf)

    print(f"Generated music with ambient and percussive elements saved to {output_file}")

# Example usage
file_path = input("Enter the path to the input file: ")
generate_ambient_percussive_music(file_path)


----- Content of Music-2.py -----
from midiutil import MIDIFile

def generate_music(file_path, filter_set, mod_values, ambient_instrument, percussive_instrument, ambient_tempo, percussive_tempo):
    # Simplified version of the generation function for brevity
    print(f"Generating music with settings:\nFilter Set: {filter_set}\nModulo Values: {mod_values}\nAmbient Instrument: {ambient_instrument}\nPercussive Instrument: {percussive_instrument}\nAmbient Tempo: {ambient_tempo}\nPercussive Tempo: {percussive_tempo}")
    # MIDI generation logic goes here
    # For demonstration, just print the settings
    print("Music generated successfully!")

def main_menu():
    print("\nMIDI Music Generation Workbench")
    print("1. Set Filter Set")
    print("2. Set Modulo Values")
    print("3. Set Ambient Instrument")
    print("4. Set Percussive Instrument")
    print("5. Set Ambient Tempo")
    print("6. Set Percussive Tempo")
    print("7. Generate MIDI File")
    print("0. Exit")

# Default settings
settings = {
    'filter_set': {2, 3, 5},
    'mod_values': [2, 3, 5],
    'ambient_instrument': 91,  # Pad
    'percussive_instrument': 114,  # Steel Drums
    'ambient_tempo': 60,
    'percussive_tempo': 120,
}

def update_setting(choice):
    if choice == 1:
        new_set = input("Enter new filter set (e.g., 2,3,5): ")
        settings['filter_set'] = set(map(int, new_set.split(',')))
    elif choice == 2:
        new_values = input("Enter new modulo values (e.g., 2,3,5): ")
        settings['mod_values'] = list(map(int, new_values.split(',')))
    # Continue for other settings...

while True:
    main_menu()
    choice = int(input("Enter your choice: "))
    
    if choice == 0:
        print("Exiting program...")
        break
    elif 1 <= choice <= 6:
        update_setting(choice)
    elif choice == 7:
        file_path = input("Enter the path to the input file: ")
        generate_music(file_path, **settings)
    else:
        print("Invalid choice. Please enter a number between 0 and 7.")


----- Content of Music-3.py -----
from midiutil import MIDIFile
import math

# Initialize track configuration
tracks_config = {}
# Default settings
settings = {
    'filter_set': {2, 3, 5},
}
gm1_instrument_names = [
    "Acoustic Grand Piano", "Bright Acoustic Piano", "Electric Grand Piano", "Honky-tonk Piano",
    "Electric Piano 1", "Electric Piano 2", "Harpsichord", "Clavinet",
    "Celesta", "Glockenspiel", "Music Box", "Vibraphone",
    "Marimba", "Xylophone", "Tubular Bells", "Dulcimer",
    "Drawbar Organ", "Percussive Organ", "Rock Organ", "Church Organ",
    "Reed Organ", "Accordion", "Harmonica", "Tango Accordion",
    "Acoustic Guitar (nylon)", "Acoustic Guitar (steel)", "Electric Guitar (jazz)", "Electric Guitar (clean)",
    "Electric Guitar (muted)", "Overdriven Guitar", "Distortion Guitar", "Guitar harmonics",
    "Acoustic Bass", "Electric Bass (finger)", "Electric Bass (pick)", "Fretless Bass",
    "Slap Bass 1", "Slap Bass 2", "Synth Bass 1", "Synth Bass 2",
    "Violin", "Viola", "Cello", "Contrabass",
    "Tremolo Strings", "Pizzicato Strings", "Orchestral Harp", "Timpani",
    "String Ensemble 1", "String Ensemble 2", "Synth Strings 1", "Synth Strings 2",
    "Choir Aahs", "Voice Oohs", "Synth Choir", "Orchestra Hit",
    "Trumpet", "Trombone", "Tuba", "Muted Trumpet",
    "French Horn", "Brass Section", "Synth Brass 1", "Synth Brass 2",
    "Soprano Sax", "Alto Sax", "Tenor Sax", "Baritone Sax",
    "Oboe", "English Horn", "Bassoon", "Clarinet",
    "Piccolo", "Flute", "Recorder", "Pan Flute",
    "Blown Bottle", "Shakuhachi", "Whistle", "Ocarina",
    "Lead 1 (square)", "Lead 2 (sawtooth)", "Lead 3 (calliope)", "Lead 4 (chiff)",
    "Lead 5 (charang)", "Lead 6 (voice)", "Lead 7 (fifths)", "Lead 8 (bass + lead)",
    "Pad 1 (new age)", "Pad 2 (warm)", "Pad 3 (polysynth)", "Pad 4 (choir)",
    "Pad 5 (bowed)", "Pad 6 (metallic)", "Pad 7 (halo)", "Pad 8 (sweep)",
    "FX 1 (rain)", "FX 2 (soundtrack)", "FX 3 (crystal)", "FX 4 (atmosphere)",
    "FX 5 (brightness)", "FX 6 (goblins)", "FX 7 (echoes)", "FX 8 (sci-fi)",
    "Sitar", "Banjo", "Shamisen", "Koto",
    "Kalimba", "Bagpipe", "Fiddle", "Shanai",
    "Tinkle Bell", "Agogo", "Steel Drums", "Woodblock",
    "Taiko Drum", "Melodic Tom", "Synth Drum", "Reverse Cymbal",
    "Guitar Fret Noise", "Breath Noise", "Seashore", "Bird Tweet",
    "Telephone Ring", "Helicopter", "Applause", "Gunshot"
]
# Automatically generate the dictionary of instruments mapped to their corresponding integers
midi_instruments = {name: index for index, name in enumerate(gm1_instrument_names)}


def get_user_mapping_preferences():
    print("Define how to map numbers to note attributes.")
    pitch_rule = input("Pitch mapping (e.g., 'decimal * 127'): ")
    time_rule = input("Start time mapping (e.g., 'index' for sequential): ")
    duration_rule = input("Duration mapping (e.g., 'fixed', '1'): ")
    volume_rule = input("Volume mapping (e.g., 'fixed', '100'): ")

    return {
        'pitch_rule': pitch_rule,
        'time_rule': time_rule,
        'duration_rule': duration_rule,
        'volume_rule': volume_rule,
    }

#import math  Ensure this import is at the top of your script

def interpret_and_load_notes(file_path, track_name, preferences):
    if track_name not in tracks_config:
        print(f"Track '{track_name}' not found. Adding it automatically.")
        tracks_config[track_name] = {'instrument': 0, 'tempo': 120, 'pan': 64, 'notes': []}
    
    with open(file_path, 'r') as file:
        numbers = file.read().split()
        
        for index, number in enumerate(numbers):
            # Update the eval environment to include the math module
            eval_env = {
                'index': index,
                'number': float(number),
                'decimal': float(f"0.{str(number).split('.')[-1]}"),
                'math': math  # Include math module here
            }
            
            pitch = eval(preferences['pitch_rule'], eval_env)
            time = eval(preferences['time_rule'], eval_env)
            duration = eval(preferences['duration_rule'], eval_env)
            volume = eval(preferences['volume_rule'], eval_env)

            tracks_config[track_name]['notes'].append((int(pitch), time, duration, int(volume)))


# Function to display the instruments and their IDs
def list_available_instruments():
    print("Available MIDI Instruments:")
    for name, id in sorted(midi_instruments.items(), key=lambda item: item[1]):
        print(f"{id:3}: {name}")
        
def add_track():
    track_name = input("Enter new track name: ")
    if track_name in tracks_config:
        print("Track already exists.")
        return
    tracks_config[track_name] = {
        'instrument': 0,  # Default instrument
        'tempo': 120,  # Default tempo
        'pan': 64,  # Center panning
        'notes': []  # List of tuples (pitch, time, duration, volume)
    }
    print(f"Track '{track_name}' added.")

def set_instrument():
    track_name = input("Enter track name: ")
    # Example usage
    list_available_instruments()
    instrument = int(input("Enter instrument number: "))
    if track_name in tracks_config:
        tracks_config[track_name]['instrument'] = instrument
        print(f"Instrument for '{track_name}' set to {instrument}.")
    else:
        print("Track not found.")

def set_track_pan():
    track_name = input("Enter track name: ")
    pan = int(input("Enter pan position (0-127): "))
    if track_name in tracks_config and 0 <= pan <= 127:
        tracks_config[track_name]['pan'] = pan
        print(f"Panning for '{track_name}' set to {pan}.")
    else:
        print("Invalid track name or pan position.")

def add_note_to_track():
    track_name = input("Enter track name: ")
    pitch = int(input("Enter pitch (0-127): "))
    # Apply the language filter to the pitch
    if pitch % 10 not in settings['filter_set']:
        print(f"Pitch {pitch} does not pass the filter criteria.")
        return
    time = float(input("Enter time: "))
    duration = float(input("Enter duration: "))
    volume = int(input("Enter volume (0-127): "))
    if track_name in tracks_config:
        tracks_config[track_name]['notes'].append((pitch, time, duration, volume))
        print(f"Note added to '{track_name}'.")
    else:
        print("Track not found.")


def shift_notes_in_track():
    track_name = input("Enter track name: ")
    shift_amount = float(input("Enter shift amount (negative to shift left, positive to shift right): "))
    if track_name in tracks_config:
        shifted_notes = [(pitch, time + shift_amount, duration, volume) for pitch, time, duration, volume in tracks_config[track_name]['notes']]
        tracks_config[track_name]['notes'] = shifted_notes
        print(f"Notes in '{track_name}' shifted by {shift_amount}.")
    else:
        print("Track not found.")

def generate_music(file_path):
    midi = MIDIFile(len(tracks_config))  # Number of tracks
    
    track_index = 0
    for track_name, config in tracks_config.items():
        midi.addTrackName(track_index, 0, track_name)
        midi.addTempo(track_index, 0, config['tempo'])
        midi.addProgramChange(track_index, track_index, 0, config['instrument'])
        midi.addControllerEvent(track_index, track_index, 0, 10, config['pan'])  # Apply panning
        
        for note in config['notes']:
            pitch, time, duration, volume = note
            midi.addNote(track_index, track_index, time, duration, pitch, volume)

        track_index += 1

    output_filename = file_path.replace('.txt', '_generated.mid')
    with open(output_filename, 'wb') as outf:
        midi.writeFile(outf)

    print(f"Music generated successfully and saved to {output_filename}")

def update_filter_set():
    new_set = input("Enter new filter set (e.g., 2,3,5): ")
    settings['filter_set'] = set(map(int, new_set.split(',')))
    print(f"Filter set updated to {settings['filter_set']}.")

def main_menu():
    print("\nMIDI Music Generation Workbench")
    print("1. Add Track")
    print("2. Set Instrument for Track")
    print("3. Set Track Pan")
    print("4. Add Note to Track")
    print("5. Shift Notes in Track")
    print("6. Update Language Filter Set")
    print("7. Generate MIDI File")
    print("8. Add note sequence to a Track")
    print("0. Exit")


while True:
    main_menu()
    choice = int(input("Enter your choice: "))
    
    if choice == 0:
        print("Exiting program...")
        break
    elif choice == 1:
        add_track()
    elif choice == 2:
        set_instrument()
    elif choice == 3:
        set_track_pan()
    elif choice == 4:
        add_note_to_track()
    elif choice == 5:
        shift_notes_in_track()
    elif choice == 6:
        update_filter_set()
    elif choice == 7:
        file_path = input("Enter the path to the input file (used for naming the MIDI file): ")
        generate_music(file_path)
    elif choice == 8:
        file_path = input("Enter the path to the note sequence file: ")
        track_name = input("Enter the track name to add notes to: ")
        preferences = get_user_mapping_preferences()
        interpret_and_load_notes(file_path, track_name, preferences)
    else:
        print("Invalid choice. Please enter a number between 0 and 7.")



----- Content of Music-4.py -----
from midiutil import MIDIFile
import math

# Initialize track configuration
tracks_config = {}
# Default settings
settings = {
    'filter_set': {2, 3, 5},
}
gm1_instrument_names = [
    "Acoustic Grand Piano", "Bright Acoustic Piano", "Electric Grand Piano", "Honky-tonk Piano",
    "Electric Piano 1", "Electric Piano 2", "Harpsichord", "Clavinet",
    "Celesta", "Glockenspiel", "Music Box", "Vibraphone",
    "Marimba", "Xylophone", "Tubular Bells", "Dulcimer",
    "Drawbar Organ", "Percussive Organ", "Rock Organ", "Church Organ",
    "Reed Organ", "Accordion", "Harmonica", "Tango Accordion",
    "Acoustic Guitar (nylon)", "Acoustic Guitar (steel)", "Electric Guitar (jazz)", "Electric Guitar (clean)",
    "Electric Guitar (muted)", "Overdriven Guitar", "Distortion Guitar", "Guitar harmonics",
    "Acoustic Bass", "Electric Bass (finger)", "Electric Bass (pick)", "Fretless Bass",
    "Slap Bass 1", "Slap Bass 2", "Synth Bass 1", "Synth Bass 2",
    "Violin", "Viola", "Cello", "Contrabass",
    "Tremolo Strings", "Pizzicato Strings", "Orchestral Harp", "Timpani",
    "String Ensemble 1", "String Ensemble 2", "Synth Strings 1", "Synth Strings 2",
    "Choir Aahs", "Voice Oohs", "Synth Choir", "Orchestra Hit",
    "Trumpet", "Trombone", "Tuba", "Muted Trumpet",
    "French Horn", "Brass Section", "Synth Brass 1", "Synth Brass 2",
    "Soprano Sax", "Alto Sax", "Tenor Sax", "Baritone Sax",
    "Oboe", "English Horn", "Bassoon", "Clarinet",
    "Piccolo", "Flute", "Recorder", "Pan Flute",
    "Blown Bottle", "Shakuhachi", "Whistle", "Ocarina",
    "Lead 1 (square)", "Lead 2 (sawtooth)", "Lead 3 (calliope)", "Lead 4 (chiff)",
    "Lead 5 (charang)", "Lead 6 (voice)", "Lead 7 (fifths)", "Lead 8 (bass + lead)",
    "Pad 1 (new age)", "Pad 2 (warm)", "Pad 3 (polysynth)", "Pad 4 (choir)",
    "Pad 5 (bowed)", "Pad 6 (metallic)", "Pad 7 (halo)", "Pad 8 (sweep)",
    "FX 1 (rain)", "FX 2 (soundtrack)", "FX 3 (crystal)", "FX 4 (atmosphere)",
    "FX 5 (brightness)", "FX 6 (goblins)", "FX 7 (echoes)", "FX 8 (sci-fi)",
    "Sitar", "Banjo", "Shamisen", "Koto",
    "Kalimba", "Bagpipe", "Fiddle", "Shanai",
    "Tinkle Bell", "Agogo", "Steel Drums", "Woodblock",
    "Taiko Drum", "Melodic Tom", "Synth Drum", "Reverse Cymbal",
    "Guitar Fret Noise", "Breath Noise", "Seashore", "Bird Tweet",
    "Telephone Ring", "Helicopter", "Applause", "Gunshot"
]
# MIDI instruments mapping remains unchanged
midi_instruments = {name: index for index, name in enumerate(gm1_instrument_names)}

def get_user_mapping_preferences():
    # Enhanced to include start time customization
    print("Define how to map numbers to note attributes.")
    pitch_rule = input("Pitch mapping (e.g., 'decimal * 127'): ")
    time_rule = input("Start time mapping (e.g., 'index * 0.5' for staggered): ")
    duration_rule = input("Duration mapping (e.g., 'fixed', '1'): ")
    volume_rule = input("Volume mapping (e.g., 'fixed', '100'): ")

    return {
        'pitch_rule': pitch_rule,
        'time_rule': time_rule,
        'duration_rule': duration_rule,
        'volume_rule': volume_rule,
    }

#import math  Ensure this import is at the top of your script

def interpret_and_load_notes(file_path, track_name, preferences):
    if track_name not in tracks_config:
        print(f"Track '{track_name}' not found. Adding it automatically.")
        tracks_config[track_name] = {'instrument': 0, 'tempo': 120, 'pan': 64, 'notes': []}
    
    with open(file_path, 'r') as file:
        numbers = file.read().split()
        
        for index, number in enumerate(numbers):
            # Update the eval environment to include the math module
            eval_env = {
                'index': index,
                'number': float(number),
                'decimal': float(f"0.{str(number).split('.')[-1]}"),
                'math': math  # Include math module here
            }
            
            pitch = eval(preferences['pitch_rule'], eval_env)
            time = eval(preferences['time_rule'], eval_env)
            duration = eval(preferences['duration_rule'], eval_env)
            volume = eval(preferences['volume_rule'], eval_env)

            tracks_config[track_name]['notes'].append((int(pitch), time, duration, int(volume)))


# Function to display the instruments and their IDs
def list_available_instruments():
    print("Available MIDI Instruments:")
    for name, id in sorted(midi_instruments.items(), key=lambda item: item[1]):
        print(f"{id:3}: {name}")
        
def add_track(track_name):
    # Prompt the user for each setting
    print(f"Adding new track: {track_name}")
    
    # List available instruments for user selection
    list_available_instruments()
    instrument = int(input("Enter instrument number: "))
    
    tempo = int(input("Enter tempo (BPM): "))
    pan = int(input("Enter pan position (0-127, where 64 is center): "))
    
    # Initialize the new track with user-defined settings
    tracks_config[track_name] = {
        'instrument': instrument,
        'tempo': tempo,
        'pan': pan,
        'notes': []  # Initialize an empty list for notes
    }
    print(f"Track '{track_name}' added with instrument {instrument}, tempo {tempo}, and pan {pan}.")


def set_instrument():
    track_name = input("Enter track name: ")
    # Example usage
    list_available_instruments()
    instrument = int(input("Enter instrument number: "))
    if track_name in tracks_config:
        tracks_config[track_name]['instrument'] = instrument
        print(f"Instrument for '{track_name}' set to {instrument}.")
    else:
        print("Track not found.")

def set_track_pan():
    track_name = input("Enter track name: ")
    pan = int(input("Enter pan position (0-127): "))
    if track_name in tracks_config and 0 <= pan <= 127:
        tracks_config[track_name]['pan'] = pan
        print(f"Panning for '{track_name}' set to {pan}.")
    else:
        print("Invalid track name or pan position.")

def add_note_to_track():
    track_name = input("Enter track name: ")
    pitch = int(input("Enter pitch (0-127): "))
    # Apply the language filter to the pitch
    if pitch % 10 not in settings['filter_set']:
        print(f"Pitch {pitch} does not pass the filter criteria.")
        return
    time = float(input("Enter time: "))
    duration = float(input("Enter duration: "))
    volume = int(input("Enter volume (0-127): "))
    if track_name in tracks_config:
        tracks_config[track_name]['notes'].append((pitch, time, duration, volume))
        print(f"Note added to '{track_name}'.")
    else:
        print("Track not found.")


def shift_notes_in_track():
    track_name = input("Enter track name: ")
    shift_amount = float(input("Enter shift amount (negative to shift left, positive to shift right): "))
    if track_name in tracks_config:
        shifted_notes = [(pitch, time + shift_amount, duration, volume) for pitch, time, duration, volume in tracks_config[track_name]['notes']]
        tracks_config[track_name]['notes'] = shifted_notes
        print(f"Notes in '{track_name}' shifted by {shift_amount}.")
    else:
        print("Track not found.")

def generate_music(file_path):
    midi = MIDIFile(len(tracks_config))  # Number of tracks

    track_index = 0
    for track_name, config in tracks_config.items():
        midi.addTrackName(track_index, 0, track_name)
        midi.addTempo(track_index, 0, config['tempo'])
        midi.addProgramChange(track_index, track_index, 0, config['instrument'])
        midi.addControllerEvent(track_index, track_index, 0, 10, config['pan'])  # Apply panning

        for note in config['notes']:
            pitch, start_time, duration, volume = note
            # Ensure that pitch and volume are integers
            pitch = int(pitch)
            volume = int(volume)
            midi.addNote(track_index, track_index, start_time, duration, pitch, volume)

        track_index += 1

    output_filename = file_path.replace('.txt', '_generated.mid')
    with open(output_filename, 'wb') as outf:
        midi.writeFile(outf)

    print(f"Music generated successfully and saved to {output_filename}")



def interpret_and_distribute_notes(file_path, track_names, preferences):
    with open(file_path, 'r') as file:
        numbers = file.read().split()
        
    note_count = len(numbers)
    notes_per_track = max(note_count // len(track_names), 1)  # Ensure at least one note per track
    
    for index, number in enumerate(numbers):
        track_index = index // notes_per_track % len(track_names)
        track_name = track_names[track_index]
        
        # Assuming the environment setup for eval includes 'index', 'number', 'math'
        eval_env = {'index': index, 'number': float(number), 'decimal': float(f"0.{str(number).split('.')[-1]}"), 'math': math}
        pitch = eval(preferences['pitch_rule'], eval_env)
        time = eval(preferences['time_rule'], eval_env)
        duration = eval(preferences['duration_rule'], eval_env)
        volume = eval(preferences['volume_rule'], eval_env)

        # Add note to the appropriate track
        tracks_config[track_name]['notes'].append((int(pitch), time, duration, int(volume)))


def update_filter_set():
    new_set = input("Enter new filter set (e.g., 2,3,5): ")
    settings['filter_set'] = set(map(int, new_set.split(',')))
    print(f"Filter set updated to {settings['filter_set']}.")

def main_menu():
    print("\nMIDI Music Generation Workbench")
    print("1. Add Track")
    print("2. Set Instrument for Track")
    print("3. Set Track Pan")
    print("4. Add Note to Track")
    print("5. Shift Notes in Track")
    print("6. Update Language Filter Set")
    print("7. Generate MIDI File")
    print("8. Add note sequence to a Track")
    print("9. Help and Documentation") # New help command
    print("0. Exit")

def display_help():
    print("Help and Documentation:")
    print("- 1 Add Track: Adds a new track. Specify instrument, tempo, and pan.")
    print("- 2 Set Instrument: Change the instrument for a track.")
    print("- 3 Set Track Pan: Adjusts stereo pan for a track.")
    print("- 4 Add Note: Add a note with pitch, time, duration, and volume.")
    print("- 5 Shift Notes: Moves all notes in a track in time.")
    print("- 6 Update Filter Set: Change pitch filter criteria.")
    print("- 7 Generate MIDI: Creates a MIDI file from your configurations.")
    print("- 8 Add Sequence: Add a sequence of notes to tracks, with timing and distribution options.")
    print("- 9 Help: Displays this help information.")
    print("Each function will guide you with prompts for necessary inputs.")

while True:
    main_menu()
    choice = int(input("Enter your choice: "))
     
    if choice == 0:
        print("Exiting program...")
        break
    elif choice == 1:
        tn = input("Enter track name: ")
        add_track(tn)
    elif choice == 2:
        set_instrument()
    elif choice == 3:
        set_track_pan()
    elif choice == 4:
        add_note_to_track()
    elif choice == 5:
        shift_notes_in_track()
    elif choice == 6:
        update_filter_set()
    elif choice == 7:
        file_path = input("Enter the path to the input file (used for naming the MIDI file): ")
        generate_music(file_path)
    elif choice == 8:
        file_path = input("Enter the path to the note sequence file: ")
        distribute_notes = int(input("Distribute notes across multiple tracks automatically? Enter 1 for Yes, 0 for No: "))
         
        if distribute_notes:
            num_tracks = int(input("Enter the number of tracks to distribute notes across: "))
            track_names = [f"Track_{i+1}" for i in range(num_tracks)]
            for name in track_names:
                if name not in tracks_config:
                    add_track(name)
            preferences = get_user_mapping_preferences()
            interpret_and_distribute_notes(file_path, track_names, preferences)
        else:
            track_name = input("Enter the track name to add notes to: ")
            preferences = get_user_mapping_preferences()
            interpret_and_load_notes(file_path, track_name, preferences)
    elif choice == 9:
        display_help()
    else:
        print("Invalid choice. Please enter a number between 0 and 9.")



----- Content of Music-5.py -----
from midiutil import MIDIFile
import math
import random

# Initialize track configuration
tracks_config = {}
# Default settings
settings = {
    'filter_set': {2, 3, 5},
}
gm1_instrument_names = [
    "Acoustic Grand Piano", "Bright Acoustic Piano", "Electric Grand Piano", "Honky-tonk Piano",
    "Electric Piano 1", "Electric Piano 2", "Harpsichord", "Clavinet",
    "Celesta", "Glockenspiel", "Music Box", "Vibraphone",
    "Marimba", "Xylophone", "Tubular Bells", "Dulcimer",
    "Drawbar Organ", "Percussive Organ", "Rock Organ", "Church Organ",
    "Reed Organ", "Accordion", "Harmonica", "Tango Accordion",
    "Acoustic Guitar (nylon)", "Acoustic Guitar (steel)", "Electric Guitar (jazz)", "Electric Guitar (clean)",
    "Electric Guitar (muted)", "Overdriven Guitar", "Distortion Guitar", "Guitar harmonics",
    "Acoustic Bass", "Electric Bass (finger)", "Electric Bass (pick)", "Fretless Bass",
    "Slap Bass 1", "Slap Bass 2", "Synth Bass 1", "Synth Bass 2",
    "Violin", "Viola", "Cello", "Contrabass",
    "Tremolo Strings", "Pizzicato Strings", "Orchestral Harp", "Timpani",
    "String Ensemble 1", "String Ensemble 2", "Synth Strings 1", "Synth Strings 2",
    "Choir Aahs", "Voice Oohs", "Synth Choir", "Orchestra Hit",
    "Trumpet", "Trombone", "Tuba", "Muted Trumpet",
    "French Horn", "Brass Section", "Synth Brass 1", "Synth Brass 2",
    "Soprano Sax", "Alto Sax", "Tenor Sax", "Baritone Sax",
    "Oboe", "English Horn", "Bassoon", "Clarinet",
    "Piccolo", "Flute", "Recorder", "Pan Flute",
    "Blown Bottle", "Shakuhachi", "Whistle", "Ocarina",
    "Lead 1 (square)", "Lead 2 (sawtooth)", "Lead 3 (calliope)", "Lead 4 (chiff)",
    "Lead 5 (charang)", "Lead 6 (voice)", "Lead 7 (fifths)", "Lead 8 (bass + lead)",
    "Pad 1 (new age)", "Pad 2 (warm)", "Pad 3 (polysynth)", "Pad 4 (choir)",
    "Pad 5 (bowed)", "Pad 6 (metallic)", "Pad 7 (halo)", "Pad 8 (sweep)",
    "FX 1 (rain)", "FX 2 (soundtrack)", "FX 3 (crystal)", "FX 4 (atmosphere)",
    "FX 5 (brightness)", "FX 6 (goblins)", "FX 7 (echoes)", "FX 8 (sci-fi)",
    "Sitar", "Banjo", "Shamisen", "Koto",
    "Kalimba", "Bagpipe", "Fiddle", "Shanai",
    "Tinkle Bell", "Agogo", "Steel Drums", "Woodblock",
    "Taiko Drum", "Melodic Tom", "Synth Drum", "Reverse Cymbal",
    "Guitar Fret Noise", "Breath Noise", "Seashore", "Bird Tweet",
    "Telephone Ring", "Helicopter", "Applause", "Gunshot"
]
# MIDI instruments mapping remains unchanged
midi_instruments = {name: index for index, name in enumerate(gm1_instrument_names)}

# Define a helper function to randomly select from sets based on Caley Tables
def random_selection_from_caley(prime_elements):
    selection = random.choice(prime_elements)
    prime_elements.remove(selection)  # Ensure uniqueness by removing the selected element
    return selection


def add_notes_with_caley_logic_to_tracks(track_names, preferences, number_of_notes=100):
    # Caley Table elements for pitch, duration, and volume
    pitch_elements = list(range(60, 65))  # Example pitches from C5 to C#5/Eb5
    duration_elements = [1, 2, 4]  # Quarter, half, whole notes as example durations
    volume_elements = [64, 127]  # Medium and high volumes

    random.shuffle(pitch_elements)
    random.shuffle(duration_elements)
    random.shuffle(volume_elements)

    for track_name in track_names:
        # Distribute notes evenly across tracks
        notes_for_track = number_of_notes // len(track_names)
        for _ in range(notes_for_track):
            pitch = pitch_elements.pop() if pitch_elements else random.choice(range(60, 72))
            duration = duration_elements.pop() if duration_elements else random.choice([1, 2, 4])
            volume = volume_elements.pop() if volume_elements else random.choice([64, 127])

            # Reset lists if empty to ensure continuous note generation
            if not pitch_elements: pitch_elements = list(range(60, 65))
            if not duration_elements: duration_elements = [1, 2, 4]
            if not volume_elements: volume_elements = [64, 127]

            # Calculate start time based on preferences or a simple increment
            start_time = _ * 1  # Simplified start time calculation

            # Add note to the track
            if track_name in tracks_config:
                tracks_config[track_name]['notes'].append((pitch, start_time, duration, volume))
            else:
                print(f"Track {track_name} not found.")

    # After distributing notes, proceed to generate the MIDI file or further processing
    

# Modify or integrate a similar function to utilize Caley logic for note attributes
def add_notes_with_caley_logic(track_name, number_of_notes):
    # Define Caley Table elements (as an example, real implementation may vary)
    pitch_elements = [0, 1, 2, 3, 4]  # Modulo 5 for pitch
    duration_elements = [0, 1, 2]  # Modulo 3 for duration
    volume_elements = [0, 1]  # Modulo 2 for volume

    for _ in range(number_of_notes):
        # Randomly select pitch, duration, and volume
        pitch = random_selection_from_caley(pitch_elements) + 60  # Example pitch offset
        duration = random_selection_from_caley(duration_elements) + 1  # Ensure non-zero duration
        volume = random_selection_from_caley(volume_elements) * 127  # Scale volume

        # Check and reset the elements if all are used
        if not pitch_elements: pitch_elements = [0, 1, 2, 3, 4]
        if not duration_elements: duration_elements = [0, 1, 2]
        if not volume_elements: volume_elements = [0, 1]

        # Add the note with selected attributes
        if track_name in tracks_config:
            tracks_config[track_name]['notes'].append((pitch, _, duration, volume))  # Placeholder for start time


def get_user_mapping_preferences():
    # Enhanced to include start time customization
    print("Define how to map numbers to note attributes.")
    pitch_rule = input("Pitch mapping (e.g., 'decimal * 127'): ")
    time_rule = input("Start time mapping (e.g., 'index * 0.5' for staggered): ")
    duration_rule = input("Duration mapping (e.g., 'fixed', '1'): ")
    volume_rule = input("Volume mapping (e.g., 'fixed', '100'): ")

    return {
        'pitch_rule': pitch_rule,
        'time_rule': time_rule,
        'duration_rule': duration_rule,
        'volume_rule': volume_rule,
    }

#import math  Ensure this import is at the top of your script

def interpret_and_load_notes(file_path, track_name, preferences):
    if track_name not in tracks_config:
        print(f"Track '{track_name}' not found. Adding it automatically.")
        tracks_config[track_name] = {'instrument': 0, 'tempo': 120, 'pan': 64, 'notes': []}
    
    with open(file_path, 'r') as file:
        numbers = file.read().split()
        
        for index, number in enumerate(numbers):
            # Update the eval environment to include the math module
            eval_env = {
                'index': index,
                'number': float(number),
                'decimal': float(f"0.{str(number).split('.')[-1]}"),
                'math': math  # Include math module here
            }
            
            pitch = eval(preferences['pitch_rule'], eval_env)
            time = eval(preferences['time_rule'], eval_env)
            duration = eval(preferences['duration_rule'], eval_env)
            volume = eval(preferences['volume_rule'], eval_env)

            tracks_config[track_name]['notes'].append((int(pitch), time, duration, int(volume)))


# Function to display the instruments and their IDs
def list_available_instruments():
    print("Available MIDI Instruments:")
    for name, id in sorted(midi_instruments.items(), key=lambda item: item[1]):
        print(f"{id:3}: {name}")
        
def add_track(track_name):
    # Prompt the user for each setting
    print(f"Adding new track: {track_name}")
    
    # List available instruments for user selection
    list_available_instruments()
    instrument = int(input("Enter instrument number: "))
    
    tempo = int(input("Enter tempo (BPM): "))
    pan = int(input("Enter pan position (0-127, where 64 is center): "))
    
    # Initialize the new track with user-defined settings
    tracks_config[track_name] = {
        'instrument': instrument,
        'tempo': tempo,
        'pan': pan,
        'notes': []  # Initialize an empty list for notes
    }
    print(f"Track '{track_name}' added with instrument {instrument}, tempo {tempo}, and pan {pan}.")


def set_instrument():
    track_name = input("Enter track name: ")
    # Example usage
    list_available_instruments()
    instrument = int(input("Enter instrument number: "))
    if track_name in tracks_config:
        tracks_config[track_name]['instrument'] = instrument
        print(f"Instrument for '{track_name}' set to {instrument}.")
    else:
        print("Track not found.")

def set_track_pan():
    track_name = input("Enter track name: ")
    pan = int(input("Enter pan position (0-127): "))
    if track_name in tracks_config and 0 <= pan <= 127:
        tracks_config[track_name]['pan'] = pan
        print(f"Panning for '{track_name}' set to {pan}.")
    else:
        print("Invalid track name or pan position.")

def add_note_to_track():
    track_name = input("Enter track name: ")
    pitch = int(input("Enter pitch (0-127): "))
    # Apply the language filter to the pitch
    if pitch % 10 not in settings['filter_set']:
        print(f"Pitch {pitch} does not pass the filter criteria.")
        return
    time = float(input("Enter time: "))
    duration = float(input("Enter duration: "))
    volume = int(input("Enter volume (0-127): "))
    if track_name in tracks_config:
        tracks_config[track_name]['notes'].append((pitch, time, duration, volume))
        print(f"Note added to '{track_name}'.")
    else:
        print("Track not found.")


def shift_notes_in_track():
    track_name = input("Enter track name: ")
    shift_amount = float(input("Enter shift amount (negative to shift left, positive to shift right): "))
    if track_name in tracks_config:
        shifted_notes = [(pitch, time + shift_amount, duration, volume) for pitch, time, duration, volume in tracks_config[track_name]['notes']]
        tracks_config[track_name]['notes'] = shifted_notes
        print(f"Notes in '{track_name}' shifted by {shift_amount}.")
    else:
        print("Track not found.")

def generate_music(file_path):
    midi = MIDIFile(len(tracks_config))  # Number of tracks

    track_index = 0
    for track_name, config in tracks_config.items():
        midi.addTrackName(track_index, 0, track_name)
        midi.addTempo(track_index, 0, config['tempo'])
        midi.addProgramChange(track_index, track_index, 0, config['instrument'])
        midi.addControllerEvent(track_index, track_index, 0, 10, config['pan'])  # Apply panning

        for note in config['notes']:
            pitch, start_time, duration, volume = note
            # Ensure that pitch and volume are integers
            pitch = int(pitch)
            volume = int(volume)
            midi.addNote(track_index, track_index, start_time, duration, pitch, volume)

        track_index += 1

    output_filename = file_path.replace('.txt', '_generated.mid')
    with open(output_filename, 'wb') as outf:
        midi.writeFile(outf)

    print(f"Music generated successfully and saved to {output_filename}")



def interpret_and_distribute_notes(file_path, track_names, preferences):
    with open(file_path, 'r') as file:
        numbers = file.read().split()
        
    note_count = len(numbers)
    notes_per_track = max(note_count // len(track_names), 1)  # Ensure at least one note per track
    
    for index, number in enumerate(numbers):
        track_index = index // notes_per_track % len(track_names)
        track_name = track_names[track_index]
        
        # Assuming the environment setup for eval includes 'index', 'number', 'math'
        eval_env = {'index': index, 'number': float(number), 'decimal': float(f"0.{str(number).split('.')[-1]}"), 'math': math}
        pitch = eval(preferences['pitch_rule'], eval_env)
        time = eval(preferences['time_rule'], eval_env)
        duration = eval(preferences['duration_rule'], eval_env)
        volume = eval(preferences['volume_rule'], eval_env)

        # Add note to the appropriate track
        tracks_config[track_name]['notes'].append((int(pitch), time, duration, int(volume)))


def update_filter_set():
    new_set = input("Enter new filter set (e.g., 2,3,5): ")
    settings['filter_set'] = set(map(int, new_set.split(',')))
    print(f"Filter set updated to {settings['filter_set']}.")

def main_menu():
    print("\nMIDI Music Generation Workbench")
    print("1. Add Track")
    print("2. Set Instrument for Track")
    print("3. Set Track Pan")
    print("4. Add Note to Track")
    print("5. Shift Notes in Track")
    print("6. Update Language Filter Set")
    print("7. Generate MIDI File")
    print("8. Add note sequence to a Track")
    print("9. Help and Documentation") # New help command
    print("0. Exit")

def display_help():
    print("Help and Documentation:")
    print("- 1 Add Track: Adds a new track. Specify instrument, tempo, and pan.")
    print("- 2 Set Instrument: Change the instrument for a track.")
    print("- 3 Set Track Pan: Adjusts stereo pan for a track.")
    print("- 4 Add Note: Add a note with pitch, time, duration, and volume.")
    print("- 5 Shift Notes: Moves all notes in a track in time.")
    print("- 6 Update Filter Set: Change pitch filter criteria.")
    print("- 7 Generate MIDI: Creates a MIDI file from your configurations.")
    print("- 8 Add Sequence: Add a sequence of notes to tracks, with timing and distribution options.")
    print("- 9 Help: Displays this help information.")
    print("Each function will guide you with prompts for necessary inputs.")

def get_number_of_notes_from_file(file_path):
    with open(file_path, 'r') as file:
        # Example: Assuming each line in the file represents a different note
        # or each value is a note, adjust this logic based on the actual file format
        lines = file.readlines()
        number_of_notes = len(lines)  # Each line represents one note
    return number_of_notes


while True:
    main_menu()
    choice = int(input("Enter your choice: "))
     
    if choice == 0:
        print("Exiting program...")
        break
    elif choice == 1:
        tn = input("Enter track name: ")
        add_track(tn)
    elif choice == 2:
        set_instrument()
    elif choice == 3:
        set_track_pan()
    elif choice == 4:
        add_note_to_track()
    elif choice == 5:
        shift_notes_in_track()
    elif choice == 6:
        update_filter_set()
    elif choice == 7:
        file_path = input("Enter the path to the input file (used for naming the MIDI file): ")
        generate_music(file_path)
    elif choice == 8:
        file_path = input("Enter the path to the note sequence file: ")
        distribute_notes = int(input("Distribute notes across multiple tracks automatically? Enter 1 for Yes, 0 for No: "))
        
        if distribute_notes:
            num_tracks = int(input("Enter the number of tracks to distribute notes across: "))
            track_names = [f"Track_{i+1}" for i in range(num_tracks)]
            for name in track_names:
                if name not in tracks_config:
                    # Directly configure new tracks to avoid user interaction for each track's settings
                    tracks_config[name] = {'instrument': 0, 'tempo': 120, 'pan': 64, 'notes': []}
                    print(f"Track '{name}' added with default settings.")

            # Determine the number of notes from the file's content
            number_of_notes = get_number_of_notes_from_file(file_path)

            # Call the function to distribute notes across tracks using Caley logic
            add_notes_with_caley_logic_to_tracks(track_names, number_of_notes)
        

    elif choice == 9:
        display_help()
    else:
        print("Invalid choice. Please enter a number between 0 and 9.")



----- Content of Music.py -----
from midiutil import MIDIFile

def generate_music_with_modulo(file_path, filter_set={2, 3, 5}, mod_values=[2, 3, 5]):
    with open(file_path, 'r') as file:
        content = file.read().split()
    
    # Filter and apply arithmetic operations
    filtered_content = [float(num) for num in content if any((int(digit) in filter_set) for digit in str(num) if digit.isdigit())]
    
    # Initialize MIDI file
    midi = MIDIFile(1)
    track = 0
    time = 0
    midi.addTrackName(track, time, "Modulo Music")
    midi.addTempo(track, time, 120)
    
    channel = 0
    volume = 100

    for i, value in enumerate(filtered_content):
        for mod_value in mod_values:
            # Apply arithmetic operations with modulo
            pitch = (int(value * i) + int(value)) % mod_value + 60  # Modulo operation for pitch variation
            duration = 1
            midi.addNote(track, channel, pitch, time, duration, volume)
            time += 1  # Increment time for sequential placement of notes

    # Output MIDI file
    output_file = file_path.replace('.txt', '_modulo.mid')
    with open(output_file, 'wb') as outf:
        midi.writeFile(outf)

    print(f"Generated music with modulo operations saved to {output_file}")

# Example usage
file_path = input("Enter the path to the input file: ")
generate_music_with_modulo(file_path)


----- Content of NaturalLanguageverification.py -----
from tkinter import *
import tkinter as tk
#from PIL.Image import core as _imaging
import random
import os
import math
import time
import sys
import subprocess
from array import *


import io #experiment

from PIL.Image import Image
from PIL import Image
import PIL
a = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9']
#import pyautogui
#from PIL import Image, experiment

#get Statement from file   [DONE]

#--use Statement from file
#if element from statement matches a[iteration], then print "id number, " to Sequence file to be named by operator. and reset id number
#elif element from statement does not match a[iteration] iterate id number by 1
#elif id is above cell count, then print system failure and pause for 12 seconds.

#use Sequence buffer
#if element is found in statement, print gold pixel
#if element is not found in statement, print white pixel
#save image to directory file


time.sleep(3)

test = input("Run Test? Yes[y] or No[n]? ")
if(test == 'y'):
    gi1 = "build_1.txt"
    gi2 = "sequence_1.txt"
    gi3 = "1"
    gi4 = "lib_1.txt"

if(test == 'n'):
    gi1 = input("input build filename 'build_id.txt': ")
    gi2 = input("input sequence filename 'sequence_id.txt': ")
    gi3 = input("input Image filename 'id': ")
    gi4 = input("input lib filename 'lib_id.txt': ")

s_f = open(gi2, "w")
s_f.close()
s_f = open(gi2, "a")
lib_file_1 = open(gi4, "r")

print("Note: build file is named (Within the directory of this program)... 'build_id.txt'")
xgv = input("Have you entered your statement (1 = yes, 0 = no)? ...")
if(xgv == '1'):
    print("Then Let Us Go ...")
elif(xgv == '0'):
    sys.exit(1)
elif(xgv != '1' and xgv != '0'):
    print("error")
    time.sleep(3)
    sys.exit(1)

st_f = open(gi1, "r")
st_buff = ['0']
bf_buff = ['0']
files_ = ['0']



nword = 0
pointer = 1
pointer2 = 1
jot_ = lib_file_1.read()

got_ = st_f.read()


wcount = 0
tcount = 0
hit1 = len(jot_)
hit2 = len(got_)
xtant = "0"
xtan = int(xtant)

while(jot_ != ''):

    bf_buff.extend(jot_)
    jot_ = lib_file_1.read()

while(got_ != ''):
    
    print(got_)
    st_buff.extend(got_)
    got_ = st_f.read()

del st_buff[0]
del bf_buff[0]


print(st_buff)
print("Size of Lib by Characters ...")
print(len(bf_buff))


#...

conda = len(st_buff)
yields = 0
yeldo = input("Number of Characters in your Language:")
yeldo_ = int(yeldo)
iter_99 = 0
iter_98 = -1
benine = ['0']
pnaf = len(a)
#s13 = 1
while(iter_99 < conda):

    if(iter_98 < yeldo_):
        iter_98 = iter_98 + 1
    if(iter_98 == yeldo_):
        iter_98 = 0
    
    if(st_buff[iter_99] == a[iter_98]):
        solumn_ = str(iter_98 + 1)
        s_f.write(solumn_)
        s_f.write(' ')
        benine.append(iter_98 + 1)
        iter_99 = iter_99 + 1
    yields = yields + 1

    

del benine[0]

print(benine)
print("Length of array is ...")
print(conda)


print("random() : ", random.random())
master = Tk()
master.attributes('-fullscreen', True)
#a = 250
#b = 200
print("Welcome\n")
print("Tip: side length should be a factor of the image width and of the image height")
change1 = input("Enter side length of image block:  ")
change = int(change1)
#a = 1880
#b = 1050 
a1 = input("Enter width of image: ")
a = int(a1)
b1 = input ("Enter height of image:  ")
b = int(b1)
pin_p = a/change 
w = Canvas(master, width= a, height= b)
#psv = getscreen().getcanvas()


#files = 3
#files_buffer = input("Enter number of files to be generated (8^((width/side_length)*(height/side_length)):  ")
#files = int(files_buffer)

#c = ["red","blue","yellow","brown","purple","pink","green","orange"]
c = ["gold"]
xc = 0
zerox = 0
zeroy = 0
p = 1
range_for = int((a/change)*(b/change))
name = 1
cells = ((a//change)*(b//change))
upper = cells - 1
nbr_comb = math.pow(len(c),cells)
files = int(nbr_comb)
#print(len(c))
rown = 0
#rdiv = math.pow(len(c),cells - 1)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)

#rdiv = math.pow(len(c),cells - 2)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)
#def rone(h,j,l):
#    cell = (h/j) % l
#    celled = int(cell
#    w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = c[celled])
file_count = 0
st_f.close()
s_f.close()
#giilp = 1
aiilp = 0
#for t in range(0,files):
x_coun = 0
create_a = ['0']
z_coun = 0
dcoun = 0
lk = 0

if(conda > 1000):
    print("Max Characters allowed: 1000")
    time.sleep(5)
    sys.exit(1)
    
while(z_coun < cells):
    create_a.append(lk)
    z_coun = z_coun + 1
zcoun = 0


while(zcoun < conda):
    create_a[benine[zcoun]] = benine[dcoun]
    zcoun = zcoun + 1
    dcoun = dcoun + 1
    
del create_a[0]

print(create_a)
zcoun = 0
tr_ = len(create_a)
print(tr_)




#file validation check (Natural Language Processing)
lib_file_1.close()
###########
lib_file_1 = open(gi4, "r")
st_f = open (gi1, "r")
gime = len(bf_buff)
grime = 0
liner = 0
chime = len(st_buff)
pount = 0
lount = 0
chount = 0

for tiy in range(0,chime):
    if(st_buff[tiy] == '\n'):
        chount = chount + 1
chount = chount
print("There are ...")
print(chount)
print("files in build.")
gime_ = gime*(chount)
#print(gime)
ijn = 0
ij = 0
g = 0

ijl = 0
pip = len(benine)
kilo = lib_file_1.readline()
kiloe = st_f.readline()
f = 0

while(f < gime_ or kiloe != ''):

    if(kilo == ''):
        lib_file_1.seek(0,0)
    if(kilo == kiloe):
        xtant = 1
        kiloe = st_f.readline()
        print("SUCCESS")
        #print(f)
        f = f + 1
        if(kiloe == ''):
            break
    elif(kilo != kiloe and f < gime_):
        kilo = lib_file_1.readline()
        xtant = 0
        #print(f)
        f = f + 1
        if(kiloe == ''):
            break
    else:
        print("Error")
        time.sleep(5)
        break
    
    g = 0
    


    

if(xtant == 1):
    print("Success, Build file is valid ...")
    time.sleep(5)
elif(xtant == 0):
    print("Build file is not valid")
    time.sleep(5)
    exit()
else:
    print("Fatal Error")
    time.sleep(5)
    exit()

###########


st_f.close()
lib_file_1.close()



for t in range(0,files):
    file_count = file_count + 1
    #if(file_count == 121):
    #    break
    switch = 1
    sw = 0
    #for x in range(range_for):
    #for x in range (0,cells):
    x = 0
    col = cells - 1
    #print(rown)
    pixlp = 0
    while(x < cells):
        
        #f = open('%s.ps' % name, 'wb')
        #f.close
        if(switch == 1):
            row = 1
            nxleft = 0
            nxright = change
            nyleft = 0
            nyright = change
            zerox = 0
            zeroy = 0
        c_length = len(c)    
        switch = 0
        #ran = random.randint(0,c_length - 1)

        rdiv = math.pow(len(c),col)
        cell = (rown/rdiv) % (len(c))
        #rone(row,rdiv,len(c))
        #print(cell)
        #print(rdiv)
        celled = int(cell)
        #print(celled)
        #print(cell)
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran], outline = c[ran])

        kij = st_buff[aiilp]
        
        #for inh in range(0,100*conda):
       
        if(create_a[zcoun] > 0):
            w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = "green", width = 0)     
            #giilp = 0
            #zcoun += 1
    
        if(create_a[zcoun] == 0):
            w.create_rectangle(zerox, nyleft, nxright,nyright, fill = "purple", outline = "black", width = 0)

        zcoun = zcoun + 1
            
        #z_coun = z_coun + 1
        #pixlp = 0
        #if(giilp > 100):
        #    giilp = 0

        
        
            
        if(x <= cells):
            col = col - 1
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran])
        #zxbuffer = zerox
        #w.place(x = zerox, y = zeroy)
        #w.place(bordermode = OUTSIDE, x = zerox + change, y = zeroy)
        w.grid(row = zeroy, column = zerox + change)
        if(p >= pin_p and p%pin_p == 0):
            zeroy = zeroy + change
            zerox = -change
            #zerox = 0
            nxleft = change
            nxright = 0
            nyleft = nyleft + change
            nyright = nyright + change
        zerox = zerox + change
        p = p + 1
        #xc + 1
        nxright = nxright + change
        if(xc == 3):
            xc = 0
        x = x + 1    
    rown = rown + 1
    ce = str(name)
    w.update()


    

    def savefirst():
        w.postscript(file ='Map_' + gi3 + '.ps', colormode='color')

    savefirst()

    name = name + 1
    #f_p = 'D:\\Kaliber\\Portfolio\\Content\\My PhotoBook\\Content\\'
    #os.rename(f_p + '1.ps', f_p + '2.ps')
    
    #process = subprocess.Popen(["ps2pdf", ce + ".ps", ce + ".pdf"], shell=True)
   

   

    
    #Contender 1 For File Saving
    """
    def savefirst():
        cnv = getscreen().getcanvas() 
        global hen
        ps = cnv.postscript(colormode = 'color')
        hen = filedialog.asksaveasfilename(defaultextension = '.jpg')
        im = Image.open(io.BytesIO(ps.encode('utf-8')))
        im.save(hen + '.jpg')
    #savefirst()
    """
    """
    Second Contender For File Saving
    def save(w):
        ps = w.canvas.postscript(colormode='color')
        img = Image.open(io.BytesIO(ps.encode('utf-8')))
        img.save('testing.jpg')
    """
#w.update()    
#script  = ce + ".ps"
#w.save(script)
#os.startfile(script)
#print(script)
    

print("Done")


#master.mainloop()


----- Content of notepad_4.py -----
import tkinter as tk
from tkinter import filedialog

class Notepad:
    def __init__(self, root):
        self.file_path = None
        
        self.notepad = tk.Toplevel(root)
        self.notepad.title("Notepad")
        
        #self.text_area = tk.Text(self.notepad, wrap=tk.WORD)
        #self.text_area.pack(expand=1, fill=tk.BOTH, side=tk.TOP)

        self.scroll_frame = tk.Frame(self.notepad)
        self.scroll_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        
        self.text_area = tk.Text(self.scroll_frame, wrap=tk.WORD)
        self.text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=1)

        # Add scrollbar to the text area
        self.scrollbar = tk.Scrollbar(self.scroll_frame, command=self.text_area.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.text_area.config(yscrollcommand=self.scrollbar.set)

        
        # Bottom Frame for Counts
        self.bottom_frame = tk.Frame(self.notepad)
        self.bottom_frame.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.line_count_label = tk.Label(self.bottom_frame, text="Lines: 0")
        self.line_count_label.pack(side=tk.LEFT, padx=10)
        
        self.char_count_label = tk.Label(self.bottom_frame, text="Chars: 0")
        self.char_count_label.pack(side=tk.LEFT, padx=10)
        
        self.text_area.bind('<KeyRelease>', self.on_text_changed)
        
        # Check for duplicates after typing
        self.text_area.bind('<KeyRelease>', lambda event: self.highlight_duplicates())
        
        # Binding the shortcut key
        self.text_area.bind('<Control-s>', self.quick_save)
        
        menu = tk.Menu(self.notepad)
        file_menu = tk.Menu(menu, tearoff=0)
        file_menu.add_command(label="New", command=self.new_file)
        file_menu.add_command(label="Open", command=self.open_file)
        file_menu.add_command(label="Save", command=self.save_file)
        file_menu.add_command(label="Save As", command=self.save_file_as)
        
        menu.add_cascade(label="File", menu=file_menu)
        self.notepad.config(menu=menu)

    def new_file(self):
        self.text_area.delete(1.0, tk.END)
        self.file_path = None
        self.update_counts()

    def open_file(self):
        self.file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            self.text_area.delete(1.0, tk.END)
            with open(self.file_path, "r") as file:
                self.text_area.insert(tk.INSERT, file.read())
            self.highlight_duplicates()
        self.update_counts()

    def save_file(self):
        if not self.file_path:
            self.save_file_as()
        else:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def save_file_as(self):
        self.file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def quick_save(self, event=None):
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))
        else:
            self.save_file_as()

    def highlight_duplicates(self):
        lines = self.text_area.get(1.0, tk.END).strip().split('\n')
        duplicates = [line for line in lines if lines.count(line) > 1]

        # Clear existing tags
        self.text_area.tag_remove("duplicate", 1.0, tk.END)
        
        # Highlight lines with duplicates
        for duplicate in duplicates:
            start_index = "1.0"
            while True:
                start_index = self.text_area.search(duplicate, start_index, nocase=1, stopindex=tk.END)
                if not start_index:
                    break
                end_index = f"{start_index} lineend+1c"
                self.text_area.tag_add("duplicate", start_index, end_index)
                self.text_area.tag_config("duplicate", background="red")
                start_index = end_index

    def on_text_changed(self, event=None):
        self.update_counts()

    def update_counts(self):
        '''
        chars = len(self.text_area.get(1.0, tk.END)) - 1 # -1 to exclude the final newline char added by Text widget
        lines = self.text_area.get(1.0, tk.END).count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        '''
        text_content = self.text_area.get(1.0, tk.END)
        chars = len(text_content) # Count every character including spaces, tabs, newlines

        # If you want to exclude any character from the count, simply subtract its count from 'chars'.
        # For example, to exclude spaces: chars -= text_content.count(' ')

        lines = text_content.count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        
        
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    tk.Button(root, text="Open Notepad", command=lambda: Notepad(root)).pack()
    root.mainloop()


----- Content of notepad_app-2.py -----
import tkinter as tk
from tkinter import filedialog

def open_notepad(root):
    notepad = tk.Toplevel(root)
    notepad.title("Notepad")
    
    text_area = tk.Text(notepad, wrap=tk.WORD)
    text_area.pack(expand=1, fill=tk.BOTH)
    
    # Check for duplicates after typing
    text_area.bind('<KeyRelease>', lambda event: highlight_duplicates(text_area))
    
    menu = tk.Menu(notepad)
    file_menu = tk.Menu(menu, tearoff=0)
    file_menu.add_command(label="New", command=lambda: new_file(text_area))
    file_menu.add_command(label="Open", command=lambda: open_file(text_area))
    file_menu.add_command(label="Save", command=lambda: save_file(text_area))
    file_menu.add_command(label="Save As", command=lambda: save_file_as(text_area))
    
    menu.add_cascade(label="File", menu=file_menu)
    notepad.config(menu=menu)

def new_file(text_area):
    text_area.delete(1.0, tk.END)

def open_file(text_area):
    file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        text_area.delete(1.0, tk.END)
        with open(file_path, "r") as file:
            text_area.insert(tk.INSERT, file.read())
    highlight_duplicates(text_area)

def save_file(text_area):
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(text_area.get(1.0, tk.END))

def save_file_as(text_area):
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(text_area.get(1.0, tk.END))

def highlight_duplicates(text_area):
    lines = text_area.get(1.0, tk.END).strip().split('\n')
    duplicates = [line for line in lines if lines.count(line) > 1]

    # Clear existing tags
    text_area.tag_remove("duplicate", 1.0, tk.END)
    
    # Highlight lines with duplicates
    for duplicate in duplicates:
        start_index = "1.0"
        while True:
            start_index = text_area.search(duplicate, start_index, nocase=1, stopindex=tk.END)
            if not start_index:
                break
            end_index = f"{start_index} lineend+1c"
            text_area.tag_add("duplicate", start_index, end_index)
            text_area.tag_config("duplicate", background="red")
            start_index = end_index

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    tk.Button(root, text="Open Notepad", command=lambda: open_notepad(root)).pack()
    root.mainloop()


----- Content of notepad_app-3.py -----
import tkinter as tk
from tkinter import filedialog

class Notepad:
    def __init__(self, root):
        self.file_path = None
        
        self.notepad = tk.Toplevel(root)
        self.notepad.title("Notepad")
        
        self.text_area = tk.Text(self.notepad, wrap=tk.WORD)
        self.text_area.pack(expand=1, fill=tk.BOTH, side=tk.TOP)
        
        # Bottom Frame for Counts
        self.bottom_frame = tk.Frame(self.notepad)
        self.bottom_frame.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.line_count_label = tk.Label(self.bottom_frame, text="Lines: 0")
        self.line_count_label.pack(side=tk.LEFT, padx=10)
        
        self.char_count_label = tk.Label(self.bottom_frame, text="Chars: 0")
        self.char_count_label.pack(side=tk.LEFT, padx=10)
        
        self.text_area.bind('<KeyRelease>', self.on_text_changed)
        
        # Check for duplicates after typing
        self.text_area.bind('<KeyRelease>', lambda event: self.highlight_duplicates())
        
        # Binding the shortcut key
        self.text_area.bind('<Control-s>', self.quick_save)
        
        menu = tk.Menu(self.notepad)
        file_menu = tk.Menu(menu, tearoff=0)
        file_menu.add_command(label="New", command=self.new_file)
        file_menu.add_command(label="Open", command=self.open_file)
        file_menu.add_command(label="Save", command=self.save_file)
        file_menu.add_command(label="Save As", command=self.save_file_as)
        
        menu.add_cascade(label="File", menu=file_menu)
        self.notepad.config(menu=menu)

    def new_file(self):
        self.text_area.delete(1.0, tk.END)
        self.file_path = None
        self.update_counts()

    def open_file(self):
        self.file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            self.text_area.delete(1.0, tk.END)
            with open(self.file_path, "r") as file:
                self.text_area.insert(tk.INSERT, file.read())
            self.highlight_duplicates()
        self.update_counts()

    def save_file(self):
        if not self.file_path:
            self.save_file_as()
        else:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def save_file_as(self):
        self.file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def quick_save(self, event=None):
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))
        else:
            self.save_file_as()

    def highlight_duplicates(self):
        lines = self.text_area.get(1.0, tk.END).strip().split('\n')
        duplicates = [line for line in lines if lines.count(line) > 1]

        # Clear existing tags
        self.text_area.tag_remove("duplicate", 1.0, tk.END)
        
        # Highlight lines with duplicates
        for duplicate in duplicates:
            start_index = "1.0"
            while True:
                start_index = self.text_area.search(duplicate, start_index, nocase=1, stopindex=tk.END)
                if not start_index:
                    break
                end_index = f"{start_index} lineend+1c"
                self.text_area.tag_add("duplicate", start_index, end_index)
                self.text_area.tag_config("duplicate", background="red")
                start_index = end_index

    def on_text_changed(self, event=None):
        self.update_counts()

    def update_counts(self):
        '''
        chars = len(self.text_area.get(1.0, tk.END)) - 1 # -1 to exclude the final newline char added by Text widget
        lines = self.text_area.get(1.0, tk.END).count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        '''
        text_content = self.text_area.get(1.0, tk.END)
        chars = len(text_content) # Count every character including spaces, tabs, newlines

        # If you want to exclude any character from the count, simply subtract its count from 'chars'.
        # For example, to exclude spaces: chars -= text_content.count(' ')

        lines = text_content.count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        
        
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    tk.Button(root, text="Open Notepad", command=lambda: Notepad(root)).pack()
    root.mainloop()


----- Content of notepad_app-4.py -----
import tkinter as tk
from tkinter import filedialog

class Notepad:
    def __init__(self, root):
        self.file_path = None
        
        self.notepad = tk.Toplevel(root)
        self.notepad.title("Notepad")
        
        #self.text_area = tk.Text(self.notepad, wrap=tk.WORD)
        #self.text_area.pack(expand=1, fill=tk.BOTH, side=tk.TOP)

        self.scroll_frame = tk.Frame(self.notepad)
        self.scroll_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        
        self.text_area = tk.Text(self.scroll_frame, wrap=tk.WORD)
        self.text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=1)

        # Add scrollbar to the text area
        self.scrollbar = tk.Scrollbar(self.scroll_frame, command=self.text_area.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.text_area.config(yscrollcommand=self.scrollbar.set)

        
        # Bottom Frame for Counts
        self.bottom_frame = tk.Frame(self.notepad)
        self.bottom_frame.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.line_count_label = tk.Label(self.bottom_frame, text="Lines: 0")
        self.line_count_label.pack(side=tk.LEFT, padx=10)
        
        self.char_count_label = tk.Label(self.bottom_frame, text="Chars: 0")
        self.char_count_label.pack(side=tk.LEFT, padx=10)
        
        self.text_area.bind('<KeyRelease>', self.on_text_changed)
        
        # Check for duplicates after typing
        self.text_area.bind('<KeyRelease>', lambda event: self.highlight_duplicates())
        
        # Binding the shortcut key
        self.text_area.bind('<Control-s>', self.quick_save)
        
        menu = tk.Menu(self.notepad)
        file_menu = tk.Menu(menu, tearoff=0)
        file_menu.add_command(label="New", command=self.new_file)
        file_menu.add_command(label="Open", command=self.open_file)
        file_menu.add_command(label="Save", command=self.save_file)
        file_menu.add_command(label="Save As", command=self.save_file_as)
        
        menu.add_cascade(label="File", menu=file_menu)
        self.notepad.config(menu=menu)

    def new_file(self):
        self.text_area.delete(1.0, tk.END)
        self.file_path = None
        self.update_counts()

    def open_file(self):
        self.file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            self.text_area.delete(1.0, tk.END)
            with open(self.file_path, "r") as file:
                self.text_area.insert(tk.INSERT, file.read())
            self.highlight_duplicates()
        self.update_counts()

    def save_file(self):
        if not self.file_path:
            self.save_file_as()
        else:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def save_file_as(self):
        self.file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))

    def quick_save(self, event=None):
        if self.file_path:
            with open(self.file_path, "w") as file:
                file.write(self.text_area.get(1.0, tk.END))
        else:
            self.save_file_as()

    def highlight_duplicates(self):
        lines = self.text_area.get(1.0, tk.END).strip().split('\n')
        duplicates = [line for line in lines if lines.count(line) > 1]

        # Clear existing tags
        self.text_area.tag_remove("duplicate", 1.0, tk.END)
        
        # Highlight lines with duplicates
        for duplicate in duplicates:
            start_index = "1.0"
            while True:
                start_index = self.text_area.search(duplicate, start_index, nocase=1, stopindex=tk.END)
                if not start_index:
                    break
                end_index = f"{start_index} lineend+1c"
                self.text_area.tag_add("duplicate", start_index, end_index)
                self.text_area.tag_config("duplicate", background="red")
                start_index = end_index

    def on_text_changed(self, event=None):
        self.update_counts()

    def update_counts(self):
        '''
        chars = len(self.text_area.get(1.0, tk.END)) - 1 # -1 to exclude the final newline char added by Text widget
        lines = self.text_area.get(1.0, tk.END).count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        '''
        text_content = self.text_area.get(1.0, tk.END)
        chars = len(text_content) # Count every character including spaces, tabs, newlines

        # If you want to exclude any character from the count, simply subtract its count from 'chars'.
        # For example, to exclude spaces: chars -= text_content.count(' ')

        lines = text_content.count('\n')
        
        self.line_count_label.config(text=f"Lines: {lines}")
        self.char_count_label.config(text=f"Chars: {chars}")
        
        
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    tk.Button(root, text="Open Notepad", command=lambda: Notepad(root)).pack()
    root.mainloop()


----- Content of notepad_app.py -----
import tkinter as tk
from tkinter import filedialog

def open_notepad(root):
    notepad = tk.Toplevel(root)
    notepad.title("Notepad")
    
    text_area = tk.Text(notepad, wrap=tk.WORD)
    text_area.pack(expand=1, fill=tk.BOTH)
    
    menu = tk.Menu(notepad)
    file_menu = tk.Menu(menu, tearoff=0)
    file_menu.add_command(label="New", command=lambda: new_file(text_area))
    file_menu.add_command(label="Open", command=lambda: open_file(text_area))
    file_menu.add_command(label="Save", command=lambda: save_file(text_area))
    file_menu.add_command(label="Save As", command=lambda: save_file_as(text_area))
    
    menu.add_cascade(label="File", menu=file_menu)
    notepad.config(menu=menu)

def new_file(text_area):
    text_area.delete(1.0, tk.END)

def open_file(text_area):
    file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        text_area.delete(1.0, tk.END)
        with open(file_path, "r") as file:
            text_area.insert(tk.INSERT, file.read())

def save_file(text_area):
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(text_area.get(1.0, tk.END))

def save_file_as(text_area):
    file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
    if file_path:
        with open(file_path, "w") as file:
            file.write(text_area.get(1.0, tk.END))

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Main Window")
    tk.Button(root, text="Open Notepad", command=lambda: open_notepad(root)).pack()
    root.mainloop()


----- Content of PANS_ptia-hdl.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	puts("(pt) == Universal Set = Computer");
	puts("(pt)i = sub-set of (pt)");
	puts("(pt)ia = element of sub-set of (pt)");
	puts("ti = ia");
	puts("t = i of (pt)ia ");
	puts("i = a of ((pt)ia)");
	puts("\nProgressive Abstract Numerical Solution");
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("PROGRESSIVE_ANS_px_RENAME.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int a[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999};
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 1000;
	for(pr = 0; pr < pc; pr++){
		printf("%d	%d\n", pr, a[pr]);
	}
	char choice;
	cout << "Enter a to uniquely use the 1 to 1000 identifiers for the Default Library or c to create a custom Library: ";
	cin >> choice;
	
	cout << "Enter the size of your array: ";
	cin >> pin;
		
	int array[pin], inn, position;
	int generate;
	cout << "\nDo you want manually create your array (0) or, do you want to generate your array for a range of numbers (1):	";
	cin >> generate;
	int lbrange;
	int ubrange;
	//int i_lbrange, i_ubrange;
	int r_check;
	r_check = 0;
	
	if(choice == 'c'){
		//cout << "Enter the size of your array: ";
		//cin >> pin;
		//int array[pin], inn, position;
		
	
		
		if(generate == 0){
			cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
			for(inn = 0; inn < pin; inn++){
				cin >> array[inn];
			}
		}
		if(generate == 1){
			cout << "\nEnter the lower inclusive bound of the array range of numbers:	";
			cin >> lbrange;
			//i_lbrange = int(lbrange);
			cout << "\nEnter the upper inclusive bound of the array range of numbers:	";
			cin >> ubrange;
			//i_ubrange = ubrange;
			r_check = lbrange;
			//generate custom array from user input;
			for(inn = 0; inn < pin; inn++){
			//	r_check = r_check + 1;
				array[inn] = r_check;
				printf("\n%d", r_check);
				r_check = r_check + 1;
				if (r_check > ubrange){
					break;
				}
			}
			
		}
//		for(inn = 0; inn < pin; inn++){
//			cin >> array[inn];
//		}
	}
	
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	if(choice == 'c'){
		k = pin - 1;
	}
	if(choice == 'a'){
		k = 1000 - 1;
	}
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	int id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	int ai, ci, switch_c, switch_a;
	
	

	
	if(choice == 'c'){
		
		switch_c = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ci;
		
		for(ci; n < ci + 1; n++){
			
			if(switch_c == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			
			for (row=0; row < nbr_comb; row++){
				id++;  //fprintf(p,"\n\n%dCF%d\n\n", n,id);
				for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					rin = array[cell];
					if(col == 0){
						fprintf(p,"%d\n", a[rin]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[rin]);
					}
					
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_c = 1;
		}
	}
	int check;
	check = pin - 1000;
	

	
		
	if(choice == 'a' && check == 0){
	
		switch_a = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ai;
	
		for(n; n < ai + 1; n++){
			if(switch_a == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n, id);
				for (col=n-1; col>=0; col--){
					
					rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					//rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[cell]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[cell]);
					}
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_a = 1;
		}
	}
	
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of PANS_ptia.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	puts("(pt) == Universal Set = Computer");
	puts("(pt)i = sub-set of (pt)");
	puts("(pt)ia = element of sub-set of (pt)");
	puts("ti = ia");
	puts("t = i of (pt)ia ");
	puts("i = a of ((pt)ia)");
	puts("\nProgressive Abstract Numerical Solution");
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("PROGRESSIVE_ANS_px_RENAME.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int a[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999};
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 1000;
	for(pr = 0; pr < pc; pr++){
		printf("%d	%d\n", pr, a[pr]);
	}
	char choice;
	cout << "Enter a to uniquely use the 1 to 1000 identifiers for the Default Library or c to create a custom Library: ";
	cin >> choice;
	
	cout << "Enter the size of your array: ";
	cin >> pin;
		
	int array[pin], inn, position;
	int generate;
	cout << "\nDo you want manually create your array (0) or, do you want to generate your array for a range of numbers (1):	";
	cin >> generate;
	int lbrange;
	int ubrange;
	//int i_lbrange, i_ubrange;
	int r_check;
	r_check = 0;
	
	if(choice == 'c'){
		//cout << "Enter the size of your array: ";
		//cin >> pin;
		//int array[pin], inn, position;
		
	
		
		if(generate == 0){
			cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
			for(inn = 0; inn < pin; inn++){
				cin >> array[inn];
			}
		}
		if(generate == 1){
			cout << "\nEnter the lower inclusive bound of the array range of numbers:	";
			cin >> lbrange;
			//i_lbrange = int(lbrange);
			cout << "\nEnter the upper inclusive bound of the array range of numbers:	";
			cin >> ubrange;
			//i_ubrange = ubrange;
			r_check = lbrange;
			//generate custom array from user input;
			for(inn = 0; inn < pin; inn++){
			//	r_check = r_check + 1;
				array[inn] = r_check;
				printf("\n%d", r_check);
				r_check = r_check + 1;
				if (r_check > ubrange){
					break;
				}
			}
			
		}
//		for(inn = 0; inn < pin; inn++){
//			cin >> array[inn];
//		}
	}
	
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	if(choice == 'c'){
		k = pin - 1;
	}
	if(choice == 'a'){
		k = 1000 - 1;
	}
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	int id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	int ai, ci, switch_c, switch_a;
	
	

	
	if(choice == 'c'){
		
		switch_c = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ci;
		
		for(ci; n < ci + 1; n++){
			
			if(switch_c == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n,id);
				for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[rin]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[rin]);
					}
					
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_c = 1;
		}
	}
	int check;
	check = pin - 1000;
	

	
		
	if(choice == 'a' && check == 0){
	
		switch_a = 0;
		cout << "\n\nEnter nth File System (Number of Cells Per File of the nth File System). Let the value be equal to n for a progressionless session: ";
		cin >> ai;
	
		for(n; n < ai + 1; n++){
			if(switch_a == 1){
				nbr_comb = pow(k + 1, n);
				row = 0;
			}
			for (row=0; row < nbr_comb; row++){
				id++;  fprintf(p,"\n\n%dCF%d\n\n", n, id);
				for (col=n-1; col>=0; col--){
					
					rdiv = pow(k+1, col);
					//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
					
					cell = (row/rdiv) % (k+1);
					//rin = array[cell];
					if(col == 0){
						fprintf(p,"%d", a[cell]);	
					}
					if(col != 0){
						fprintf(p,"%d ", a[cell]);
					}
					//fprintf(p, "%d", a[cell]);
				}
				//printf("\n");
			}
			switch_a = 1;
		}
	}
	
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of Particle_Simulator.py -----
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from PIL import Image
import os

# Function to calculate the gravitational force between two particles
def calculate_gravitational_force(mass1, mass2, pos1, pos2, G=6.67430e-11):
    r = np.linalg.norm(pos1 - pos2)
    force_magnitude = (G * mass1 * mass2) / (r ** 2)
    force_direction = (pos2 - pos1) / r
    force = force_magnitude * force_direction
    return force

# User-defined parameters
num_particles = int(input("Enter the number of particles: "))
time_step = float(input("Enter the time step (t): "))
num_time_steps = int(input("Enter the number of time steps: "))

# Initialize particle properties
masses = np.random.uniform(1.0, 10.0, num_particles)  # Random masses
positions = np.random.uniform(-100.0, 100.0, (num_particles, 3))  # Random initial positions
velocities = np.random.uniform(-1.0, 1.0, (num_particles, 3))  # Random initial velocities

# Create a 3D scatter plot for visualization
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Create a directory to store frame images
if not os.path.exists('frames'):
    os.makedirs('frames')

# Simulation loop
for step in range(num_time_steps):
    # Calculate forces on each particle
    forces = np.zeros_like(positions)
    for i in range(num_particles):
        for j in range(num_particles):
            if i != j:
                force = calculate_gravitational_force(
                    masses[i], masses[j], positions[i], positions[j]
                )
                forces[i] += force
    
    # Update positions and velocities using Euler's method
    positions += velocities * time_step
    velocities += forces / masses[:, np.newaxis] * time_step
    
    # Update the scatter plot for visualization
    ax.cla()
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.scatter(positions[:, 0], positions[:, 1], positions[:, 2], c='b', marker='o')
    
    # Save the current frame as an image
    frame = plt.gcf()
    frame.savefig(f'frames/frame_{step:04d}.png')  # Save the frame as an image

# Create a GIF animation from the saved frames
images = [Image.open(f'frames/frame_{i:04d}.png') for i in range(num_time_steps)]
images[0].save('particle_simulation.gif', save_all=True, append_images=images[1:], duration=100, loop=0)

# Display the final plot
plt.show()


----- Content of permute.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <vector>
#include <algorithm> // For std::sort and std::unique
using namespace std;

bool hasDuplicates(const vector<int>& vec) {
    vector<int> sortedVec = vec;
    sort(sortedVec.begin(), sortedVec.end());
    auto it = unique(sortedVec.begin(), sortedVec.end());
    // If iterator 'it' is not at the end, duplicates were found.
    return it != sortedVec.end();
}

int main() {
    // Existing setup code here...
    FILE *p; p = fopen("SOLUTION_RENAME_MAX.txt","w");
    char a[] = {/* existing characters */};
    int pin, cheque;

    cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;

    int array[pin]; // Assume this is filled with unique elements for permutation
    int k = pin - 1;
    int noc; // User inputs this
    scanf("%d", &noc);
    int n = noc;
    unsigned long long id = 0;
    int nbr_comb = pow(k+1, n);

    if (cheque == 1) {
        for (int row = 0; row < nbr_comb; row++) {
            vector<int> indices;
            for (int col = n-1; col >= 0; col--) {
                int rdiv = pow(k+1, col);
                int cell = (row / rdiv) % (k+1);
                indices.push_back(array[cell]);
            }
            if (!hasDuplicates(indices)) {
                id++;  fprintf(p, "%d ", (id - 1));
                for (int index : indices) {
                    fprintf(p, "%c", a[index]);
                }
                fprintf(p, "\n");
            }
        }
    } else {
        for (int row = 0; row < nbr_comb; row++) {
            vector<int> indices;
            for (int col = n-1; col >= 0; col--) {
                int rdiv = pow(k+1, col);
                int cell = (row / rdiv) % (k+1);
                indices.push_back(cell);
            }
            if (!hasDuplicates(indices)) {
                id++;  fprintf(p, "%d ", (id - 1));
                for (int cell : indices) {
                    fprintf(p, "%c", a[cell]);
                }
                fprintf(p, "\n");
            }
        }
    }
    fclose(p);
    return 0;
}


----- Content of Program.py -----
import tkinter as tk
from tkinter import simpledialog
from tkinter import messagebox
import os
import pickle
from graphviz import Digraph

root = tk.Tk()
root.title("FSM Builder")

class State:
    def __init__(self, name):
        self.name = name

class FSM:
    def __init__(self):
        self.states = {}
        self.transitions = {}
        self.current_state = None

    def add_state(self, state_name):
        state = State(state_name)
        self.states[state_name] = state

    def add_transition(self, from_state, to_state, input_symbol):
        if from_state in self.states and to_state in self.states:
            self.transitions[(from_state, input_symbol)] = to_state
        else:
            print("State not found")

    def set_start(self, state_name):
        if state_name in self.states:
            self.current_state = state_name
        else:
            print("Start state not found")

    def transition(self, input_symbol):
        if (self.current_state, input_symbol) in self.transitions:
            self.current_state = self.transitions[(self.current_state, input_symbol)]
        else:
            print("Transition not found")

    def current_state_name(self):
        return self.current_state
    
    def visualize(self):
        dot = Digraph()
        for state in self.states:
            dot.node(state)
        for (from_state, input_symbol), to_state in self.transitions.items():
            label = f"{input_symbol}"
            dot.edge(from_state, to_state, label=label)
        return dot

def load_session(fsm):
    file_name = simpledialog.askstring("Load Session", "Enter filename to load:")
    if file_name:
        try:
            with open(file_name + '.pkl', 'rb') as f:
                loaded_fsm = pickle.load(f)
            fsm.states = loaded_fsm.states
            fsm.transitions = loaded_fsm.transitions
            fsm.current_state = loaded_fsm.current_state
        except FileNotFoundError:
            messagebox.showerror("Error", "File not found")

def delete_session():
    file_name = simpledialog.askstring("Delete Session", "Enter filename to delete:")
    if file_name:
        try:
            os.remove(file_name + '.pkl')
        except FileNotFoundError:
            messagebox.showerror("Error", "File not found")

def save_session(fsm):
    file_name = simpledialog.askstring("Save Session", "Enter filename to save:")
    if file_name:
        with open(file_name + '.pkl', 'wb') as f:
            pickle.dump(fsm, f)

def display_fsm_diagram(fsm):
    dot = fsm.visualize()
    dot.format = 'png'
    dot.render('fsm_diagram', view=False)
    img = tk.PhotoImage(file='fsm_diagram.png')
    img_label = tk.Label(root, image=img)
    img_label.image = img
    img_label.pack()


# Create an FSM instance
fsm = FSM()

# Frame for Buttons
frame = tk.Frame(root)
root.title("Finite State Machine Builder")
frame.pack(padx=10, pady=10)

menu_bar = tk.Menu(root)
root.config(menu=menu_bar)

file_menu = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="File", menu=file_menu)

# Adding 'Save', 'Load', and 'Delete' options
file_menu.add_command(label="Save Session", command=lambda: save_session(fsm))
file_menu.add_command(label="Load Session", command=lambda: load_session(fsm))
file_menu.add_command(label="Display FSM Diagram", command=lambda: display_fsm_diagram(fsm))
file_menu.add_command(label="Delete Session", command=delete_session)

# Add State Button
add_state_button = tk.Button(frame, text="Add State", command=lambda: add_state(fsm))
add_state_button.pack(side=tk.LEFT, padx=5)

# Add Transition Button
add_transition_button = tk.Button(frame, text="Add Transition", command=lambda: add_transition(fsm))
add_transition_button.pack(side=tk.LEFT, padx=5)

# Set Start State Button
set_start_button = tk.Button(frame, text="Set Start State", command=lambda: set_start(fsm))
set_start_button.pack(side=tk.LEFT, padx=5)

# Transition Button
transition_button = tk.Button(frame, text="Transition", command=lambda: make_transition(fsm))
transition_button.pack(side=tk.LEFT, padx=5)

# Current State Display
current_state_label = tk.Label(root, text="Current State: None")
current_state_label.pack(pady=10)


def add_state(fsm):
    state_name = simpledialog.askstring("Add State", "Enter state name:")
    if state_name:
        fsm.add_state(state_name)

def add_transition(fsm):
    from_state = simpledialog.askstring("Add Transition", "Enter from state:")
    to_state = simpledialog.askstring("Add Transition", "Enter to state:")
    input_symbol = simpledialog.askstring("Add Transition", "Enter input symbol:")
    if from_state and to_state and input_symbol:
        if from_state in fsm.states and to_state in fsm.states:
            fsm.add_transition(from_state, to_state, input_symbol)
        else:
            messagebox.showerror("Error", "One or more states not found")


def set_start(fsm):
    start_state = simpledialog.askstring("Set Start State", "Enter start state:")
    if start_state:
        fsm.set_start(start_state)

def make_transition(fsm):
    input_symbol = simpledialog.askstring("Transition", "Enter input symbol for transition:")
    if input_symbol:
        if (fsm.current_state, input_symbol) in fsm.transitions:
            fsm.transition(input_symbol)
            current_state_label.config(text=f"Current State: {fsm.current_state_name()}")
        else:
            messagebox.showerror("Transition Error", "Transition cannot be made with the given input symbol")


root.mainloop()


----- Content of pycontrol.py -----
import pygame
import importlib
import requests
import os
import subprocess
import webbrowser
import csv
from bs4 import BeautifulSoup
import datetime
import sys
import math
import random
import json
import re
import threading

MY_CUSTOM_EVENT = pygame.USEREVENT + 1

class PygameApp:
    def __init__(self):
        pygame.init()
        self.joystick_init()
        self.screen_size_init()
        self.commands_init()
        self.coordinates_init()
        self.images_init()
        self.input_init()
        # Additional initializations as required...
        
    def joystick_init(self):
        pygame.joystick.init()
        if pygame.joystick.get_count() > 0:
            self.joystick = pygame.joystick.Joystick(0)
            self.joystick.init()

    def maze_layout_init(self):
        self.maze_layout = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15]
        ]
        self.maze_width = len(self.maze_layout[0])  # Assuming all rows have the same length
        self.maze_height = len(self.maze_layout)



    def screen_size_init(self):
        self.enter = 422
        self.screen_width = self.enter
        self.screen_height = self.enter
        #self.bls = 52
        self.bls = min(self.screen_width // 16, self.screen_height // 16)
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))

    def commands_init(self):
        self.bus_ = 255
        self.amount_ = (self.bus_ + 1) * (self.bus_ + 1)
        with open("Command_Template.txt", "w") as create_f:
            for line_number_ in range(self.amount_):
                create_f.write("print(\"[Empty Command Slot] (Change using a text-editor to Update this slot in Command_Template.txt\")\n")

        self.star = []
        with open("Command_Template.txt", 'r') as file:
            for command in file:
                self.star.append(command.strip())

    def coordinates_init(self):
        self.starsx = []
        self.starsy = []

        with open('Coordinates_Python.txt', 'r') as file:
            for line in file:
                parts = line.strip().split(",")
                if len(parts) >= 3:  # Expecting at least 3 parts in each line
                    try:
                        # Assuming the last two parts are x and y coordinates
                        x, y = map(int, parts[-2:])  # Extract the last two values
                        self.starsx.append(x)
                        self.starsy.append(y)
                    except ValueError:
                        print(f"Invalid line in coordinates file: {line}")
                else:
                    print(f"Unexpected format in coordinates file: {line}")



    def images_init(self):

        self.player_image = pygame.image.load("player.png")  # This sets the instance attribute
        self.block_images = []
        # Calculate block size based on screen size and maze dimensions (assuming 16x16 maze)
        block_width = self.screen_width // 16
        block_height = self.screen_height // 16
        for i in range(256):
            # Load and scale each block image
            img = pygame.image.load(f"block{i}.png")
            scaled_img = pygame.transform.scale(img, (block_width, block_height))
            self.block_images.append(scaled_img)

    def input_init(self):
        self.player_x = 0
        self.player_y = 0
        self.typei = "k"
        
    def run(self):
        running = True
        self.maze_layout_init()
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                else:
                    self.handle_input(event)

            self.update_game_state()
            self.render_game()

        pygame.quit()



    def handle_input(self, event):
        # Delegate input handling based on typei
        if self.typei == 'k':
            self.handle_keyboard_input(event)
        elif self.typei == 'd':
            self.handle_xbox_controller_input()
        elif self.typei == 's':
            self.handle_switch_command_input()
        elif self.typei == 'm':
            self.handle_mouse_input()

        if event.type == MY_CUSTOM_EVENT:
            self.handle_custom_event(event)

    def handle_keyboard_input(self, event):
        # Get the current state of all keys
        keys = pygame.key.get_pressed()

        # Update move flag based on keyboard input
        move = keys[pygame.K_LEFT] or keys[pygame.K_RIGHT] or keys[pygame.K_UP] or keys[pygame.K_DOWN]

        # Update player position based on keyboard input
        if move:
            if keys[pygame.K_LEFT]:
                self.player_x -= 1
            if keys[pygame.K_RIGHT]:
                self.player_x += 1
            if keys[pygame.K_UP]:
                self.player_y -= 1
            if keys[pygame.K_DOWN]:
                self.player_y += 1
            self.clamp_player_position()

    def clamp_player_position(self):
        # Ensure the player position stays within bounds
        self.player_x = max(0, min(self.player_x, self.screen_width // self.bls - 1))
        self.player_y = max(0, min(self.player_y, self.screen_height // self.bls - 1))


                
    def handle_xbox_controller_input(self):
        # Xbox controller input handling code
        # ... (your Xbox controller handling code here)

        if(self.typei == 'd'):
            # Check for Xbox controller input
            if pygame.joystick.get_count() > 0:
                joystick = pygame.joystick.Joystick(0)
                joystick.init()
                # Check for D-Pad input
                dpad = joystick.get_hat(0)
                if dpad == (1, 0):
                    self.player_x += 1
                elif dpad == (-1, 0):
                    self.player_x -= 1
                elif dpad == (0, 1):
                    self.player_y -= 1
                elif dpad == (0, -1):
                    self.player_y += 1
                if self.player_x < 0:
                    self.player_x = 0
                if self.player_x >= int(self.screen_width / self.bls):
                    self.player_x = int(self.screen_width / self.bls) - 1
                if self.player_y < 0:
                    self.player_y = 0
                if self.player_y >= int(self.screen_height / self.bls):
                    self.player_y = int(self.screen_height / self.bls) - 1


        

    def handle_switch_command_input(self):
        # Switch command matrix input handling code
        # ... (your switch command handling code here)

        #LoadCommands
        self.xin = 0
        filnam = input("Enter name of Command Matrix file, 'filename.txt': ")
        quet = int(input("Enter 1 if file already exists [Read mode], Else Enter 2 [Write mode], choose carefully: "))
        
        self.bus = 255
        self.amount = (self.bus + 1) * (self.bus + 1)
        self.line_number = 0
        #ai = log10(amount)
        if(quet == 2):
            create_f = open(filnam, "w")
            while(line_number < amount):
                #i = log10(line_number)
                create_f.write("print(\"[Empty Command Slot] Change using a text-editor to Update this slot in Command_Template.txt after renaming it accordingly.\")\n")
                self.line_number = self.line_number + 1

            create_f.close()
        
        with open(filnam, 'r') as file:
            self.commands = file.readlines()
            self.xin = self.xin + 1

        self.star = [0]

        for i, command in enumerate(self.commands):
            self.commands[i] = command.strip()
            #cmd = command.split(",")
            self.star.append(command)
        del self.star[0]
        
        #reset state of matrix
        self.typei = "k"
        self.player_x = 0
        self.player_y = 0

        

    def handle_mouse_input(self):
        # Mouse input handling code
        # ... (your mouse handling code here)

        if(self.typei == 'm'):
            # Get mouse position
            self.mouse_x, self.mouse_y = pygame.mouse.get_pos()

            # Update player position based on mouse position
            self.player_x = self.mouse_x // self.bls
            self.player_y = self.mouse_y // self.bls

    def update_game_state(self):
        # Update game state (e.g., player position)
        # ...
        #reset state of matrix
        self.typei = "k"
        self.player_x = 0
        self.player_y = 0

    '''
    def render_game(self):
        self.screen.fill((255, 255, 255))

        # Ensure the loop covers the entire range
        for y in range(int((self.maze_height*52)/self.bls)):
            for x in range(int((self.maze_width*52)/self.bls)):
                relative_x = x - self.player_x
                relative_y = y - self.player_y
                block_index = relative_x + relative_y * self.maze_width
                if 0 <= block_index < len(self.block_images):
                    self.screen.blit(self.block_images[block_index], (x * self.bls, y * self.bls))

        self.screen.blit(self.player_image, (self.player_x * self.bls, self.player_y * self.bls))
        pygame.display.update()
    '''
    def render_game(self):
        # Clear screen
        self.screen.fill((255, 255, 255))

        # Draw blocks
        for y in range(16):  # Assuming a 16x16 grid
            for x in range(16):
                block_index = y * 16 + x  # Calculate the block index assuming a sequential layout
                block_image = self.block_images[block_index]  # Get the correct image
                # Ensure the image is drawn at the correct position; no overlapping
                self.screen.blit(block_image, (x * self.bls, y * self.bls))

        # Draw player image at the player's position
        self.screen.blit(self.player_image, (self.player_x * self.bls, self.player_y * self.bls))

        # Update the display
        pygame.display.update()

        
    def handle_spacebar_event(self):
        self.typei = "n"
        enter_cma = int(input("Enter command? 1[yes], 0 [no]: "))
        if enter_cma == 0:
            self.typei = "k"
            self.player_x, self.player_y = 0, 0
        elif enter_cma == 1:
            input_variable = int(input("Enter command number ID (0 to 65535): "))
            pygame.event.post(pygame.event.Event(MY_CUSTOM_EVENT, {"input_variable": input_variable}))

    def handle_custom_event(self, event):
        cma = event.input_variable
        if self.typei == 'n':
            if 0 <= cma <= 65535:
                try:
                    # Execute the command from the star list
                    command_to_execute = self.star[cma]
                    exec(command_to_execute, globals(), locals())
                except IndexError:
                    print(f"Command ID {cma} is out of range.")
                except Exception as e:
                    print(f"An error occurred executing command {cma}: {e}")
            else:
                print(f"Invalid command number ID: {cma}")

    def start(self):
        self.thread = threading.Thread(target=self.run)
        self.thread.start()

    def stop(self):
        # Send a QUIT event to stop the game loop
        pygame.event.post(pygame.event.Event(pygame.QUIT))

if __name__ == "__main__":
    app = PygameApp()
    app.start()


----- Content of pyout.py -----
def read_characters_from_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        # Read the contents of the file and split by lines
        characters = file.read().splitlines()
    return characters


def generate_strings(char_set, initial_cells, num_file_systems, output_file_path):
    with open(output_file_path, "w", encoding='utf-8') as output_file:
        k = len(char_set)
        for cell_count in range(initial_cells, initial_cells + num_file_systems):
            nof = pow(k, cell_count)
            for i in range(nof):
                s = ''
                for col in range(cell_count - 1, -1, -1):
                    s += char_set[(i // pow(k, col)) % k]
                output_file.write(s + '\n')

def main():
    char_file_path = 'charSF3.txt'  # Replace with your actual file path
    output_file_path = 'pyout.txt'

    char_set = read_characters_from_file(char_file_path)
    
    try:
        initial_cells = int(input('Initial number of cells per file: '))
        num_file_systems = int(input('Number of File Systems to be generated (Starting from c Celled Files) + 1: '))
    except ValueError:
        print("Invalid input. Please enter integers only.")
        return

    generate_strings(char_set, initial_cells, num_file_systems, output_file_path)
    print("Files generated successfully and saved to pyout.txt.")

if __name__ == "__main__":
    main()


----- Content of pytoexe_manual.py -----
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
import subprocess
import threading

def select_files():
    file_paths = filedialog.askopenfilenames(filetypes=[("Python files", "*.py")])
    selected_files.set(", ".join(file_paths))

def compile_to_exe():
    files = selected_files.get().split(", ")
    one_file_option = single_exe.get()
    
    for file in files:
        with open(file, 'r') as f:
            content = f.read()

        if 'import tkinter' in content or 'from tkinter import' in content:
            hidden_import_option = '--hidden-import=_tkinter'
        else:
            hidden_import_option = ''

        if one_file_option:
            command = f"pyinstaller --onefile {hidden_import_option} {file}"
        else:
            command = f"pyinstaller {hidden_import_option} {file}"

        subprocess.run(command, shell=True)

    output_message.set("Compilation completed.")


root = tk.Tk()
root.title("Python to EXE Converter")

frame = tk.Frame(root, padx=10, pady=10)
frame.pack(padx=20, pady=20)

selected_files = tk.StringVar()
single_exe = tk.BooleanVar()
output_message = tk.StringVar()

select_button = tk.Button(frame, text="Select Python Files", command=select_files)
select_button.grid(row=0, column=0, padx=10, pady=10)

single_exe_checkbox = tk.Checkbutton(frame, text="Compile to single EXE", variable=single_exe)
single_exe_checkbox.grid(row=1, column=0, padx=10, pady=10)

compile_button = tk.Button(frame, text="Compile", command=lambda: threading.Thread(target=compile_to_exe).start())
compile_button.grid(row=2, column=0, padx=10, pady=10)

output_label = tk.Label(frame, textvariable=output_message)
output_label.grid(row=3, column=0, padx=10, pady=10)

root.mainloop()


----- Content of pytoexe_manual_.py -----
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
import subprocess
import threading

def select_files():
    file_paths = filedialog.askopenfilenames(filetypes=[("Python files", "*.py")])
    selected_files.set(", ".join(file_paths))

def compile_to_exe():
    files = selected_files.get().split(", ")
    one_file_option = single_exe.get()
    
    for file in files:
        with open(file, 'r') as f:
            content = f.read()

        if 'import tkinter' in content or 'from tkinter import' in content:
            hidden_import_option = '--hidden-import=_tkinter'
        else:
            hidden_import_option = ''

        if one_file_option:
            command = f"pyinstaller --onefile {hidden_import_option} {file}"
        else:
            command = f"pyinstaller {hidden_import_option} {file}"

        subprocess.run(command, shell=True)

    output_message.set("Compilation completed.")


root = tk.Tk()
root.title("Python to EXE Converter")

frame = tk.Frame(root, padx=10, pady=10)
frame.pack(padx=20, pady=20)

selected_files = tk.StringVar()
single_exe = tk.BooleanVar()
output_message = tk.StringVar()

select_button = tk.Button(frame, text="Select Python Files", command=select_files)
select_button.grid(row=0, column=0, padx=10, pady=10)

single_exe_checkbox = tk.Checkbutton(frame, text="Compile to single EXE", variable=single_exe)
single_exe_checkbox.grid(row=1, column=0, padx=10, pady=10)

compile_button = tk.Button(frame, text="Compile", command=lambda: threading.Thread(target=compile_to_exe).start())
compile_button.grid(row=2, column=0, padx=10, pady=10)

output_label = tk.Label(frame, textvariable=output_message)
output_label.grid(row=3, column=0, padx=10, pady=10)

root.mainloop()


----- Content of pywindows.py -----
import tkinter as tk
from tkinter import scrolledtext, ttk
import subprocess
import os
import platform
import shlex

class CustomTerminal(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Python Terminal")
        self.geometry("1000x700")

        self.command_history = []
        self.history_pointer = 0
        self.current_dir = os.getcwd()
        self.os_type = platform.system()

        self.menu_bar = tk.Menu(self)
        self.file_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.file_menu.add_command(label="New Tab", command=self.add_tab, accelerator="Ctrl+T")
        self.file_menu.add_command(label="Exit", command=self.on_closing)
        self.menu_bar.add_cascade(label="File", menu=self.file_menu)
        self.config(menu=self.menu_bar)

        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill='both')

        self.status_bar = tk.Label(self, text=f"Current directory: {self.current_dir}", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

        self.add_tab()
        self.bind("<Control-t>", lambda event: self.add_tab())

        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def add_tab(self):
        tab = ttk.Frame(self.notebook)
        text_widget = scrolledtext.ScrolledText(tab, wrap='word', state=tk.DISABLED)
        text_widget.pack(expand=True, fill='both')
        command_entry = tk.Entry(tab, bd=2, relief=tk.SUNKEN)
        command_entry.pack(fill='x', ipady=4)
        command_entry.bind('<Return>', self.execute_command)
        command_entry.bind('<Up>', self.prev_command)
        command_entry.bind('<Down>', self.next_command)

        tab.text_widget = text_widget

        self.notebook.add(tab, text=f"Terminal {self.notebook.index('end')+1}")
        self.notebook.select(tab)
        command_entry.focus()

    def execute_command(self, event):
        command_entry = event.widget
        command = command_entry.get()
        if not command.strip():
            return

        if self.os_type == "Windows":
            cmd = ['cmd.exe', '/c', command]
        else:
            cmd = ['/bin/bash', '-c', command]

        try:
            process = subprocess.Popen(cmd, cwd=self.current_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, shell=True)
            stdout, stderr = process.communicate()
            output = stdout + stderr

            if command.startswith('cd'):
                parts = shlex.split(command)
                if len(parts) > 1:
                    path = parts[1]
                    new_dir = os.path.abspath(os.path.join(self.current_dir, path))
                    if os.path.isdir(new_dir):
                        self.current_dir = new_dir
                        self.status_bar.config(text=f"Current directory: {self.current_dir}")
                    else:
                        output = f"No such directory: {path}\n"

        except Exception as e:
            output = f"Error: {e}\n"

        self.command_history.append(command)
        self.history_pointer = len(self.command_history)
        command_entry.delete(0, tk.END)
        tab = self.notebook.nametowidget(self.notebook.select())
        text_widget = tab.text_widget
        text_widget.config(state=tk.NORMAL)
        text_widget.insert(tk.END, f'{self.current_dir}> {command}\n{output}\n')
        text_widget.see(tk.END)
        text_widget.config(state=tk.DISABLED)

    def prev_command(self, event):
        command_entry = event.widget
        if self.command_history and self.history_pointer > 0:
            self.history_pointer -= 1
            command_entry.delete(0, tk.END)
            command_entry.insert(tk.END, self.command_history[self.history_pointer])

    def next_command(self, event):
        command_entry = event.widget
        if self.command_history and self.history_pointer < len(self.command_history):
            command_entry.delete(0, tk.END)
            command_entry.insert(tk.END, self.command_history[self.history_pointer])
            self.history_pointer += 1

    def on_closing(self):
        self.destroy()

if __name__ == "__main__":
    terminal = CustomTerminal()
    terminal.mainloop()


----- Content of random_pictography.py -----
from tkinter import *
import tkinter as tk
import random
import os
import time

import subprocess

import io #experiment
#import pyautogui
#from PIL import Image, experiment


print("random() : ", random.random())
master = Tk()
master.attributes('-fullscreen', True)
#a = 250
#b = 200
print("Welcome\n")
print("Tip: side length should be a factor of the image width and of the image height")
change1 = input("Enter side length of image block:  ")
change = int(change1)
#a = 1880
#b = 1050 
a1 = input("Enter width of image: ")
a = int(a1)
b1 = input ("Enter height of image:  ")
b = int(b1)
pin_p = a/change 
w = Canvas(master, width= a, height= b)


#files = 3
files_buffer = input("Enter number of files to be generated:  ")
files = int(files_buffer)

c = ["white","gold","black"]
xc = 0
zerox = 0
zeroy = 0
p = 1
range_for = int((a/change)*(b/change))
name = 1


for t in range(0,files):
    switch = 1
    for x in range(range_for):
        #f = open('%s.ps' % name, 'wb')
        #f.close
        if(switch == 1):
            row = 1
            nxleft = 0
            nxright = change
            nyleft = 0
            nyright = change
            zerox = 0
            zeroy = 0
        c_length = len(c)    
        switch = 0
        ran = random.randint(0,c_length - 1)
        w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran], outline = "black")
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran])
        #zxbuffer = zerox
        #w.place(x = zerox, y = zeroy)
        #w.place(bordermode = OUTSIDE, x = zerox + change, y = zeroy)
        w.grid(row = zeroy, column = zerox + change)
        if(p >= pin_p and p%pin_p == 0):
            zeroy = zeroy + change
            zerox = -change
            #zerox = 0
            nxleft = change
            nxright = 0
            nyleft = nyleft + change
            nyright = nyright + change
        zerox = zerox + change
        p = p + 1
        #xc + 1
        nxright = nxright + change
        if(xc == 3):
            xc = 0
    
        
    ce = str(name)
    w.update()
    w.postscript(file = ce + ".ps", colormode='color')
    name = name + 1
    #f_p = 'D:\\Kaliber\\Portfolio\\Content\\My PhotoBook\\Content\\'
    #os.rename(f_p + '1.ps', f_p + '2.ps')
    
    #process = subprocess.Popen(["ps2pdf", ce + ".ps", ce + ".pdf"], shell=True)
   

   

    
    #Contender 1 For File Saving
    """
    def savefirst():
        cnv = getscreen().getcanvas() 
        global hen
        ps = cnv.postscript(colormode = 'color')
        hen = filedialog.asksaveasfilename(defaultextension = '.jpg')
        im = Image.open(io.BytesIO(ps.encode('utf-8')))
        im.save(hen + '.jpg')
    #savefirst()
    """
    """
    Second Contender For File Saving
    def save(w):
        ps = w.canvas.postscript(colormode='color')
        img = Image.open(io.BytesIO(ps.encode('utf-8')))
        img.save('testing.jpg')
    """
#w.update()    
#script  = ce + ".ps"
#w.save(script)
#os.startfile(script)
#print(script)
print("Done")


#master.mainloop()
time.sleep(7)
master.destroy()



----- Content of rbtoexe.cpp -----
#include <iostream>
#include <cstdlib>
#include <filesystem>

int main() {
    // Get the current working directory
    std::filesystem::path current_path = std::filesystem::current_path();

    // Iterate through each file in the current directory
    for (const auto& entry : std::filesystem::directory_iterator(current_path)) {
        std::filesystem::path file_path = entry.path();
        
        // Check if the file has a .rb extension
        if (file_path.extension() == ".rb") {
            std::string run_command = "ruby " + file_path.string();
            
            // Run the .rb file
            std::cout << "Running: " << file_path.string() << std::endl;
            std::system(run_command.c_str());
        }
    }

    return 0;
}


----- Content of reconvert.cpp -----
#include <iostream>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <sstream>

using namespace std;

vector<unordered_map<string, string>> readMappings() {
    vector<unordered_map<string, string>> mappings(4);
    for (int i = 1; i <= 4; ++i) {
        ifstream file(to_string(i) + ".txt");
        if (!file) {
            cerr << "Error opening file " << i << ".txt" << endl;
            exit(EXIT_FAILURE);
        }
        string line;
        while (getline(file, line)) {
            int spacePos = line.find(' ');
            if (spacePos != string::npos) {
                string numberStr = line.substr(0, spacePos);
                string str = line.substr(spacePos + 1);
                mappings[i - 1][numberStr] = str;
            }
        }
    }
    return mappings;
}

int main() {
    auto mappings = readMappings();

    string inputFilePath;
    cout << "Enter the path of the file to re-convert: ";
    cin >> inputFilePath;

    ifstream inputFile(inputFilePath);
    if (!inputFile) {
        cerr << "Could not open the file " << inputFilePath << endl;
        exit(EXIT_FAILURE);
    }

    string line, content;
    while (getline(inputFile, line)) {
        content += line + '\n';
    }
    inputFile.close();

    stringstream ss(content);
    string token;
    string outputContent;
    while (getline(ss, token, ' ')) {
		int dotPos = token.find('.');
		if (dotPos != string::npos) {
			int len = stoi(token.substr(0, dotPos));
			string numberStr = token.substr(dotPos + 1);
			if (numberStr == "27" && len == 1) {
				outputContent += '\n';
			} else if (numberStr != "0") {
				numberStr = to_string(stoi(numberStr) - 1);
				if (mappings[len - 1].find(numberStr) != mappings[len - 1].end()) {
					outputContent += mappings[len - 1][numberStr];
				} else {
					outputContent += "?"; // Placeholder for unmapped values
				}
			}
		}
	}


    ofstream outputFile("0.txt");
    if (outputFile) {
        outputFile << outputContent;
        outputFile.close();
    } else {
        cerr << "Could not create the file 0.txt" << endl;
    }

    return 0;
}


----- Content of Renderer2.py -----
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
import math

def plot_equation(equation_type, equation, domain=(-10, 10)):
    if equation_type == "2D":
        plot_2d_curve(equation, domain)
    elif equation_type == "3D":
        plot_3d_surface(equation, domain)
    elif equation_type == "implicit":
        plot_implicit(equation, domain)
    elif equation_type == "parametric":
        plot_parametric(equation, domain)
    elif equation_type == "polar":
        plot_polar(equation, domain)

def plot_2d_curve(equation, domain):
    x = np.linspace(domain[0], domain[1], 400)
    y = eval(equation)
    plt.plot(x, y)
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.title('2D Representation of Equation')
    plt.grid(True)
    plt.show()

def plot_3d_surface(equation, domain):
    x, y = sp.symbols('x y')
    X = np.linspace(domain[0], domain[1], 100)
    Y = np.linspace(domain[0], domain[1], 100)
    X, Y = np.meshgrid(X, Y)
    
    Z_positive = np.zeros_like(X)
    Z_negative = np.zeros_like(X)
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            try:
                Z_positive[i, j] = eval(equation, {"x": X[i, j], "y": Y[i, j], "math": math})
                Z_negative[i, j] = -Z_positive[i, j]
            except ValueError:
                Z_positive[i, j] = np.nan
                Z_negative[i, j] = np.nan
    
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(X, Y, Z_positive, cmap='viridis')
    ax.plot_surface(X, Y, Z_negative, cmap='viridis')
    plt.show()



def plot_implicit(equation, domain):
    x, y = sp.symbols('x y')
    implicit_eq = sp.Eq(*map(sp.sympify, equation.split('=')))
    p1 = sp.plot_implicit(implicit_eq, (x, domain[0], domain[1]), (y, domain[0], domain[1]), show=False)
    p1.show()

def plot_parametric(equations, domain):
    t = np.linspace(domain[0], domain[1], 400)
    x_eq, y_eq = equations.split(';')
    x = eval(x_eq.split('=')[1])
    y = eval(y_eq.split('=')[1])
    plt.plot(x, y)
    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.title('Parametric Representation')
    plt.grid(True)
    plt.show()

def plot_polar(equation, domain):
    theta = np.linspace(domain[0], domain[1], 400)
    r_eq = equation.split('=')[1]
    r = eval(r_eq)
    plt.polar(theta, r)
    plt.title('Polar Representation')
    plt.grid(True)
    plt.show()

equation_type = input("Enter equation type (2D, 3D, implicit, parametric, polar): ")

if equation_type == "parametric":
    print("For parametric equations, please enter in the format x(t)=...;y(t)=...")
    equation_x = input("Enter your x(t) equation: ")
    equation_y = input("Enter your y(t) equation: ")
    equation = equation_x + ';' + equation_y
else:
    equation = input("Enter your equation: ")

domain_start = float(input("Enter domain start: "))
domain_end = float(input("Enter domain end: "))
domain = (domain_start, domain_end)

plot_equation(equation_type, equation, domain)


----- Content of SAI.py -----
def generate_strings(char_set, initial_cells, num_file_systems):
    output_file = open("pyout.txt", "w")
    k = len(char_set)
    for cell_count in range(initial_cells, initial_cells + num_file_systems):
        nof = pow(k, cell_count)
        for i in range(nof):
            s = ''
            for col in range(cell_count - 1, -1, -1):
                s += char_set[(i // pow(k, col)) % k]
            output_file.write(s + '\n')
    output_file.close()

def main():
    char_set = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", " ", "\n", "\t", "\\", "'", ",", "/", "<", ">", "?", ":", ";", "@", "#", "~", "]", "[", "{", "}", "`", "", "|", "", "!", "\"", "", "$", "%", "^", "&", "*", "(", ")", "-", "_", "+", "=", ".", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "\0"]

    try:
        initial_cells = int(input('Initial number of cells per file: '))
        num_file_systems = int(input('Number of File Systems to be generated (Starting from c Celled Files) + 1: '))
    except ValueError:
        print("Invalid input. Please enter integers only.")
        return

    generate_strings(char_set, initial_cells, num_file_systems)
    print("Files generated successfully and saved to pyout.txt.")

if __name__ == "__main__":
    main()


----- Content of Sandbox_Database_Kaliber.c -----
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

//nof = number of files
//fn = file number
//noftbc = number of files to be created
//ftd = file to delete
//ftbv = file to be viewed

int main(){
	printf("\n\n\tWelcome To The Sandbox Database Kaliber\n\n");
	printf("\n\t\t1 = yes\n\n");
	printf("\n\t\t2 = no\n\n");

	int prompt1;
	printf("\nDo you want to create files?:	");
	scanf("%d", &prompt1);
	printf("\n\nEnter file number type to be created after entering the number of files to be created.");
	//printf("\n\n");
	if(prompt1 == 1){
		int noftbc;
		int nof;
		int i;
		int ftid;
		int set_ftid;
		printf("\nEnter the number of files to be created, then the file number type:	");
		scanf("%d", &noftbc);
		printf("_");
		nof = noftbc;
		scanf("%d", &ftid);
		set_ftid = ftid;
		int fid = 0;
		for(i = 0; i < nof; i = i + 1){
			char fname[500];
			sprintf(fname, "%d_%d.txt", set_ftid, fid);
			FILE *p; p = fopen(fname, "w");
			fclose(p);
			//ftid = ftid + 1;
			fid = fid + 1;
		}
	}else{
		return 0;
	}

	/*
	int prompt_n;
	printf("\nQuestion?:	");
	scanf("d%", &prompt_n);
	printf("\n\n");
	if(prompt_n == 1 && prompt_n != 2){
		instruction statement/s;
	}
	*/

	return 0;
}


----- Content of se.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("SOLUTION_RENAME_MAX.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 27;
	puts("26 = SPACE");
	puts("27 = NEWLINE");
	puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"%d ", (id - 1));
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			fprintf(p,"\n");
			//printf("\n");
		}
	}
	if(cheque == 0){
	for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"%d ", (id - 1));
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				cell = (row/rdiv) % (k+1);
				fprintf(p,"%c", a[cell]);
			}
			fprintf(p,"\n");
			//printf("\n");
		}	
	}
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of SequentialWriterVersion3.c -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){ 
	//FILE *p; p = fopen("SOLUTION.txt","w"); 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int k, kprompt, fnum;
	k = sizeof(a) - 1;
	int soe = 0;
	puts("Set Of Elements");
	do{
		printf("\n\tElement %d = %c", soe, a[soe]);
		soe++;
	}while(soe <= k);
	printf("\n\tNumber Of Elements = %d", k + 1);
	printf("\n\tK = Number of Elements - 1");
	printf("\n\tTherefore k = %d", k);
	int noc, assert, go;
	printf("\n\tn = Number Of Cells Per File To Be Generated");
	printf("\n\n\t(k+1)^n = Number of Files To Be Generated");
	printf("\n\tEnter 2 = Search For A Specific File\n\tEnter 1 = Generate Files\n\tEnter 0 = Abort\n\n\t"); scanf("%d", &go);
	if(go == 1){
		assert = 2;
	}else if(go == 2){
		assert = 1;
	}else if(go == 0){
		assert = 0;
	}else
		assert = 3;
	//Get Files From Database and save to directory
	if(assert == 2){
		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc); printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int n = noc; int row, col; int cell; int rdiv; int id; id = 0; 
		int nbr_comb = pow(k+1, n);
		for (row=0; row < nbr_comb; row++){
			char filename[500];
			sprintf(filename, "%dC%d.txt",n,id);
			//FILE *p; p = fopen("SOLUTION.txt","w");
			FILE *p; p = fopen(filename,"w");
			id++; 
			//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
			for (col=n-1; col>=0; col--){
				rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
			}
			if(id == nbr_comb){
				fprintf(p,"\n\n\t(k+1)^n = (%d + 1)^%d = %d", k, n, id);
			}
			fclose(p);
			printf("\n");	
		}
	}
	//Get One Specific File From Database and save to active Directory
	if(assert == 1){

		printf("\n\tPlease Enter a Value For n:\t");
		scanf("%d", &noc);
		int n = noc;
		int nbr_comb = pow(k+1, n);
		printf("\n\n\tPlease Enter file number wanted between 0 and %d Inclusively:\t", nbr_comb-1);
		scanf("%d", &fnum);
		printf("\n\tNumber Of FILE Cells To Be Generated = %d", noc);
		int row, col; int cell; int rdiv; int id; id = fnum; 
		
		int sw = 1;
		for (row=0; row < nbr_comb; row++){
			if(row == fnum){
				char filename[500];
				sprintf(filename, "DQUERY%dC%d.txt",n,id);
				//FILE *p; p = fopen("SOLUTION.txt","w");
				FILE *p; p = fopen(filename,"w");
				id++;
				//fprintf(p,"\n\n\n\nFILE%d\n\n\n\n", id); 
				for (col=n-1; col>=0; col--){
					rdiv = pow(k+1, col); cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				sw = 0;
				}
			if(sw == 0)
				break;
				
			}
				
		}
		
		
	}
	
	
	if(assert == 0 || assert == 3){
		puts("exiting");
	}
	return 0;
} 


----- Content of sequential_pictographyV10.py -----
from tkinter import *
import tkinter as tk
import random
import os
import math

import subprocess

import io #experiment
#import pyautogui
#from PIL import Image, experiment


print("random() : ", random.random())
master = Tk()
master.attributes('-fullscreen', True)
#a = 250
#b = 200
print("Welcome\n")
print("Tip: side length should be a factor of the image width and of the image height")
change1 = input("Enter side length of image block:  ")
change = int(change1)
#a = 1880
#b = 1050 
a1 = input("Enter width of image: ")
a = int(a1)
b1 = input ("Enter height of image:  ")
b = int(b1)
pin_p = a/change 
w = Canvas(master, width= a, height= b)


#files = 3
#files_buffer = input("Enter number of files to be generated (8^((width/side_length)*(height/side_length)):  ")
#files = int(files_buffer)

#c = ["red","blue","yellow","brown","purple","pink","green","orange"]

#c = ["red","blue","yellow","brown","purple","pink","green","orange","grey","white"]

c = ["white", "black", "green", "red", "blue", "yellow"]
xc = 0
zerox = 0
zeroy = 0
p = 1
range_for = int((a/change)*(b/change))
name = 1
cells = ((a//change)*(b//change))
upper = cells - 1
nbr_comb = math.pow(len(c),cells)
files = int(nbr_comb)
#print(len(c))
rown = 0
#rdiv = math.pow(len(c),cells - 1)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)

#rdiv = math.pow(len(c),cells - 2)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)
#def rone(h,j,l):
#    cell = (h/j) % l
#    celled = int(cell
#    w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = c[celled])
file_count = 0    
for t in range(0,files):
    file_count = file_count + 1
    #if(file_count == 121):
    #    break
    switch = 1
    sw = 0
    #for x in range(range_for):
    #for x in range (0,cells):
    x = 0
    col = cells - 1
    #print(rown)
    while(x < cells):
        
        #f = open('%s.ps' % name, 'wb')
        #f.close
        if(switch == 1):
            row = 1
            nxleft = 0
            nxright = change
            nyleft = 0
            nyright = change
            zerox = 0
            zeroy = 0
        c_length = len(c)    
        switch = 0
        #ran = random.randint(0,c_length - 1)

        rdiv = math.pow(len(c),col)
        cell = (rown/rdiv) % (len(c))
        #rone(row,rdiv,len(c))
        #print(cell)
        #print(rdiv)
        celled = int(cell)
        print(celled)
        #print(cell)
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran], outline = c[ran])
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = c[celled], width = 0)
        w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = "black", width = 0)
        if(x <= cells):
            col = col - 1
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran])
        #zxbuffer = zerox
        #w.place(x = zerox, y = zeroy)
        #w.place(bordermode = OUTSIDE, x = zerox + change, y = zeroy)
        w.grid(row = zeroy, column = zerox + change)
        if(p >= pin_p and p%pin_p == 0):
            zeroy = zeroy + change
            zerox = -change
            #zerox = 0
            nxleft = change
            nxright = 0
            nyleft = nyleft + change
            nyright = nyright + change
        zerox = zerox + change
        p = p + 1
        #xc + 1
        nxright = nxright + change
        if(xc == 3):
            xc = 0
        x = x + 1    
    rown = rown + 1
    ce = str(name)
    w.update()
    w.postscript(file = ce + ".ps", colormode='color')
    name = name + 1
    #f_p = 'D:\\Kaliber\\Portfolio\\Content\\My PhotoBook\\Content\\'
    #os.rename(f_p + '1.ps', f_p + '2.ps')
    
    #process = subprocess.Popen(["ps2pdf", ce + ".ps", ce + ".pdf"], shell=True)
   

   

    
    #Contender 1 For File Saving
    """
    def savefirst():
        cnv = getscreen().getcanvas() 
        global hen
        ps = cnv.postscript(colormode = 'color')
        hen = filedialog.asksaveasfilename(defaultextension = '.jpg')
        im = Image.open(io.BytesIO(ps.encode('utf-8')))
        im.save(hen + '.jpg')
    #savefirst()
    """
    """
    Second Contender For File Saving
    def save(w):
        ps = w.canvas.postscript(colormode='color')
        img = Image.open(io.BytesIO(ps.encode('utf-8')))
        img.save('testing.jpg')
    """
#w.update()    
#script  = ce + ".ps"
#w.save(script)
#os.startfile(script)
#print(script)
print("Done")


#master.mainloop()


----- Content of sequential_pictographyV11.py -----
from tkinter import *
import tkinter as tk
import random
import os
import math

import subprocess

import io #experiment
#import pyautogui
#from PIL import Image, experiment


print("random() : ", random.random())
master = Tk()
master.attributes('-fullscreen', True)
#a = 250
#b = 200
print("Welcome\n")
print("Tip: side length should be a factor of the image width and of the image height")
change1 = input("Enter side length of image block:  ")
change = int(change1)
#a = 1880
#b = 1050 
a1 = input("Enter width of image: ")
a = int(a1)
b1 = input ("Enter height of image:  ")
b = int(b1)
pin_p = a/change 
w = Canvas(master, width= a, height= b)

c = ["red", "green", "blue"]
xc = 0
zerox = 0
zeroy = 0
p = 1
range_for = int((a/change)*(b/change))
name = 1
cells = ((a//change)*(b//change))
upper = cells - 1
nbr_comb = math.pow(len(c),cells)
files = int(nbr_comb)
#print(len(c))
rown = 0

file_count = 0    
for t in range(0,files):
    file_count = file_count + 1
    #if(file_count == 121):
    #    break
    switch = 1
    sw = 0
    #for x in range(range_for):
    #for x in range (0,cells):
    x = 0
    col = cells - 1
    #print(rown)
    while(x < cells):
        
        #f = open('%s.ps' % name, 'wb')
        #f.close
        if(switch == 1):
            row = 1
            nxleft = 0
            nxright = change
            nyleft = 0
            nyright = change
            zerox = 0
            zeroy = 0
        c_length = len(c)    
        switch = 0
        #ran = random.randint(0,c_length - 1)

        rdiv = math.pow(len(c),col)
        cell = (rown/rdiv) % (len(c))

        celled = int(cell)
        print(celled)

        w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = "black", width = 0)
        if(x <= cells):
            col = col - 1

        w.grid(row = zeroy, column = zerox + change)
        if(p >= pin_p and p%pin_p == 0):
            zeroy = zeroy + change
            zerox = -change
            #zerox = 0
            nxleft = change
            nxright = 0
            nyleft = nyleft + change
            nyright = nyright + change
        zerox = zerox + change
        p = p + 1
        #xc + 1
        nxright = nxright + change
        if(xc == 3):
            xc = 0
        x = x + 1    
    rown = rown + 1
    ce = str(name)
    w.update()
    #w.postscript(file = ce + ".ps", colormode='color')
    w.postscript(file=ce + ".ps", colormode='color', x=0, y=0, width=a, height=b)
    name = name + 1

print("Done")


#master.mainloop()


----- Content of Signal Simulator.py -----
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


def connect_particles(particle_a, particle_b):
    # Connects the two particles with a line segment
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot([particle_a[0], particle_b[0]], [particle_a[1], particle_b[1]], [particle_a[2], particle_b[2]])
    plt.show()


def disconnect_particles(particle_a, particle_b):
    # Disconnects the two particles by removing the line segment connecting them
    pass


def move_forward(particle_a, particle_b, a, b):
    # Moves the particles forward by a specified amount
    particle_a += a
    particle_b += b
    return particle_a, particle_b


def move_backward(particle_a, particle_b, c, d):
    # Moves the particles backward by a specified amount
    particle_a -= c
    particle_b -= d
    return particle_a, particle_b


def move_leftward(particle_a, particle_b, e, f):
    # Moves the particles leftward by a specified amount
    particle_a[0] -= e
    particle_b[0] -= f
    return particle_a, particle_b


def move_rightward(particle_a, particle_b, g, h):
    # Moves the particles rightward by a specified amount
    particle_a[0] += g
    particle_b[0] += h
    return particle_a, particle_b


def move_upward(particle_a, particle_b, i, j):
    # Moves the particles upward by a specified amount
    particle_a[1] += i
    particle_b[1] += j
    return particle_a, particle_b


def move_downward(particle_a, particle_b, k, l):
    # Moves the particles downward by a specified amount
    particle_a[1] -= k
    particle_b[1] -= l
    return particle_a, particle_b


def save_gif(coordinates):
    # Saves the sequence of coordinates as a GIF file
    pass


def main():
    particle_a = np.array([0, 0, 0])  # Initial position of particle A
    particle_b = np.array([1, 1, 1])  # Initial position of particle B
    coordinates = [particle_a.copy(), particle_b.copy()]  # Stores the sequence of coordinates

    while True:
        print("Choose an option:")
        print("0. Connect the two particles")
        print("1. Disconnect the two particles")
        print("2. Move forward")
        print("3. Move backward")
        print("4. Move leftward")
        print("5. Move rightward")
        print("6. Move upward")
        print("7. Move downward")
        print("8. End program and save output as a GIF")

        option = int(input("Enter your option: "))

        if option == 0:
            connect_particles(particle_a, particle_b)
        elif option == 1:
            disconnect_particles(particle_a, particle_b)
        elif option == 2:
            a = int(input("Enter the amount to move particle A forward: "))
            b = int(input("Enter the amount to move particle B forward: "))
            particle_a, particle_b = move_forward(particle_a, particle_b, a, b)
        elif option == 3:
            c = int(input("Enter the amount to move particle A backward: "))
            d = int(input("Enter the amount to move particle B backward: "))
            particle_a, particle_b = move_backward(particle_a, particle_b, c, d)
        elif option == 4:
            e = int(input("Enter the amount to move particle A leftward: "))
            f = int(input("Enter the amount to move particle B leftward: "))
            particle_a, particle_b = move_leftward(particle_a, particle_b, e, f)
        elif option == 5:
            g = int(input("Enter the amount to move particle A rightward: "))
            h = int(input("Enter the amount to move particle B rightward: "))
            particle_a, particle_b = move_rightward(particle_a, particle_b, g, h)
        elif option == 6:
            i = int(input("Enter the amount to move particle A upward: "))
            j = int(input("Enter the amount to move particle B upward: "))
            particle_a, particle_b = move_upward(particle_a, particle_b, i, j)
        elif option == 7:
            k = int(input("Enter the amount to move particle A downward: "))
            l = int(input("Enter the amount to move particle B downward: "))
            particle_a, particle_b = move_downward(particle_a, particle_b, k, l)
        elif option == 8:
            save_gif(coordinates)
            break
        else:
            print("Invalid option!")

        coordinates.append(particle_a.copy())
        coordinates.append(particle_b.copy())


if __name__ == "__main__":
    main()


----- Content of SignalProcessing.py -----
import numpy as np
from scipy.signal import lfilter
from scipy.fftpack import fft

# transitions.txt:
# Purpose: Defines the transition rules for the DFSM.
# Format: Each line represents a transition rule, formatted as <current state> <input condition> <next state>.
# Example:
#   Start condition1 Middle
#   Middle condition2 End

# filter_coeffs.txt:
# Purpose: Defines the coefficients for the digital filter.
# Format: Two numbers representing the coefficients b and a for the digital filter, separated by whitespace.
# Example:
#   0.1 0.9

# fft_settings.txt:
# Purpose: Defines the settings for the Fourier Transform operation.
# Format: A single number representing the number of points to use in the Fourier Transform.
# Example:
#   256

# accepting_conditions.txt:
# Purpose: Defines the conditions under which a state is considered to be an accepting state.
# Format: Each line represents an accepting condition for a state, formatted as <state> <condition>.
# Example:
#   End condition3

# input.txt:
# Purpose: Contains the input signals for the DFSM to process.
# Format: Each line represents an input signal, with the signal values separated by whitespace.
# Example:
#   0.1 0.2 0.3 0.4
#   0.5 0.6 0.7 0.8


class DeterministicFSM:
    def __init__(self):
        self.state = 'Start'
        self.transitions = {}
        self.accepting_conditions = {}

    def load_transitions(self, filename):
        with open(filename, 'r') as file:
            for line in file:
                state, input_condition, next_state = line.strip().split()
                self.transitions[(state, input_condition)] = next_state

    def load_accepting_conditions(self, filename):
        with open(filename, 'r') as file:
            for line in file:
                state, condition = line.strip().split()
                self.accepting_conditions[state] = condition

    def transition(self, input_signal):
        # Apply digital filtering
        with open('filter_coeffs.txt', 'r') as file:
            b, a = map(float, file.read().strip().split())
        filtered_signal = lfilter([b], [a, -1], input_signal)

        # Perform Fourier Transform
        with open('fft_settings.txt', 'r') as file:
            n = int(file.read().strip())
        fft_result = fft(filtered_signal, n)

        # Determine transition based on processing results
        input_condition = 'condition1'  # Define conditions based on processing results
        self.state = self.transitions.get((self.state, input_condition), self.state)

    def is_in_accepting_state(self):
        condition = self.accepting_conditions.get(self.state)
        # Evaluate condition based on current state and/or processing results
        # ...

# Usage
dfsm = DeterministicFSM()
dfsm.load_transitions('transitions.txt')
dfsm.load_accepting_conditions('accepting_conditions.txt')

# Assume input.txt contains input signals, one per line
with open('input.txt', 'r') as file:
    input_signals = [list(map(float, line.strip().split())) for line in file]

output_lines = []
for signal in input_signals:
    dfsm.transition(signal)
    output_lines.append(f'Current State: {dfsm.state}')

# Check acceptance
output_lines.append(f'Is in accepting state: {dfsm.is_in_accepting_state()}')

# Write output to file
with open('dfsm_o.txt', 'w') as file:
    file.write('\n'.join(output_lines))

#Note... Note yet Tested. In Beta

----- Content of simple_os.py -----
import tkinter as tk
from tkinter import ttk, filedialog
import os
import subprocess

class SimpleOS:
    def __init__(self, root):
        self.root = root
        self.root.title("SimpleOS")
        self.root.geometry("800x600")
        self.current_directory = os.getcwd()  # Set initial directory to the working directory
        self.create_menu()

    def create_menu(self):
        menu = tk.Menu(self.root)
        
        app_menu = tk.Menu(menu, tearoff=0)
        self.update_app_menu(app_menu)
        
        menu.add_cascade(label="Applications", menu=app_menu)
        
        settings_menu = tk.Menu(menu, tearoff=0)
        settings_menu.add_command(label="Change Directory", command=self.change_directory)
        
        menu.add_cascade(label="Settings", menu=settings_menu)
        
        self.root.config(menu=menu)

    def update_app_menu(self, app_menu):
        app_menu.delete(0, tk.END)  # Clear existing menu items
        for filename in os.listdir(self.current_directory):
            if filename.endswith('.exe'):
                app_menu.add_command(label=filename, command=lambda f=filename: self.run_file(f))

    def run_file(self, filename):
        filepath = os.path.join(self.current_directory, filename)
        if filename.endswith('.exe'):
            subprocess.run([filepath])

    def change_directory(self):
        new_directory = filedialog.askdirectory()
        if new_directory:
            self.current_directory = new_directory
            self.create_menu()  # Re-create the menu to reflect the new directory

if __name__ == "__main__":
    root = tk.Tk()
    app = SimpleOS(root)
    root.mainloop()


----- Content of Solution.rb -----
ar = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"," ","\n","\t","\\","\"",',',"#","~","]","[","{","}","`","","|","","!","'","","$","%","^","&","*","(",")","-","_","+","=","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z", "0", "1" , "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9", "/","<",">",",",":",";","@","?","\0"]

print ar
k = ar.length - 1
p = k + 1
puts p;
row = 0
id = 0
print "\n\nNumber of cells per file:	";
nocs = gets
noc = nocs.to_i

nbr_comb = (k+1)**noc
f = File.open("Solution_rb_rename.txt", "w+")
while row < nbr_comb do
	id = id + 1
	f.print "File", id
	f.print "\n"
	col = noc - 1
	while col >= 0 do
		rdiv = (k + 1)**col
		cell = (row/rdiv) % (k+1)
		#buffer = ar[cell]
		col = col - 1
		f.puts ar[cell]
	end
	row = row + 1
end

f.close()


----- Content of SOLUTION_MAX.cpp -----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("SOLUTION_RENAME_MAX.txt","w");
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 100;
	puts("26 = SPACE");
	puts("27 = NEWLINE");
	puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"\n\nF%d\n\n", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			//printf("\n");
		}
	}
	if(cheque == 0){
	for (row=0; row < nbr_comb; row++){
			id++;  fprintf(p,"\n\nF%d\n\n", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				cell = (row/rdiv) % (k+1);
				fprintf(p,"%c", a[cell]);
			}
			//printf("\n");
		}	
	}
	fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of SOLUTION_MAX_Instruction_Set.cpp -----
//SOLUTION_MAX.cpp, written by Dominic Alexander Cooper (Database of Files from the given set of elements/ functions, that being a).
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;
//put together by Dominic Alexander Cooper
int main(){
	//Code Adapted by DAC from lyst on https://stackoverflow.com
	//k+1 = no. of elements
	//n = exponent = number of cells
	//the k and n values must perfectly fit the size of the set of elements in question
	FILE *p; p = fopen("Instruction_Set_Rename.txt","w");
	//char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_',' +','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	char a[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}; 
	int pin;
	
	int pr, pc;
	printf("\nLet us begin\n\n");
	pc = 97;
	//puts("26 = SPACE");
	//puts("27 = NEWLINE");
	//puts("28 = TAB");
	puts("");
	for(pr = 0; pr < pc; pr++){
		printf("%d	%c\n", pr, a[pr]);
	}
	
	int cheque;
	cout << "Enter the size of your array: ";
	cin >> pin;
	cout << "Do you want to create a custom array? ";
	cin >> cheque;
	int array[pin], inn, position;
	if(cheque == 1){
		cout << "\n\n Enter the " << pin << " elements of your array: \n\n";
		for(inn = 0; inn < pin; inn++){
			cin >> array[inn];
		}
	}
	//char a[] = {'1','2','3','4','p1','p2','p3','p4','p5','p6'};
	//char b[] = {'a','b'};
	//char c[] = {'0','1','2','3'};
	//int n = 4; //int k = 3; //int n = x;
	//int k = 100;
	
	//int k = strlen(a) - 1;
	int k;
	k = pin - 1;
	printf("\n\tk = %d", k);
	int noc; printf("\n\tn = ");
	scanf("%d", &noc);
	printf("\n\tNumber Of FILE Cells = %d", noc);
	int n = noc;
	int row, col;
	int cell;
	int rdiv;
	unsigned long long id;
	id = 0;
	int rin;
	int nbr_comb = pow(k+1, n);
	if(cheque == 1){
		for (row=0; row < nbr_comb; row++){
			id++;
			//fprintf(p,"\n\nF%d\n\n", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				//cell = (row/rdiv) % (k+1); fprintf(p,"%c", a[cell]);
				
				cell = (row/rdiv) % (k+1);
				rin = array[cell];
				fprintf(p,"%c", a[rin]);
			}
			fprintf(p,"\n");
		}
	}
	if(cheque == 0){
	for (row=0; row < nbr_comb; row++){
			id++;
			//fprintf(p,"\n\nF%d\n\n", id);
			for (col=n-1; col>=0; col--){  rdiv = pow(k+1, col);
				cell = (row/rdiv) % (k+1);
				fprintf(p,"%c", a[cell]);
			}
			fprintf(p,"\n");
		}	
	}
	//fprintf(p,"\n\nend.(k+1)^n = (%d + 1)^%d = %d", k, n, id);
	fclose(p);
	//end of adaptation
	return 0;
}


----- Content of Statement-Informatics.py -----
from tkinter import *
import tkinter as tk
#from PIL.Image import core as _imaging
import random
import os
import math
import time
import sys
import subprocess
from array import *


import io #experiment

from PIL.Image import Image
from PIL import Image
import PIL
a = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ','\n','\t','\\','\'',',','/','<','>','?',':',';','@','#','~',']','[','{','}','`','','|','','!','"','','$','%','^','&','*','(',')','-','_','+','=','.','A','B','C','D','E','F','G','H', 'I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9']
#import pyautogui
#from PIL import Image, experiment

#get Statement from file   [DONE]

#--use Statement from file
#if element from statement matches a[iteration], then print "id number, " to Sequence file to be named by operator. and reset id number
#elif element from statement does not match a[iteration] iterate id number by 1
#elif id is above cell count, then print system failure and pause for 12 seconds.

#use Sequence buffer
#if element is found in statement, print gold pixel
#if element is not found in statement, print white pixel
#save image to directory file


time.sleep(3)

gi1 = input("input 'statement_id.txt': ")
gi2 = input("input 'sequence_id.txt': ")
gi3 = input("input Image 'id': ")

s_f = open(gi2, "w")
s_f.close()
s_f = open(gi2, "a")

print("Note: Statement file is named (Within the directory of this program)... 'statement_id.txt'")
xgv = input("Have you entered your statement (1 = yes, 0 = no)? ...")
if(xgv == '1'):
    print("Then Let Us Go ...")
elif(xgv == '0'):
    sys.exit(1)
elif(xgv != '1' and xgv != '0'):
    print("error")
    time.sleep(3)
    sys.exit(1)

st_f = open(gi1, "r")
st_buff = ['0']
got = st_f.read()
while(got != ''):
    print(got)
    st_buff.extend(got)
    got = st_f.read()
del st_buff[0]
print(st_buff)

#...

conda = len(st_buff)
yields = 0
yeldo = input("Number of Characters in your Language:")
yeldo_ = int(yeldo)
iter_99 = 0
iter_98 = -1
benine = ['0']
pnaf = len(a)
#s13 = 1
while(iter_99 < conda):

    if(iter_98 < yeldo_):
        iter_98 = iter_98 + 1
    if(iter_98 == yeldo_):
        iter_98 = 0
    
    if(st_buff[iter_99] == a[iter_98]):
        solumn_ = str(iter_98 + 1)
        s_f.write(solumn_)
        s_f.write(' ')
        benine.append(iter_98 + 1)
        iter_99 = iter_99 + 1
    yields = yields + 1

    

del benine[0]

print(benine)
print("Length of array is ...")
print(conda)







print("random() : ", random.random())
master = Tk()
master.attributes('-fullscreen', True)
#a = 250
#b = 200
print("Welcome\n")
print("Tip: side length should be a factor of the image width and of the image height")
change1 = input("Enter side length of image block:  ")
change = int(change1)
#a = 1880
#b = 1050 
a1 = input("Enter width of image: ")
a = int(a1)
b1 = input ("Enter height of image:  ")
b = int(b1)
pin_p = a/change 
w = Canvas(master, width= a, height= b)
#psv = getscreen().getcanvas()


#files = 3
#files_buffer = input("Enter number of files to be generated (8^((width/side_length)*(height/side_length)):  ")
#files = int(files_buffer)

#c = ["red","blue","yellow","brown","purple","pink","green","orange"]
c = ["gold"]
xc = 0
zerox = 0
zeroy = 0
p = 1
range_for = int((a/change)*(b/change))
name = 1
cells = ((a//change)*(b//change))
upper = cells - 1
nbr_comb = math.pow(len(c),cells)
files = int(nbr_comb)
#print(len(c))
rown = 0
#rdiv = math.pow(len(c),cells - 1)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)

#rdiv = math.pow(len(c),cells - 2)
#print(rdiv)
#cell = (row/rdiv) % (len(c))
#print(cell)
#def rone(h,j,l):
#    cell = (h/j) % l
#    celled = int(cell
#    w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = c[celled])
file_count = 0
st_f.close()
s_f.close()
#giilp = 1
aiilp = 0
#for t in range(0,files):
x_coun = 0
create_a = ['0']
z_coun = 0
dcoun = 0
lk = 0

if(conda > 100):
    print("Max Characters allowed: 100")
    time.sleep(5)
    sys.exit(1)
    
while(z_coun < cells):
    create_a.append(lk)
    z_coun = z_coun + 1
zcoun = 0


while(zcoun < conda):
    create_a[benine[zcoun]] = benine[dcoun]
    zcoun = zcoun + 1
    dcoun = dcoun + 1
    
del create_a[0]

print(create_a)
zcoun = 0
tr_ = len(create_a)
print(tr_)
for t in range(0,files):
    file_count = file_count + 1
    #if(file_count == 121):
    #    break
    switch = 1
    sw = 0
    #for x in range(range_for):
    #for x in range (0,cells):
    x = 0
    col = cells - 1
    #print(rown)
    pixlp = 0
    while(x < cells):
        
        #f = open('%s.ps' % name, 'wb')
        #f.close
        if(switch == 1):
            row = 1
            nxleft = 0
            nxright = change
            nyleft = 0
            nyright = change
            zerox = 0
            zeroy = 0
        c_length = len(c)    
        switch = 0
        #ran = random.randint(0,c_length - 1)

        rdiv = math.pow(len(c),col)
        cell = (rown/rdiv) % (len(c))
        #rone(row,rdiv,len(c))
        #print(cell)
        #print(rdiv)
        celled = int(cell)
        #print(celled)
        #print(cell)
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran], outline = c[ran])

        kij = st_buff[aiilp]
        
        #for inh in range(0,100*conda):
       
        if(create_a[zcoun] > 0):
            w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[celled], outline = "green", width = 0)     
            #giilp = 0
            #zcoun += 1
    
        if(create_a[zcoun] == 0):
            w.create_rectangle(zerox, nyleft, nxright,nyright, fill = "purple", outline = "black", width = 0)

        zcoun = zcoun + 1
            
        #z_coun = z_coun + 1
        #pixlp = 0
        #if(giilp > 100):
        #    giilp = 0

        
        
            
        if(x <= cells):
            col = col - 1
        #w.create_rectangle(zerox, nyleft, nxright,nyright, fill = c[ran])
        #zxbuffer = zerox
        #w.place(x = zerox, y = zeroy)
        #w.place(bordermode = OUTSIDE, x = zerox + change, y = zeroy)
        w.grid(row = zeroy, column = zerox + change)
        if(p >= pin_p and p%pin_p == 0):
            zeroy = zeroy + change
            zerox = -change
            #zerox = 0
            nxleft = change
            nxright = 0
            nyleft = nyleft + change
            nyright = nyright + change
        zerox = zerox + change
        p = p + 1
        #xc + 1
        nxright = nxright + change
        if(xc == 3):
            xc = 0
        x = x + 1    
    rown = rown + 1
    ce = str(name)
    w.update()


    

    def savefirst():
        w.postscript(file = 'M' + gi3 + '.ps', colormode='color')

    savefirst()

    name = name + 1
    #f_p = 'D:\\Kaliber\\Portfolio\\Content\\My PhotoBook\\Content\\'
    #os.rename(f_p + '1.ps', f_p + '2.ps')
    
    #process = subprocess.Popen(["ps2pdf", ce + ".ps", ce + ".pdf"], shell=True)
   

   

    
    #Contender 1 For File Saving
    """
    def savefirst():
        cnv = getscreen().getcanvas() 
        global hen
        ps = cnv.postscript(colormode = 'color')
        hen = filedialog.asksaveasfilename(defaultextension = '.jpg')
        im = Image.open(io.BytesIO(ps.encode('utf-8')))
        im.save(hen + '.jpg')
    #savefirst()
    """
    """
    Second Contender For File Saving
    def save(w):
        ps = w.canvas.postscript(colormode='color')
        img = Image.open(io.BytesIO(ps.encode('utf-8')))
        img.save('testing.jpg')
    """
#w.update()    
#script  = ce + ".ps"
#w.save(script)
#os.startfile(script)
#print(script)
print("Done")


#master.mainloop()


----- Content of StudyPlanner.py -----
import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random
import math
import json  # For logging

# Initialize cube states
cube_states = {}
for x in range(11):
    for y in range(11):
        for z in range(11):
            cube_states[(x, y, z)] = 'RED'

# Colors for different states
colors = [
    [1, 0, 0],  # Red for unmastered topics
    [0, 1, 0],  # Green for familiar topics
    [0, 0, 1]   # Blue for mastered topics
]

# Function to read cube states from a text file
def read_states_from_file(filename):
    color_map = {'Red': 0, 'Green': 1, 'Blue': 2}
    with open(filename, 'r') as f:
        lines = f.readlines()
    states = {}
    for index, line in enumerate(lines):
        color = line.strip()
        x, y, z = get_cube_coordinates(index, 11)  # Assuming side_length is 11
        states[(x, y, z)] = color_map.get(color, 0)  # Default to 0 (Red) if color is not recognized
    return states

# Function to get cube coordinates based on its index
def get_cube_coordinates(index, side_length):
    x = index // (side_length * side_length)
    y = (index % (side_length * side_length)) // side_length
    z = index % side_length
    return x, y, z

# Read states from a text file
cube_states = read_states_from_file('cube_states.txt')

# Function to draw a cube at (x, y, z)
def draw_cube(x, y, z, color):
    vertices = [
        [x, y, z],
        [x + 1, y, z],
        [x + 1, y + 1, z],
        [x, y + 1, z],
        [x, y, z - 1],
        [x + 1, y, z - 1],
        [x + 1, y + 1, z - 1],
        [x, y + 1, z - 1],
    ]
    faces = [
        (0, 1, 2, 3),
        (3, 2, 7, 6),
        (6, 7, 5, 4),
        (4, 5, 1, 0),
        (1, 5, 6, 2),
        (4, 0, 3, 7),
    ]
    glBegin(GL_QUADS)
    glColor3fv(color)
    for face in faces:
        for vertex in face:
            glVertex3fv(vertices[vertex])
    glEnd()

# Function to change the state of a cube
def change_state(x, y, z):
    current_state = cube_states[(x, y, z)]
    if current_state == 'RED':
        cube_states[(x, y, z)] = 'GREEN'
    elif current_state == 'GREEN':
        cube_states[(x, y, z)] = 'BLUE'
    elif current_state == 'BLUE':
        cube_states[(x, y, z)] = 'RED'

print("")

# Initialize Pygame
pygame.init()
display = (900, 700)
pygame.display.set_mode(display, DOUBLEBUF | OPENGL)
gluPerspective(45, (display[0] / display[1]), 0.1, 50.0)
glTranslatef(0.0, 0.0, -40)

# Initialize selected cube coordinates and previous selected cube
selected_x, selected_y, selected_z = 0, 0, 0
prev_selected_x, prev_selected_y, prev_selected_z = None, None, None

# Function to get the index of a cube based on its coordinates
def get_cube_index(x, y, z, side_length):
    return x * side_length * side_length + y * side_length + z

# Initialize rotation angles
x_angle = 0
y_angle = 0


# Initialize log
state_log = []

# Main Loop
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            # Save log to a file
            with open('state_log.json', 'w') as f:
                json.dump(state_log, f)
            pygame.quit()
            quit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                y_angle -= 5
            elif event.key == pygame.K_RIGHT:
                y_angle += 5
            elif event.key == pygame.K_UP:
                x_angle -= 5
            elif event.key == pygame.K_DOWN:
                x_angle += 5
            elif event.key == pygame.K_w:  # Move selection up
                selected_y += 1
            elif event.key == pygame.K_s:  # Move selection down
                selected_y -= 1
            elif event.key == pygame.K_a:  # Move selection left
                selected_x -= 1
            elif event.key == pygame.K_d:  # Move selection right
                selected_x += 1
            elif event.key == pygame.K_q:  # Move selection backward
                selected_z -= 1
            elif event.key == pygame.K_e:  # Move selection forward
                selected_z += 1
            elif event.key == pygame.K_SPACE:  # Change state of selected cube
                change_state(selected_x, selected_y, selected_z)
                state_log.append({'coords': (selected_x, selected_y, selected_z), 'new_state': cube_states[(selected_x, selected_y, selected_z)]})

    # Print the index and coordinates only if the selected cube has changed
    if (selected_x, selected_y, selected_z) != (prev_selected_x, prev_selected_y, prev_selected_z):
        index = get_cube_index(selected_x, selected_y, selected_z, 11)  # Assuming side_length is 11
        print(f"Selected Cube Index: {index}, Coordinates: ({selected_x}, {selected_y}, {selected_z})")
        prev_selected_x, prev_selected_y, prev_selected_z = selected_x, selected_y, selected_z

    
    glPushMatrix()
    glRotatef(x_angle, 1, 0, 0)
    glRotatef(y_angle, 0, 1, 0)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    # Draw smaller cubes to form a larger cube
    for x in range(11):
        for y in range(11):
            for z in range(11):
                color_index = cube_states.get((x, y, z), 0)  # Default to 0 (Red) if key is not found
                color = colors[color_index]  # Map the state to its corresponding color
                draw_cube(x * 2 - 10, y * 2 - 10, z * 2 - 10, color)

    glPopMatrix()

    pygame.display.flip()
    pygame.time.wait(50)


----- Content of Tally.py -----
import tkinter as tk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pickle

class TallyCounterApp:
    def __init__(self, master):
        self.master = master
        master.title("Tally Counter")

        # Variables
        self.tally = 0
        self.tally_history = [0]
        self.time_step = 0

        # User inputs for increment and decrement
        self.increment_value = tk.IntVar(value=1)
        self.decrement_value = tk.IntVar(value=1)

        # Layout
        self.label = tk.Label(master, text="Tally: 0")
        self.label.pack()

        self.increment_entry = tk.Entry(master, textvariable=self.increment_value)
        self.increment_entry.pack()

        self.decrement_entry = tk.Entry(master, textvariable=self.decrement_value)
        self.decrement_entry.pack()

        self.increase_button = tk.Button(master, text="Increase", command=self.increase_tally)
        self.increase_button.pack()

        self.decrease_button = tk.Button(master, text="Decrease", command=self.decrease_tally)
        self.decrease_button.pack()

        # Save and Load buttons
        self.save_button = tk.Button(master, text="Save Session", command=self.save_session)
        self.save_button.pack()

        self.load_button = tk.Button(master, text="Load Session", command=self.load_session)
        self.load_button.pack()
    
        # Chart
        self.fig = Figure(figsize=(5, 4), dpi=100)
        self.plot = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=master)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack()


        self.update_plot()

    def increase_tally(self):
        self.tally += self.increment_value.get()
        self.update_tally()

    def decrease_tally(self):
        self.tally -= self.decrement_value.get()
        self.update_tally()

    def update_tally(self):
        self.label.config(text=f"Tally: {self.tally}")
        self.tally_history.append(self.tally)
        self.time_step += 1
        self.update_plot()

    def update_plot(self):
        self.plot.clear()
        self.plot.plot(range(self.time_step + 1), self.tally_history, marker='o')
        self.plot.set_title("Tally Over Time")
        self.canvas.draw()

    def save_session(self):
        with open('tally_session.pkl', 'wb') as f:
            pickle.dump({'tally': self.tally, 'tally_history': self.tally_history, 'time_step': self.time_step}, f)
        print("Session saved!")

    def load_session(self):
        try:
            with open('tally_session.pkl', 'rb') as f:
                session_data = pickle.load(f)
                self.tally = session_data['tally']
                self.tally_history = session_data['tally_history']
                self.time_step = session_data['time_step']
                self.update_tally()
        except FileNotFoundError:
            print("No saved session found.")

root = tk.Tk()
app = TallyCounterApp(root)
root.mainloop()


----- Content of Terminal.py -----
import tkinter as tk
from tkinter import scrolledtext, ttk
import subprocess
import os
import platform

class CustomTerminal(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Python Terminal")
        self.geometry("1000x700")
        
        # Command history list and current directory
        self.command_history = []
        self.history_pointer = 0
        self.current_dir = os.getcwd()

        # Identify the OS type
        self.os_type = platform.system()

        # Menu bar
        self.menu_bar = tk.Menu(self)
        self.file_menu = tk.Menu(self.menu_bar, tearoff=0)
        self.file_menu.add_command(label="New Tab", command=self.add_tab, accelerator="Ctrl+T")
        self.file_menu.add_command(label="Exit", command=self.on_closing)
        self.menu_bar.add_cascade(label="File", menu=self.file_menu)
        self.config(menu=self.menu_bar)

        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill='both')
        
        self.add_tab()
        self.bind("<Control-t>", lambda event: self.add_tab())

        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def add_tab(self):
        tab = ttk.Frame(self.notebook)
        text_widget = scrolledtext.ScrolledText(tab, wrap='word')
        text_widget.pack(expand=True, fill='both')
        command_entry = tk.Entry(tab)
        command_entry.pack(fill='x')
        command_entry.bind('<Return>', self.execute_command)
        command_entry.bind('<Up>', self.prev_command)
        command_entry.bind('<Down>', self.next_command)

        tab.text_widget = text_widget

        self.notebook.add(tab, text="Terminal")
        self.notebook.select(tab)
        command_entry.focus()

    def execute_command(self, event):
        command_entry = event.widget
        command = command_entry.get()
        if not command:
            return

        # Choose the shell based on OS type
        if self.os_type == "Windows":
            cmd = ['cmd.exe', '/c', command]
        else:
            cmd = ['/bin/bash', '-c', command]

        try:
            process = subprocess.Popen(cmd, cwd=self.current_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate()
            output = stdout + stderr

            # Update the current directory if 'cd' command is used
            if command.startswith('cd '):
                path = command.split(' ', 1)[1]
                self.current_dir = os.path.join(self.current_dir, path)

        except Exception as e:
            output = f"Error: {e}\n"

        self.command_history.append(command)
        self.history_pointer = len(self.command_history)
        command_entry.delete(0, tk.END)
        tab = self.notebook.nametowidget(self.notebook.select())
        text_widget = tab.text_widget
        text_widget.insert(tk.END, f'> {command}\n{output}')
        text_widget.see(tk.END)

    def prev_command(self, event):
        command_entry = event.widget
        if self.command_history and self.history_pointer > 0:
            self.history_pointer -= 1
            command_entry.delete(0, tk.END)
            command_entry.insert(tk.END, self.command_history[self.history_pointer])

    def next_command(self, event):
        command_entry = event.widget
        if self.command_history and self.history_pointer < len(self.command_history) - 1:
            self.history_pointer += 1
            command_entry.delete(0, tk.END)
            command_entry.insert(tk.END, self.command_history[self.history_pointer])
        else:
            command_entry.delete(0, tk.END)

    def on_closing(self):
        self.destroy()

if __name__ == "__main__":
    terminal = CustomTerminal()
    terminal.mainloop()


----- Content of textFileEdit2.cpp -----
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::string filename;
    std::cout << "Enter the text file name: ";
    std::cin >> filename;

    std::ifstream inputFile(filename);
    if (!inputFile.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return 1;
    }

    std::vector<std::string> lines;
    std::string line;
    while (std::getline(inputFile, line)) {
        lines.push_back(line);
    }
    inputFile.close();

    int option;
    while (true) {
        std::cout << "\nChoose an option:\n"
                  << "1. Edit a line\n"
                  << "2. Delete a line\n"
                  << "3. Add a line\n"
                  << "4. View a specific line\n"
                  << "5. Save and exit\n"
                  << "Option: ";
        std::cin >> option;

        if (option == 1) {
            size_t lineNo;
            std::cout << "Enter the line number to edit: ";
            std::cin >> lineNo;
            std::cin.ignore();

            if (lineNo > 0 && lineNo <= lines.size()) {
                std::cout << "Enter the new text for the line: ";
                std::getline(std::cin, line);
                lines[lineNo - 1] = line;
            } else {
                std::cout << "Invalid line number!\n";
            }
        } else if (option == 2) {
            size_t lineNo;
            std::cout << "Enter the line number to delete: ";
            std::cin >> lineNo;

            if (lineNo > 0 && lineNo <= lines.size()) {
                lines.erase(lines.begin() + lineNo - 1);
            } else {
                std::cout << "Invalid line number!\n";
            }
        } else if (option == 3) {
            std::cout << "Enter the text for the new line: ";
            std::cin.ignore();
            std::getline(std::cin, line);
            lines.push_back(line);
        } else if (option == 4) {
            size_t lineNo;
            std::cout << "Enter the line number to view: ";
            std::cin >> lineNo;

            if (lineNo > 0 && lineNo <= lines.size()) {
                std::cout << "Line " << lineNo << ": " << lines[lineNo - 1] << std::endl;
            } else {
                std::cout << "Invalid line number!\n";
            }
        } else if (option == 5) {
            break;
        } else {
            std::cout << "Invalid option!\n";
        }
    }

    std::ofstream outputFile(filename, std::ios::trunc);
    if (!outputFile.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return 1;
    }

    for (const auto& l : lines) {
        outputFile << l << std::endl;
    }
    outputFile.close();

    std::cout << "Changes saved successfully.\n";

    return 0;
}


----- Content of ULang-integers.py -----
# Unicode escape sequence
unicode_escape = input("Unicode for equivalent integer code: e.g. '\\uE031': ")

# Remove the '\\u' prefix and convert the remaining hexadecimal number to an integer
integer_number = int(unicode_escape[2:], 16)

print(f"The integer representation of '{unicode_escape}' is {integer_number}.")


