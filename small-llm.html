<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmallLLM - Deterministic Pattern Matching System</title>
    <style>
        :root {
            /* Color scheme */
            --bg-main: #1a1a24;
            --bg-light: #222230;
            --bg-lighter: #2d2d3a;
            --bg-dark: #12121a;
            --primary-color: #0088cc;
            --accent-color: #00cc88;
            --accent-blue: #3498db;
            --accent-purple: #9b59b6;
            --accent-orange: #e67e22;
            --accent-red: #e74c3c;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --text-bright: #ffffff;
            --text-normal: #ccccdd;
            --text-dim: #a0a0b0;
            --border: #333344;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;

            /* Border radius */
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 12px;

            /* Typography */
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-md: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;

            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-normal);
            line-height: 1.6;
        }

        header {
            background-color: var(--bg-dark);
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: var(--font-size-xl);
            color: var(--text-bright);
            font-weight: 600;
        }

        .app-subtitle {
            font-size: var(--font-size-xs);
            color: var(--text-dim);
            font-family: monospace;
            margin-top: 2px;
        }

        nav {
            background-color: var(--bg-dark);
            padding: var(--spacing-xs) var(--spacing-md);
            border-bottom: 1px solid var(--border);
        }

        nav ul {
            display: flex;
            list-style: none;
        }

        nav a {
            color: var(--text-dim);
            text-decoration: none;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            margin-right: var(--spacing-sm);
            transition: background-color var(--transition-fast);
        }

        nav a:hover {
            background-color: var(--bg-lighter);
            color: var(--text-bright);
        }

        nav a.active {
            background-color: var(--primary-color);
            color: var(--text-bright);
        }

        main {
            padding: var(--spacing-md);
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Sections */
        section {
            margin-bottom: var(--spacing-lg);
        }

        .section-title {
            color: var(--text-bright);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 1px solid var(--border);
        }

        .hidden-section {
            display: none;
        }

        /* Chat interface */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 70vh;
            min-height: 400px;
            border: 1px solid var(--border);
            border-radius: var(--border-radius-md);
            overflow: hidden;
        }

        .chat-header {
            background-color: var(--bg-dark);
            padding: var(--spacing-sm) var(--spacing-md);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .message {
            max-width: 85%;
            padding: var(--spacing-md);
            border-radius: var(--border-radius-md);
            position: relative;
        }

        .message.user {
            align-self: flex-end;
            background-color: var(--primary-color);
            color: var(--text-bright);
            border-bottom-right-radius: 0;
        }

        .message.system {
            align-self: flex-start;
            background-color: var(--bg-light);
            border-bottom-left-radius: 0;
        }

        .message.thinking {
            align-self: flex-start;
            background-color: var(--bg-lighter);
            color: var(--text-dim);
            border-bottom-left-radius: 0;
            font-style: italic;
        }

        .message-content {
            word-break: break-word;
        }

        .message-controls {
            margin-top: var(--spacing-xs);
            display: flex;
            justify-content: flex-end;
        }

        .copy-message-button {
            background-color: transparent;
            border: none;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            cursor: pointer;
            padding: var(--spacing-xs);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-sm);
        }

        .copy-message-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-bright);
        }

        .copy-message-button.copied {
            color: var(--accent-color);
        }

        .chat-input-container {
            padding: var(--spacing-md);
            border-top: 1px solid var(--border);
            display: flex;
            gap: var(--spacing-md);
        }

        .chat-input-wrapper {
            flex-grow: 1;
            position: relative;
        }

        #user-input {
            width: 100%;
            min-height: 50px;
            max-height: 150px;
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            background-color: var(--bg-lighter);
            color: var(--text-bright);
            border: 1px solid var(--border);
            resize: vertical;
            font-family: inherit;
            font-size: var(--font-size-md);
        }

        #user-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .chat-options {
            padding: var(--spacing-md);
            background-color: var(--bg-light);
            border-radius: var(--border-radius-sm);
            display: flex;
            gap: var(--spacing-md);
            align-items: center;
            flex-wrap: wrap;
        }

        .option-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        /* Training section */
        .training-section {
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            background-color: var(--bg-light);
        }

        .training-title {
            color: var(--text-bright);
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .training-title .training-number {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 24px;
            height: 24px;
            background-color: var(--primary-color);
            color: var(--text-bright);
            border-radius: 50%;
            font-size: var(--font-size-sm);
        }

        .char-map-container {
            margin-bottom: var(--spacing-md);
        }

        .char-map-controls {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .char-map-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: var(--spacing-xs);
            margin-top: var(--spacing-sm);
            max-height: 250px;
            overflow-y: auto;
            padding: var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            background-color: var(--bg-main);
        }

        .char-map-item {
            background-color: var(--bg-lighter);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-xs);
            text-align: center;
            position: relative;
            font-family: monospace;
        }

        .char-map-value {
            font-size: var(--font-size-md);
        }

        .char-map-index {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 7px;
            color: var(--text-dim);
        }

        .char-map-status {
            font-family: monospace;
            color: var(--text-dim);
            font-size: var(--font-size-sm);
            margin-top: var(--spacing-xs);
        }

        #training-file-container {
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-md);
            border: 2px dashed var(--border);
            border-radius: var(--border-radius-sm);
            background-color: var(--bg-main);
            text-align: center;
            transition: all var(--transition-fast);
        }

        #training-file-container.drag-over {
            border-color: var(--primary-color);
            background-color: rgba(0, 136, 204, 0.1);
        }

        .training-file-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-md);
        }

        .training-file-icon {
            font-size: 48px;
            color: var(--text-dim);
        }

        .training-file-text {
            color: var(--text-normal);
        }

        .training-file-button {
            padding: var(--spacing-sm) var(--spacing-md);
            background-color: var(--primary-color);
            color: var(--text-bright);
            border: none;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .training-file-button:hover {
            background-color: #0099ee;
        }

        #training-file-input {
            display: none;
        }

        #training-status {
            margin-top: var(--spacing-md);
            background-color: var(--bg-dark);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            display: none;
        }

        #training-status.active {
            display: block;
        }

        .training-status-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing-md);
        }

        .training-status-header h3 {
            color: var(--text-bright);
        }

        #status-message {
            font-family: monospace;
            color: var(--accent-color);
            margin-top: var(--spacing-sm);
        }

        .matrix-visualization {
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            gap: 1px;
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .matrix-cell {
            background-color: var(--bg-lighter);
            color: var(--accent-color);
            width: 100%;
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            font-size: 10px;
        }

        #training-results {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: var(--bg-lighter);
            border-radius: var(--border-radius-sm);
            border-left: 3px solid var(--accent-color);
        }

        .results-pattern,
        .results-response {
            background-color: var(--bg-main);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            overflow-x: auto;
            white-space: pre-wrap;
            margin: var(--spacing-sm) 0;
            font-family: monospace;
        }

        .button-container {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        /* Form elements */
        button {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-md);
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .primary-button {
            background-color: var(--primary-color);
            color: var(--text-bright);
            border: none;
        }

        .primary-button:hover {
            background-color: #0099ee;
        }

        .secondary-button {
            background-color: var(--bg-lighter);
            color: var(--text-normal);
            border: 1px solid var(--border);
        }

        .secondary-button:hover {
            background-color: var(--bg-dark);
            color: var(--text-bright);
        }

        .warning-button {
            background-color: var(--bg-lighter);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }

        .warning-button:hover {
            background-color: var(--warning-color);
            color: var(--text-bright);
        }

        select {
            padding: var(--spacing-xs) var(--spacing-sm);
            background-color: var(--bg-lighter);
            color: var(--text-normal);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
        }

        select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        label {
            color: var(--text-dim);
            font-size: var(--font-size-sm);
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        /* Knowledge base */
        .kb-controls {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
        }

        .kb-search-container {
            flex-grow: 1;
            position: relative;
        }

        #kb-search {
            width: 100%;
            padding: var(--spacing-sm);
            background-color: var(--bg-lighter);
            color: var(--text-bright);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
        }

        #kb-search:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .kb-filter-container {
            display: flex;
            gap: var(--spacing-sm);
        }

        .kb-table-container {
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: left;
            padding: var(--spacing-sm);
            background-color: var(--bg-dark);
            color: var(--text-bright);
            border-bottom: 2px solid var(--primary-color);
        }

        td {
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border);
        }

        tbody tr:hover {
            background-color: var(--bg-lighter);
        }

        .trusted-fact {
            background-color: rgba(0, 204, 136, 0.05);
        }

        .untrusted-fact {
            background-color: rgba(231, 76, 60, 0.05);
        }

        .trusted-badge {
            padding: 2px 6px;
            background-color: rgba(0, 204, 136, 0.2);
            color: var(--accent-color);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-xs);
        }

        .untrusted-badge {
            padding: 2px 6px;
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--error-color);
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-xs);
        }

        .kb-pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .kb-stats {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: var(--bg-light);
            border-radius: var(--border-radius-sm);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
        }

        .kb-stat-card {
            background-color: var(--bg-dark);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            text-align: center;
        }

        .kb-stat-value {
            font-size: var(--font-size-xl);
            color: var(--text-bright);
            font-weight: bold;
        }

        .kb-stat-label {
            color: var(--text-dim);
            font-size: var(--font-size-sm);
            margin-top: var(--spacing-xs);
        }

        /* Settings section */
        .settings-section {
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-md);
            background-color: var(--bg-light);
            border-radius: var(--border-radius-sm);
        }

        .settings-section h3 {
            color: var(--text-bright);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 1px solid var(--border);
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .setting-label {
            min-width: 180px;
            color: var(--text-normal);
        }

        .setting-control {
            flex-grow: 1;
        }

        .setting-description {
            margin-top: var(--spacing-xs);
            color: var(--text-dim);
            font-size: var(--font-size-sm);
            margin-bottom: var(--spacing-md);
        }

        /* Source section and code blocks */
        .sources-section {
            margin-top: var(--spacing-lg);
            padding: var(--spacing-md);
            background-color: var(--bg-light);
            border-radius: var(--border-radius-sm);
            border-left: 3px solid var(--primary-color);
        }

        .unverified-content {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: rgba(231, 76, 60, 0.05);
            border-radius: var(--border-radius-sm);
            border-left: 3px solid var(--warning-color);
        }

        .unverified-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
            color: var(--warning-color);
        }

        .unverified-footer {
            color: var(--text-dim);
            font-style: italic;
            margin-top: var(--spacing-sm);
        }

        /* Code formatting */
        .code-block-wrapper {
            position: relative;
            margin: var(--spacing-md) 0;
        }

        pre.code-block {
            background-color: var(--bg-dark);
            color: var(--text-bright);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            overflow-x: auto;
            white-space: pre;
            margin: 0;
            border: 1px solid var(--border);
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: var(--font-size-sm);
            line-height: 1.5;
        }

        code {
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: var(--bg-dark);
            color: var(--accent-color);
            padding: 0.2em 0.4em;
            border-radius: var(--border-radius-sm);
            font-size: 0.9em;
        }

        pre.code-block code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
            color: inherit;
        }

        .copy-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: var(--bg-main);
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity var(--transition-fast);
        }

        .copy-button:hover {
            opacity: 1;
            background-color: var(--bg-lighter);
        }

        .copy-button.copied {
            color: var(--accent-color);
            border-color: var(--accent-color);
            opacity: 1;
        }

        /* Null check pattern styling */
        .null-value {
            color: var(--text-dim);
            font-style: italic;
        }

        .empty-value {
            color: var(--text-dim);
        }

        .special-char {
            color: var(--accent-purple);
        }

        .control-char {
            color: var(--accent-red);
        }

        .space-char {
            color: var(--accent-blue);
        }

        /* Language specific styling */
        pre.language-javascript {
            border-left: 3px solid var(--accent-color);
        }

        pre.language-python {
            border-left: 3px solid var(--accent-purple);
        }

        pre.language-html {
            border-left: 3px solid var(--accent-orange);
        }

        pre.language-css {
            border-left: 3px solid var(--primary-color);
        }

        pre.language-c {
            border-left: 3px solid var(--accent-blue);
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--bg-dark);
            color: var(--text-normal);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-sm);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
            max-width: 300px;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Modal dialog */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        .modal-content {
            background-color: var(--bg-main);
            margin: auto;
            padding: 0;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            margin: 0;
            font-size: 20px;
            color: var(--text-bright);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-dim);
            cursor: pointer;
        }

        .modal-close:hover {
            color: var(--text-bright);
        }

        .modal-body {
            padding: 20px;
            max-height: calc(90vh - 140px);
            overflow-y: auto;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Pattern Debug Styles */
        .pattern-debug-list {
            max-height: 400px;
            overflow-y: auto;
            margin: var(--spacing-md) 0;
        }

        .pattern-debug-item {
            display: flex;
            margin-bottom: var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            background-color: var(--bg-light);
            overflow: hidden;
        }

        .pattern-index {
            background-color: var(--primary-color);
            color: var(--text-bright);
            padding: var(--spacing-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            min-width: 40px;
        }

        .pattern-details {
            padding: var(--spacing-sm);
            flex: 1;
        }

        .pattern-details > div {
            margin-bottom: var(--spacing-xs);
        }

        .debug-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        /* Footer */
        footer {
            background-color: var(--bg-dark);
            padding: var(--spacing-md);
            margin-top: var(--spacing-xl);
            border-top: 1px solid var(--border);
            text-align: center;
            color: var(--text-dim);
            font-size: var(--font-size-sm);
        }

        .footer-links {
            margin-top: var(--spacing-sm);
        }

        .footer-links a {
            color: var(--primary-color);
            text-decoration: none;
            margin: 0 var(--spacing-sm);
        }

        .footer-links a:hover {
            text-decoration: underline;
        }

        /* Drag file indicator */
        body.drag-highlight:after {
            content: "Drop Your Training File Here";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: var(--text-bright);
            font-size: 2rem;
            z-index: 1000;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .chat-options {
                flex-direction: column;
                align-items: flex-start;
            }

            .option-group {
                width: 100%;
            }

            .kb-controls {
                flex-direction: column;
            }

            .kb-filter-container {
                width: 100%;
            }

            .kb-stat-card {
                padding: var(--spacing-sm);
            }

            .debug-actions {
                flex-direction: column;
            }

            .modal-content {
                width: 95%;
            }
        }

        /* Verification message styling */
        .verification-message {
            margin-top: var(--spacing-md);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            background-color: var(--bg-dark);
        }

        .verification-checking {
            color: var(--text-dim);
            font-style: italic;
        }

        .verification-success {
            color: var(--accent-color);
        }

        .verification-warning {
            color: var(--warning-color);
        }

        .verification-error {
            color: var(--error-color);
        }

        .verification-help {
            color: var(--text-dim);
            font-size: var(--font-size-sm);
            margin-top: var(--spacing-xs);
        }

        .pattern-count {
            background-color: var(--bg-light);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            display: inline-block;
        }

        /* JSON example */
        .json-example {
            background-color: var(--bg-dark);
            padding: var(--spacing-md);
            border-radius: var(--border-radius-sm);
            overflow-x: auto;
            margin: var(--spacing-md) 0;
            font-family: monospace;
            white-space: pre;
            color: var(--text-normal);
        }

        .json-example .key {
            color: var(--accent-purple);
        }

        .json-example .string {
            color: var(--accent-color);
        }

        .json-example .number {
            color: var(--accent-orange);
        }

        .json-example .boolean {
            color: var(--primary-color);
        }

        /* Session info styling */
        .session-stats {
            background-color: var(--bg-light);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
        }

        .stat-group {
            display: flex;
            justify-content: space-around;
            gap: var(--spacing-md);
        }

        .stat-divider {
            height: 1px;
            background-color: var(--border);
            margin: var(--spacing-md) 0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-item.large .stat-value {
            font-size: var(--font-size-xl);
            color: var(--primary-color);
        }

        .stat-value {
            display: block;
            font-size: var(--font-size-lg);
            font-weight: 500;
            color: var(--accent-color);
        }

        .stat-label {
            display: block;
            font-size: var(--font-size-sm);
            color: var(--text-dim);
            margin-top: var(--spacing-xs);
        }

        .default-session-indicator {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: var(--accent-color);
            color: var(--bg-dark);
            padding: 5px 10px;
            border-radius: var(--border-radius-sm);
            font-size: var(--font-size-xs);
            z-index: 100;
            opacity: 0.8;
            transition: opacity var(--transition-fast);
        }

        .default-session-indicator:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <header>
        <div class="app-header">
            <div class="app-title">SmallLLM</div>
            <div class="app-subtitle">DETERMINISTIC PATTERN RECOGNITION SYSTEM 303530</div>
        </div>
        <div class="app-version">v1.0.0</div>
    </header>

    <nav>
        <ul>
            <li><a href="#" id="nav-home" class="active">Home</a></li>
            <li><a href="#" id="nav-train">Train</a></li>
            <li><a href="#" id="nav-knowledge-base">Knowledge Base</a></li>
            <li><a href="#" id="nav-database">Database</a></li>
            <li><a href="#" id="nav-settings">Settings</a></li>
        </ul>
    </nav>

    <main>
        <!-- Home Section (Chat Interface) -->
        <section id="section-home" class="active-section">
            <h2 class="section-title">Interactive Chat</h2>
            
            <div class="chat-options">
                <div class="option-group">
                    <label for="domain-filter">Domain:</label>
                    <select id="domain-filter">
                        <option value="all">All Domains</option>
                        <option value="general">General Knowledge</option>
                        <option value="science">Science</option>
                        <option value="history">History</option>
                        <option value="law">Law</option>
                        <option value="technology">Technology</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="include-unverified">
                        <input type="checkbox" id="include-unverified">
                        Include unverified information
                    </label>
                </div>
            </div>
            
            <div class="chat-container">
                <div class="chat-header">
                    <div>SmallLLM Chat</div>
                    <div class="chat-controls">
                        <button id="clear-button" class="secondary-button">Clear Chat</button>
                    </div>
                </div>
                
                <div id="chat-history" class="chat-history">
                    <div class="message system">
                        <div class="message-content">
                            <p>Welcome to SmallLLM! I'm a pattern-based deterministic knowledge system. I can only respond to questions that match patterns I've been trained on.</p>
                            <p>To get started, upload a training file on the Train page or ask me something from my existing knowledge.</p>
                        </div>
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <div class="chat-input-wrapper">
                        <textarea id="user-input" placeholder="Type your message here..."></textarea>
                    </div>
                    <button id="send-button" class="primary-button">Send</button>
                </div>
            </div>
        </section>
        
        <!-- Train Section -->
        <section id="section-train" class="hidden-section">
            <h2 class="section-title">Training System</h2>
            
            <div class="training-section">
                <h3 class="training-title">
                    <span class="training-number">1</span>
                    Character Mapping Configuration
                </h3>
                
                <div class="char-map-container">
                    <div class="char-map-controls">
                        <button id="create-standard-map" class="primary-button">Create Standard Map</button>
                        <button id="import-custom-map" class="secondary-button">Import Custom Map</button>
                    </div>
                    
                    <div id="char-map-grid" class="char-map-grid">
                        <div class="grid-placeholder">No character map loaded</div>
                    </div>
                    
                    <div id="char-map-status" class="char-map-status">STATUS: NO CHARACTER MAP LOADED</div>
                </div>
            </div>
            
            <div class="training-section">
                <h3 class="training-title">
                    <span class="training-number">2</span>
                    Upload Training File
                </h3>
                
                <p>Upload a JSON file containing pattern-response pairs, facts, and constraints. This will train the system to recognize patterns and respond appropriately.</p>
                
                <div id="training-file-container">
                    <div class="training-file-content">
                        <div class="training-file-icon">📄</div>
                        <div class="training-file-text">Drag & drop your training file here, or click to browse</div>
                        <button id="browse-file-button" class="training-file-button">Browse Files</button>
                        <input type="file" id="training-file-input" accept=".json">
                    </div>
                </div>
                
                <h4>Training File Format</h4>
                <p>Your JSON training file should follow this structure:</p>
                
                <div class="json-example">
<span class="key">{</span>
  <span class="key">"patterns"</span>: [
    <span class="key">{</span>
      <span class="key">"id"</span>: <span class="string">"pattern1"</span>,
      <span class="key">"pattern"</span>: <span class="string">"Hello"</span>,
      <span class="key">"response"</span>: <span class="string">"Hello! I'm SmallLLM, a deterministic language model."</span>,
      <span class="key">"factIds"</span>: [<span class="number">1</span>, <span class="number">2</span>],
      <span class="key">"constraints"</span>: <span class="key">{</span>
        <span class="key">"caseSensitive"</span>: <span class="boolean">false</span>,
        <span class="key">"exactMatch"</span>: <span class="boolean">false</span>,
        <span class="key">"substringMatch"</span>: <span class="boolean">true</span>
      <span class="key">}</span>
    <span class="key">}</span>,
    <span class="key">{</span>
      <span class="key">"id"</span>: <span class="string">"pattern2"</span>,
      <span class="key">"pattern"</span>: <span class="string">"What is SmallLLM?"</span>,
      <span class="key">"response"</span>: <span class="string">"SmallLLM is a deterministic pattern-matching system that returns predefined responses."</span>,
      <span class="key">"factIds"</span>: [<span class="number">1</span>],
      <span class="key">"constraints"</span>: <span class="key">{</span>
        <span class="key">"caseSensitive"</span>: <span class="boolean">false</span>,
        <span class="key">"exactMatch"</span>: <span class="boolean">true</span>,
        <span class="key">"substringMatch"</span>: <span class="boolean">false</span>
      <span class="key">}</span>
    <span class="key">}</span>
  ],
  <span class="key">"facts"</span>: <span class="key">{</span>
    <span class="key">"1"</span>: <span class="key">{</span>
      <span class="key">"id"</span>: <span class="number">1</span>,
      <span class="key">"text"</span>: <span class="string">"SmallLLM is a deterministic knowledge-based language model."</span>,
      <span class="key">"source"</span>: <span class="string">"SmallLLM Documentation"</span>,
      <span class="key">"domain"</span>: <span class="string">"technology"</span>,
      <span class="key">"trusted"</span>: <span class="boolean">true</span>,
      <span class="key">"timestamp"</span>: <span class="number">1712153105000</span>
    <span class="key">}</span>,
    <span class="key">"2"</span>: <span class="key">{</span>
      <span class="key">"id"</span>: <span class="number">2</span>,
      <span class="key">"text"</span>: <span class="string">"Unlike probabilistic models, SmallLLM uses exact pattern matching."</span>,
      <span class="key">"source"</span>: <span class="string">"SmallLLM Documentation"</span>,
      <span class="key">"domain"</span>: <span class="string">"technology"</span>,
      <span class="key">"trusted"</span>: <span class="boolean">true</span>,
      <span class="key">"timestamp"</span>: <span class="number">1712153105000</span>
    <span class="key">}</span>
  <span class="key">}</span>,
  <span class="key">"factIdCounter"</span>: <span class="number">3</span>
<span class="key">}</span>
                </div>
                
                <div id="training-status" class="hidden">
                    <div class="training-status-header">
                        <h3>Training Progress</h3>
                    </div>
                    
                    <div id="status-message">PROCESSING TRAINING FILE...</div>
                    
                    <div id="matrix-visualization-grid" class="matrix-visualization"></div>
                    
                    <div id="training-results"></div>
                </div>
            </div>
        </section>
        
        <!-- Knowledge Base Section -->
        <section id="section-knowledge-base" class="hidden-section">
            <h2 class="section-title">Knowledge Base</h2>
            
            <div class="kb-controls">
                <div class="kb-search-container">
                    <input type="text" id="kb-search" placeholder="Search facts...">
                </div>
                
                <div class="kb-filter-container">
                    <select id="kb-domain-filter">
                        <option value="all">All Domains</option>
                        <option value="general">General Knowledge</option>
                        <option value="science">Science</option>
                        <option value="history">History</option>
                        <option value="law">Law</option>
                        <option value="technology">Technology</option>
                    </select>
                    
                    <select id="kb-trusted-filter">
                        <option value="all">All Facts</option>
                        <option value="trusted">Trusted Only</option>
                        <option value="untrusted">Untrusted Only</option>
                    </select>
                </div>
            </div>
            
            <div class="kb-table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Fact</th>
                            <th>Domain</th>
                            <th>Source</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="kb-table-body">
                        <!-- Facts will be added here dynamically -->
                    </tbody>
                </table>
            </div>
            
            <div class="kb-pagination">
                <button id="kb-prev-page" class="secondary-button" disabled>Previous</button>
                <div id="kb-page-info">Page 1 of 1</div>
                <button id="kb-next-page" class="secondary-button" disabled>Next</button>
            </div>
            
            <div class="kb-stats">
                <div class="kb-stat-card">
                    <div id="kb-total-facts" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Total Facts</div>
                </div>
                
                <div class="kb-stat-card">
                    <div id="kb-trusted-facts" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Trusted Facts</div>
                </div>
                
                <div class="kb-stat-card">
                    <div id="kb-domains" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Domains</div>
                </div>
            </div>
        </section>
        
        <!-- Database Section -->
        <section id="section-database" class="hidden-section">
            <h2 class="section-title">Database View</h2>
            
            <div class="kb-controls">
                <div class="kb-search-container">
                    <input type="text" id="db-search" placeholder="Search database...">
                </div>
                
                <div class="kb-filter-container">
                    <select id="db-domain-filter">
                        <option value="all">All Domains</option>
                        <option value="general">General Knowledge</option>
                        <option value="science">Science</option>
                        <option value="history">History</option>
                        <option value="law">Law</option>
                        <option value="technology">Technology</option>
                    </select>
                    
                    <select id="db-sort-by">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="domain">By Domain</option>
                        <option value="trusted">By Verification</option>
                    </select>
                </div>
            </div>
            
            <div class="kb-table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Fact</th>
                            <th>Domain</th>
                            <th>Source</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="database-table-body">
                        <!-- Facts will be added here dynamically -->
                    </tbody>
                </table>
            </div>
            
            <div class="kb-pagination">
                <button id="db-prev-page" class="secondary-button" disabled>Previous</button>
                <div id="db-page-info">Page 1 of 1</div>
                <button id="db-next-page" class="secondary-button" disabled>Next</button>
            </div>
            
            <div class="kb-stats">
                <div class="kb-stat-card">
                    <div id="db-total-facts" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Total Facts</div>
                </div>
                
                <div class="kb-stat-card">
                    <div id="db-trusted-facts" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Trusted Facts</div>
                </div>
                
                <div class="kb-stat-card">
                    <div id="db-untrusted-facts" class="kb-stat-value">0</div>
                    <div class="kb-stat-label">Untrusted Facts</div>
                </div>
            </div>
        </section>
        
        <!-- Settings Section -->
        <section id="section-settings" class="hidden-section">
            <h2 class="section-title">Settings</h2>
            
            <div class="settings-section">
                <h3>Response Settings</h3>
                
                <div class="setting-row">
                    <div class="setting-label">Show Sources</div>
                    <div class="setting-control">
                        <label>
                            <input type="checkbox" id="show-sources" checked>
                            Include source information in responses
                        </label>
                    </div>
                </div>
                
                <div class="setting-row">
                    <div class="setting-label">Response Style</div>
                    <div class="setting-control">
                        <select id="response-style">
                            <option value="concise">Concise</option>
                            <option value="detailed">Detailed</option>
                            <option value="academic">Academic</option>
                            <option value="simple">Simple</option>
                        </select>
                    </div>
                </div>
                
                <div class="setting-row">
                    <div class="setting-label">Database Mode</div>
                    <div class="setting-control">
                        <label>
                            <input type="checkbox" id="enable-database-mode">
                            Enable database mode by default
                        </label>
                    </div>
                </div>
                
                <p class="setting-description">
                    These settings control how SmallLLM generates responses from matched patterns.
                </p>
                
                <div class="button-container">
                    <button id="save-settings-button" class="primary-button">Save Settings</button>
                    <button id="reset-settings-button" class="secondary-button">Reset to Defaults</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Knowledge Base Management</h3>
                
                <p class="setting-description">
                    Export or import your knowledge base, or completely reset it.
                </p>
                
                <div class="button-container">
                    <button id="export-kb-button" class="secondary-button">Export Knowledge Base</button>
                    <button id="import-kb-button" class="secondary-button">Import Knowledge Base</button>
                    <button id="reset-kb-button" class="warning-button">Reset Knowledge Base</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Character Map Management</h3>
                
                <p class="setting-description">
                    Save or load your character map configuration.
                </p>
                
                <div class="button-container">
                    <button id="save-char-map" class="secondary-button">Save Character Map</button>
                    <button id="load-char-map" class="secondary-button">Load Character Map</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Session Management</h3>
                
                <p class="setting-description">
                    Save or load your entire session, including knowledge base, patterns, and settings.
                </p>
                
                <div class="button-container">
                    <button id="save-session-button" class="secondary-button">Export Session</button>
                    <button id="load-session-button" class="secondary-button">Import Session</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Debug Tools</h3>
                
                <div class="setting-row">
                    <button id="debug-patterns-button" class="secondary-button">Debug Patterns</button>
                    <button id="debug-test-input-button" class="secondary-button">Test Input Matching</button>
                </div>
                
                <p class="setting-description">
                    Tools to help diagnose issues with pattern matching and response generation.
                </p>
            </div>
        </section>
    </main>
    
    <footer>
        <div>SmallLLM - A Deterministic Pattern Matching System</div>
        <div class="footer-links">
            <a href="#" id="footer-about">About</a>
            <a href="#" id="footer-docs">Documentation</a>
            <a href="#" id="footer-session-info">Session Info</a>
            <a href="#" id="save-data-link">Save Data</a>
        </div>
    </footer>
    
    <!-- Modal -->
    <div id="main-modal" class="modal" role="dialog" aria-modal="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" class="modal-title">Modal Title</h2>
                <button class="modal-close" aria-label="Close modal">&times;</button>
            </div>
            <div id="modal-body" class="modal-body">
                <!-- Modal content goes here -->
            </div>
            <div id="modal-footer" class="modal-footer">
                <!-- Modal buttons go here -->
            </div>
        </div>
    </div>
    
    <script>
        /**
         * SmallLLM - A complete implementation of a deterministic pattern matching system
         * This monolithic version allows uploading training data files
         */
        
        // Knowledge Base Class
        class KnowledgeBase {
            constructor() {
                this.facts = {};
                this.factIdCounter = 1;
            }
            
            addFact(text, source, domain = 'general', trusted = true) {
                const factId = this.factIdCounter++;
                
                this.facts[factId] = {
                    id: factId,
                    text: text,
                    source: source,
                    domain: domain,
                    trusted: trusted,
                    timestamp: Date.now()
                };
                
                return factId;
            }
            
            updateFact(factId, text, source, domain, trusted) {
                if (!this.facts[factId]) {
                    throw new Error(`Fact with ID ${factId} not found`);
                }
                
                this.facts[factId].text = text;
                this.facts[factId].source = source;
                this.facts[factId].domain = domain;
                this.facts[factId].trusted = trusted;
                this.facts[factId].timestamp = Date.now();
                
                return factId;
            }
            
            removeFact(factId) {
                if (!this.facts[factId]) {
                    return false;
                }
                
                delete this.facts[factId];
                return true;
            }
            
            getFact(factId) {
                return this.facts[factId];
            }
            
            getAllFacts() {
                return Object.values(this.facts);
            }
            
            getFactCount() {
                return Object.keys(this.facts).length;
            }
            
            getTrustedFactCount() {
                return Object.values(this.facts).filter(fact => fact.trusted).length;
            }
            
            getDomainCount() {
                const domains = new Set();
                
                Object.values(this.facts).forEach(fact => {
                    domains.add(fact.domain);
                });
                
                return domains.size;
            }
            
            clear() {
                this.facts = {};
                this.factIdCounter = 1;
            }
            
            /**
             * Serialize the knowledge base to JSON
             */
            toJSON() {
                try {
                    const data = {
                        facts: this.facts,
                        factIdCounter: this.factIdCounter
                    };
                    
                    return JSON.stringify(data);
                } catch (error) {
                    console.error("Error serializing knowledge base:", error);
                    return JSON.stringify({ facts: {}, factIdCounter: 1 });
                }
            }
            
            /**
             * Load knowledge base from JSON
             */
            fromJSON(jsonData) {
                try {
                    if (!jsonData) {
                        console.warn("No knowledge base data provided");
                        return;
                    }
                    
                    const data = JSON.parse(jsonData);
                    
                    if (data && typeof data === 'object') {
                        // Handle case where facts is directly in the object
                        if (data.facts && typeof data.facts === 'object') {
                            this.facts = data.facts;
                            this.factIdCounter = data.factIdCounter || 1;
                            console.log(`Loaded knowledge base with ${Object.keys(this.facts).length} facts`);
                        } 
                        // Handle case where the object itself is the facts dictionary
                        else if (Object.keys(data).length > 0 && !data.facts) {
                            console.log("Legacy format detected - object is the facts dictionary");
                            this.facts = data;
                            this.factIdCounter = Math.max(...Object.keys(data).map(Number), 0) + 1;
                            console.log(`Loaded legacy knowledge base with ${Object.keys(this.facts).length} facts`);
                        }
                        // Empty knowledge base
                        else {
                            console.warn("Empty or invalid knowledge base data");
                            this.facts = {};
                            this.factIdCounter = 1;
                        }
                    } else {
                        console.warn("Invalid knowledge base data format");
                        this.facts = {};
                        this.factIdCounter = 1;
                    }
                } catch (e) {
                    console.error('Error parsing knowledge base data:', e);
                    // Don't reset knowledge base on error - maintain current state
                }
            }
        }
        
        // Pattern Matcher Class
        class PatternMatcher {
            constructor(knowledgeBase) {
                this.knowledgeBase = knowledgeBase;
                this.patterns = [];
            }
            
            addPattern(patternData) {
                // Validate pattern data
                if (!patternData || !patternData.pattern || !patternData.response) {
                    console.error('Invalid pattern data:', patternData);
                    return false;
                }
                
                // Ensure pattern has an ID
                if (!patternData.id) {
                    patternData.id = `pattern_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
                }
                
                // Ensure pattern has constraints
                if (!patternData.constraints) {
                    patternData.constraints = {
                        exactMatch: true,
                        substringMatch: false,
                        caseSensitive: false
                    };
                }
                
                // Check if pattern already exists (by ID) and replace it
                const existingIndex = this.patterns.findIndex(p => p.id === patternData.id);
                if (existingIndex >= 0) {
                    this.patterns[existingIndex] = patternData;
                    console.log(`Updated existing pattern: "${patternData.pattern}"`);
                } else {
                    this.patterns.push(patternData);
                    console.log(`Added new pattern: "${patternData.pattern}"`);
                }
                
                console.log(`Total patterns now: ${this.patterns.length}`);
                return true;
            }
            
            findMatchingPattern(prompt, domainFilter = 'all') {
                console.log(`Finding matching pattern for: "${prompt}" among ${this.patterns.length} patterns`);
                
                if (!prompt || this.patterns.length === 0) {
                    console.log("No prompt provided or no patterns to check");
                    return null;
                }
                
                // Try to find a match
                for (const pattern of this.patterns) {
                    const { pattern: patternText, constraints } = pattern;
                    
                    // Skip invalid patterns
                    if (!patternText) continue;
                    
                    // Debug
                    console.log(`Checking pattern: "${patternText}" with constraints:`, constraints);
                    
                    // Check for match
                    if (this.matchesPattern(prompt, patternText, constraints)) {
                        console.log(`Match found! Pattern: "${patternText}"`);
                        
                        // Check if the pattern has facts in the requested domain
                        if (domainFilter !== 'all') {
                            const domainFacts = pattern.factIds
                                .map(id => this.knowledgeBase.getFact(id))
                                .filter(fact => fact && fact.domain === domainFilter);
                            
                            if (domainFacts.length > 0) {
                                return pattern;
                            } else {
                                console.log(`Pattern matched but no facts in domain: ${domainFilter}`);
                            }
                        } else {
                            return pattern;
                        }
                    }
                }
                
                console.log("No matching pattern found");
                return null;
            }
            
            matchesPattern(input, pattern, constraints) {
                // Validate inputs
                if (!input || !pattern) return false;
                
                // Default constraints if not provided
                constraints = constraints || {
                    caseSensitive: false,
                    exactMatch: true,
                    substringMatch: false
                };
                
                // Apply case sensitivity
                const patternToMatch = constraints.caseSensitive ? pattern : pattern.toLowerCase();
                const inputToMatch = constraints.caseSensitive ? input : input.toLowerCase();
                
                // Check for exact match
                if (constraints.exactMatch) {
                    const match = patternToMatch === inputToMatch;
                    console.log(`Exact match check: "${inputToMatch}" === "${patternToMatch}" = ${match}`);
                    return match;
                }
                
                // Check for substring match
                if (constraints.substringMatch) {
                    const inputContainsPattern = inputToMatch.includes(patternToMatch);
                    const patternContainsInput = patternToMatch.includes(inputToMatch);
                    const match = inputContainsPattern || patternContainsInput;
                    console.log(`Substring match: ${match} (${inputContainsPattern ? 'input contains pattern' : ''}${patternContainsInput ? 'pattern contains input' : ''})`);
                    return match;
                }
                
                // Default to exact match if no constraint specified
                const defaultMatch = patternToMatch === inputToMatch;
                console.log(`Default exact match: ${defaultMatch}`);
                return defaultMatch;
            }
            
            getRelevantFacts(pattern, domainFilter, includeTrustedOnly = true) {
                if (!pattern) return [];
                
                return pattern.factIds
                    .map(id => this.knowledgeBase.getFact(id))
                    .filter(fact => fact && 
                          (domainFilter === 'all' || fact.domain === domainFilter) &&
                          (!includeTrustedOnly || fact.trusted));
            }
            
            getAllRelevantFacts(prompt, domainFilter) {
                // Find matching pattern
                const matchingPattern = this.findMatchingPattern(prompt, domainFilter);
                
                if (!matchingPattern) {
                    return [];
                }
                
                // Get all facts for the pattern
                return matchingPattern.factIds
                    .map(id => this.knowledgeBase.getFact(id))
                    .filter(fact => fact && 
                          (domainFilter === 'all' || fact.domain === domainFilter));
            }
            
            /**
             * Serialize patterns to JSON
             */
            toJSON() {
                try {
                    const jsonString = JSON.stringify(this.patterns || []);
                    console.log(`Serializing ${this.patterns.length} patterns to JSON`);
                    return jsonString;
                } catch (e) {
                    console.error('Error serializing patterns:', e);
                    return JSON.stringify([]); // Return empty array as fallback
                }
            }
            
            /**
             * Load patterns from JSON
             */
            fromJSON(jsonData) {
                try {
                    if (!jsonData) {
                        console.warn("No pattern data provided to fromJSON");
                        return; // Keep existing patterns intact
                    }
                    
                    // Parse the JSON string
                    const parsedData = JSON.parse(jsonData);
                    
                    // Check if the parsed data is an array
                    if (Array.isArray(parsedData)) {
                        console.log(`Loading ${parsedData.length} patterns from JSON array`);
                        
                        // Only replace patterns if we have valid data
                        if (parsedData.length > 0) {
                            this.patterns = parsedData;
                            
                            // Ensure all patterns have proper constraints (backward compatibility)
                            this.patterns.forEach(pattern => {
                                if (!pattern.constraints) {
                                    console.log(`Adding default constraints to pattern: "${pattern.pattern}"`);
                                    pattern.constraints = {
                                        exactMatch: true,
                                        substringMatch: false,
                                        caseSensitive: false
                                    };
                                }
                            });
                        } else {
                            console.warn("Parsed pattern data is empty array");
                        }
                    } else {
                        console.warn("Parsed pattern data is not an array:", parsedData);
                        // Don't reset patterns here - keep existing patterns
                    }
                } catch (e) {
                    console.error('Error parsing pattern data:', e);
                    // DON'T reset patterns to empty array - keep existing patterns
                    console.log('Keeping existing patterns intact');
                }
            }
        }
        
        // Response Generator Class
        class ResponseGenerator {
            constructor(knowledgeBase, patternMatcher) {
                this.knowledgeBase = knowledgeBase;
                this.patternMatcher = patternMatcher;
            }
            
            async generateResponse(prompt, domainFilter, style, showSources, includeUntrusted) {
                // Find a matching pattern
                const matchingPattern = this.patternMatcher.findMatchingPattern(prompt, domainFilter);
                
                if (!matchingPattern) {
                    return "I don't have a pattern match for that input. Please try a different question or upload a training file with this pattern.";
                }
                
                // If there's a direct pattern match, return the exact response
                if (matchingPattern.response) {
                    let response = matchingPattern.response;
                    
                    // Add sources if requested
                    if (showSources) {
                        const facts = this.patternMatcher.getRelevantFacts(
                            matchingPattern, 
                            domainFilter,
                            !includeUntrusted
                        );
                        
                        if (facts.length > 0) {
                            response += this.generateSourcesSection(facts);
                        }
                    }
                    
                    // Apply formatting to preserve whitespace and special characters
                    return this.formatResponseOutput(response);
                }
                
                // Get relevant facts based on pattern match
                const trustedFacts = this.patternMatcher.getRelevantFacts(
                    matchingPattern, 
                    domainFilter,
                    true
                );
                
                const untrustedFacts = includeUntrusted ? 
                    this.patternMatcher.getRelevantFacts(matchingPattern, domainFilter, false)
                        .filter(fact => !fact.trusted) : [];
                
                // If no facts found, return uncertainty message
                if (trustedFacts.length === 0 && untrustedFacts.length === 0) {
                    return "I recognize this pattern, but I don't have any facts to provide for this domain filter.";
                }
                
                // Generate response from facts based on style
                let response = '';
                
                if (trustedFacts.length > 0) {
                    switch (style) {
                        case 'concise':
                            response = this.generateConciseResponse(trustedFacts);
                            break;
                        case 'detailed':
                            response = this.generateDetailedResponse(trustedFacts);
                            break;
                        case 'academic':
                            response = this.generateAcademicResponse(trustedFacts);
                            break;
                        case 'simple':
                            response = this.generateSimpleResponse(trustedFacts);
                            break;
                        default:
                            response = this.generateConciseResponse(trustedFacts);
                    }
                } else {
                    response = "I don't have any trusted information on this topic.";
                }
                
                // Add unverified content section if requested and available
                if (includeUntrusted && untrustedFacts.length > 0) {
                    response += '\n\n<div class="unverified-content">\n';
                    response += '<div class="unverified-header">\n';
                    response += '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>';
                    response += '<p><strong>Unverified Information</strong></p>\n';
                    response += '</div>\n';
                    
                    response += '<ul>\n';
                    untrustedFacts.forEach(fact => {
                        response += `<li>${this.escapeHtml(fact.text)} <em>(Source: ${this.escapeHtml(fact.source)})</em></li>\n`;
                    });
                    response += '</ul>\n';
                    
                    response += '<p class="unverified-footer"><em>This information has not been verified and may not be accurate.</em></p>\n';
                    response += '</div>';
                }
                
                // Add sources if requested
                if (showSources && trustedFacts.length > 0) {
                    response += this.generateSourcesSection(trustedFacts);
                }
                
                // Apply formatting to preserve whitespace and special characters
                return this.formatResponseOutput(response);
            }
            
            formatResponseOutput(text) {
                // First, escape HTML to prevent XSS and ensure special characters are displayed correctly
                let formattedText = this.escapeHtml(text);
                
                // Process markdown-style formatting
                
                // Handle code blocks with syntax highlighting
                formattedText = formattedText.replace(/```([a-z]*)\n([\s\S]*?)\n```/g, (match, language, code) => {
                    return `<pre class="code-block ${language ? 'language-' + language : ''}"><code>${code}</code></pre>`;
                });
                
                // Handle inline code snippets
                formattedText = formattedText.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Preserve line breaks and convert to <br> tags where not already handled by paragraphs
                formattedText = formattedText.replace(/\n\n/g, '</p><p>');
                formattedText = formattedText.replace(/\n/g, '<br>');
                
                // Handle headers (# Header)
                formattedText = formattedText.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
                formattedText = formattedText.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
                formattedText = formattedText.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
                formattedText = formattedText.replace(/^#### (.*?)$/gm, '<h4>$1</h4>');
                
                // Handle bold and italic text
                formattedText = formattedText.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                formattedText = formattedText.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                
                // Handle links
                formattedText = formattedText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // Handle lists (simple implementation)
                formattedText = formattedText.replace(/^- (.*?)$/gm, '<li>$1</li>');
                
                // Wrap in paragraphs if not already
                if (!formattedText.startsWith('<h') && !formattedText.startsWith('<p>') && !formattedText.startsWith('<div')) {
                    formattedText = '<p>' + formattedText + '</p>';
                }
                
                // Replace temporary paragraph markers
                formattedText = formattedText.replace(/<\/p><p>/g, '</p>\n<p>');
                
                // Handle consecutive list items
                formattedText = formattedText.replace(/<li>(.*?)<\/li>(\s*)<li>/g, '<li>$1</li>\n<li>');
                
                // Wrap lists in <ul> tags
                let hasListItems = formattedText.includes('<li>');
                if (hasListItems) {
                    // Find blocks of list items and wrap them in <ul> tags
                    formattedText = formattedText.replace(/(<li>.*?<\/li>(\s*)){1,}/g, '<ul>$&</ul>');
                }
                
                // Fix any HTML artifacts from list processing
                formattedText = formattedText.replace(/<\/ul><ul>/g, '');
                
                return formattedText;
            }
            
            // HTML escaping method to properly handle special characters
            escapeHtml(text) {
                if (typeof text !== 'string') return '';
                
                return text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            generateConciseResponse(facts) {
                return facts.map(fact => fact.text).join(' ');
            }
            
            generateDetailedResponse(facts) {
                // Group facts by domain
                const factsByDomain = {};
                
                facts.forEach(fact => {
                    if (!factsByDomain[fact.domain]) {
                        factsByDomain[fact.domain] = [];
                    }
                    
                    factsByDomain[fact.domain].push(fact);
                });
                
                // Generate response by domain
                let response = '';
                
                for (const domain in factsByDomain) {
                    response += `**${domain.charAt(0).toUpperCase() + domain.slice(1)} information:**\n\n`;
                    
                    factsByDomain[domain].forEach(fact => {
                        response += `- ${fact.text}\n`;
                    });
                    
                    response += '\n';
                }
                
                return response;
            }
            
            generateAcademicResponse(facts) {
                let response = '';
                
                // Create a citation map for consistent citation numbers
                const citationMap = new Map();
                facts.forEach((fact, index) => {
                    if (!citationMap.has(fact.source)) {
                        citationMap.set(fact.source, index + 1);
                    }
                });
                
                facts.forEach(fact => {
                    const citationNumber = citationMap.get(fact.source);
                    response += fact.text;
                    
                    // Add inline citation
                    response += ` [${citationNumber}]`;
                    
                    // Add period if needed
                    if (!response.endsWith('.') && !response.endsWith('!') && !response.endsWith('?')) {
                        response += '.';
                    }
                    
                    response += ' ';
                });
                
                return response;
            }
            
            generateSimpleResponse(facts) {
                // Just use the first fact
                if (facts.length > 0) {
                    return facts[0].text;
                }
                
                return "I don't have enough reliable information to answer that.";
            }
            
            generateSourcesSection(facts) {
                let sources = '\n\n<div class="sources-section">\n';
                sources += '<h3>Sources</h3>\n';
                
                // Create a map to deduplicate sources
                const sourceMap = new Map();
                
                facts.forEach((fact, index) => {
                    if (!sourceMap.has(fact.source)) {
                        sourceMap.set(fact.source, index + 1);
                    }
                });
                
                // Generate sources list
                sources += '<ol>\n';
                Array.from(sourceMap.entries()).forEach(([source, index]) => {
                    sources += `<li id="source-${index}">${this.escapeHtml(source)}</li>\n`;
                });
                sources += '</ol>\n';
                sources += '</div>';
                
                return sources;
            }
        }
        
        // Main SmallLLM Class
        class SmallLLM {
            constructor() {
                // Core components
                this.knowledgeBase = new KnowledgeBase();
                this.patternMatcher = new PatternMatcher(this.knowledgeBase);
                this.responseGenerator = new ResponseGenerator(this.knowledgeBase, this.patternMatcher);
                
                // Character mapping for encoding/decoding
                this.charMap = [];
                this.isCharMapLoaded = false;
                
                // Settings
                this.settings = {
                    showSources: true,
                    responseStyle: 'concise',
                    databaseModeEnabled: false
                };
                
                // UI state
                this.currentSection = 'section-home';
                this.kbPage = 1;
                this.kbPageSize = 10;
                this.kbFilter = '';
                this.kbDomainFilter = 'all';
                this.kbTrustedFilter = 'all';
                
                // Database view state
                this.dbPage = 1;
                this.dbPageSize = 10;
                this.dbFilter = '';
                this.dbDomainFilter = 'all';
                this.dbSortBy = 'newest';
                
                // Session filename for saving/loading
                this.sessionFilename = 'smallllm-session.json';
                
                // Initialize the app
                this.initializeApp();
            }
            
            /**
             * Initialize the application
             */
            initializeApp() {
                try {
                    console.log('Initializing SmallLLM application...');
                    
                    // Initialize modal dialog structure first
                    this.initializeModal();
                    
                    // Load saved data if available
                    this.loadFromLocalStorage();
                    
                    // Set up the file drop handler
                    this.setupFileDrop();
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    // Initialize training system
                    this.initDeterministicTrainingSystem();
                    
                    // Fix accessibility issues
                    this.fixAccessibilityIssues();
                    
                    // Update UI
                    this.updateUI();
                    
                    console.log('SmallLLM initialized');
                } catch (e) {
                    console.error('Critical error during SmallLLM initialization:', e);
                    // Show error message to user
                    alert('There was an error initializing the application. Please check the console for details.');
                }
            }
            
            /**
             * Load data from localStorage
             */
            loadFromLocalStorage() {
                // Track loaded components for debugging
                const loadStatus = {
                    knowledgeBase: false,
                    patterns: false,
                    settings: false,
                    charMap: false
                };
                
                try {
                    // Load knowledge base
                    try {
                        const kbData = localStorage.getItem('smallllm-kb');
                        if (kbData) {
                            this.knowledgeBase.fromJSON(kbData);
                            console.log(`Loaded knowledge base with ${Object.keys(this.knowledgeBase.facts).length} facts`);
                            loadStatus.knowledgeBase = true;
                        }
                    } catch (kbError) {
                        console.error('Error loading knowledge base:', kbError);
                    }
                    
                    // Load patterns
                    try {
                        const patternsData = localStorage.getItem('smallllm-patterns');
                        if (patternsData) {
                            // Store current patterns count for comparison
                            const beforeCount = this.patternMatcher.patterns.length;
                            
                            // Load patterns
                            this.patternMatcher.fromJSON(patternsData);
                            
                            // Report results
                            const afterCount = this.patternMatcher.patterns.length;
                            console.log(`Loaded patterns from localStorage: ${beforeCount} -> ${afterCount}`);
                            loadStatus.patterns = true;
                        }
                    } catch (patternError) {
                        console.error('Error loading patterns:', patternError);
                    }
                    
                    // Load settings
                    try {
                        const settingsData = localStorage.getItem('smallllm-settings');
                        if (settingsData) {
                            this.settings = JSON.parse(settingsData);
                            console.log('Loaded settings from localStorage');
                            loadStatus.settings = true;
                        }
                    } catch (settingsError) {
                        console.error('Error loading settings:', settingsError);
                    }
                    
                    // Load character map
                    try {
                        const charMapData = localStorage.getItem('smallllm-charmap');
                        if (charMapData) {
                            this.charMap = JSON.parse(charMapData);
                            this.isCharMapLoaded = this.charMap && this.charMap.length > 0;
                            console.log(`Loaded character map with ${this.charMap ? this.charMap.length : 0} entries`);
                            loadStatus.charMap = true;
                        }
                    } catch (charMapError) {
                        console.error('Error loading character map:', charMapError);
                    }
                    
                    // Make charMap available globally
                    window.charMap = this.charMap;
                    
                    // Debug report
                    console.log(`[DATA LOADED] Facts: ${Object.keys(this.knowledgeBase.facts).length}, Patterns: ${this.patternMatcher.patterns.length}`);
                    console.log('Load status:', loadStatus);
                    
                } catch (e) {
                    console.error('Unexpected error in loadFromLocalStorage:', e);
                }
            }
            
            /**
             * Save data to localStorage
             */
            saveToLocalStorage() {
                try {
                    // Save knowledge base
                    localStorage.setItem('smallllm-kb', this.knowledgeBase.toJSON());
                    
                    // Save patterns
                    localStorage.setItem('smallllm-patterns', this.patternMatcher.toJSON());
                    
                    // Save settings
                    localStorage.setItem('smallllm-settings', JSON.stringify(this.settings));
                    
                    // Save character map
                    localStorage.setItem('smallllm-charmap', JSON.stringify(this.charMap));
                    
                    console.log('Saved data to local storage');
                } catch (e) {
                    console.error('Error saving data to local storage:', e);
                }
            }
            
            /**
             * Set up event listeners for all UI elements
             */
            setupEventListeners() {
                // Navigation
                document.getElementById('nav-home').addEventListener('click', e => {
                    e.preventDefault();
                    this.switchSection('section-home');
                });
                
                document.getElementById('nav-train').addEventListener('click', e => {
                    e.preventDefault();
                    this.switchSection('section-train');
                });
                
                document.getElementById('nav-knowledge-base').addEventListener('click', e => {
                    e.preventDefault();
                    this.switchSection('section-knowledge-base');
                    this.updateKnowledgeBaseTable();
                });
                
                document.getElementById('nav-database').addEventListener('click', e => {
                    e.preventDefault();
                    this.switchSection('section-database');
                    this.updateDatabaseTable();
                });
                
                document.getElementById('nav-settings').addEventListener('click', e => {
                    e.preventDefault();
                    this.switchSection('section-settings');
                    this.updateSettingsUI();
                });
                
                // Chat interface
                document.getElementById('send-button').addEventListener('click', () => this.handleUserInput());
                document.getElementById('user-input').addEventListener('keypress', e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleUserInput();
                    }
                });
                
                document.getElementById('clear-button').addEventListener('click', () => this.clearChat());
                
                // Knowledge base interface
                document.getElementById('kb-search').addEventListener('input', e => {
                    this.kbFilter = e.target.value.toLowerCase();
                    this.kbPage = 1;
                    this.updateKnowledgeBaseTable();
                });
                
                document.getElementById('kb-domain-filter').addEventListener('change', e => {
                    this.kbDomainFilter = e.target.value;
                    this.kbPage = 1;
                    this.updateKnowledgeBaseTable();
                });
                
                document.getElementById('kb-trusted-filter').addEventListener('change', e => {
                    this.kbTrustedFilter = e.target.value;
                    this.kbPage = 1;
                    this.updateKnowledgeBaseTable();
                });
                
                document.getElementById('kb-prev-page').addEventListener('click', () => {
                    if (this.kbPage > 1) {
                        this.kbPage--;
                        this.updateKnowledgeBaseTable();
                    }
                });
                
                document.getElementById('kb-next-page').addEventListener('click', () => {
                    const totalPages = Math.ceil(this.getFilteredFacts().length / this.kbPageSize);
                    if (this.kbPage < totalPages) {
                        this.kbPage++;
                        this.updateKnowledgeBaseTable();
                    }
                });
                
                // Database view
                document.getElementById('db-search').addEventListener('input', e => {
                    this.dbFilter = e.target.value.toLowerCase();
                    this.dbPage = 1;
                    this.updateDatabaseTable();
                });
                
                document.getElementById('db-domain-filter').addEventListener('change', e => {
                    this.dbDomainFilter = e.target.value;
                    this.dbPage = 1;
                    this.updateDatabaseTable();
                });
                
                document.getElementById('db-sort-by').addEventListener('change', e => {
                    this.dbSortBy = e.target.value;
                    this.updateDatabaseTable();
                });
                
                document.getElementById('db-prev-page').addEventListener('click', () => {
                    if (this.dbPage > 1) {
                        this.dbPage--;
                        this.updateDatabaseTable();
                    }
                });
                
                document.getElementById('db-next-page').addEventListener('click', () => {
                    const filteredFacts = this.getFilteredDatabaseFacts();
                    const totalPages = Math.ceil(filteredFacts.length / this.dbPageSize);
                    if (this.dbPage < totalPages) {
                        this.dbPage++;
                        this.updateDatabaseTable();
                    }
                });
                
                // Settings interface
                document.getElementById('save-settings-button').addEventListener('click', () => this.saveSettings());
                document.getElementById('reset-settings-button').addEventListener('click', () => this.resetSettings());
                
                document.getElementById('export-kb-button').addEventListener('click', () => this.exportKnowledgeBase());
                document.getElementById('import-kb-button').addEventListener('click', () => this.importKnowledgeBase());
                document.getElementById('reset-kb-button').addEventListener('click', () => this.resetKnowledgeBase());
                
                document.getElementById('save-char-map').addEventListener('click', () => this.saveCharMap());
                document.getElementById('load-char-map').addEventListener('click', () => this.loadCharMap());
                
                document.getElementById('save-session-button').addEventListener('click', () => this.saveSessionToFile());
                document.getElementById('load-session-button').addEventListener('click', () => this.loadSessionFromFile());
                
                // Training file upload
                const trainingFileContainer = document.getElementById('training-file-container');
                const trainingFileInput = document.getElementById('training-file-input');
                const browseFileButton = document.getElementById('browse-file-button');
                
                // Browse file button
                browseFileButton.addEventListener('click', () => {
                    trainingFileInput.click();
                });
                
                // File input change
                trainingFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.processTrainingFile(e.target.files[0]);
                    }
                });
                
                // Drag and drop for training file container
                trainingFileContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    trainingFileContainer.classList.add('drag-over');
                });
                
                trainingFileContainer.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    trainingFileContainer.classList.remove('drag-over');
                });
                
                trainingFileContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    trainingFileContainer.classList.remove('drag-over');
                    
                    if (e.dataTransfer.files.length > 0) {
                        this.processTrainingFile(e.dataTransfer.files[0]);
                    }
                });
                
                // Debug tools
                document.getElementById('debug-patterns-button').addEventListener('click', () => {
                    this.showPatternsDebug();
                });
                
                document.getElementById('debug-test-input-button').addEventListener('click', () => {
                    const testInput = prompt("Enter an input to test pattern matching:");
                    if (testInput) {
                        this.testInputAgainstPatterns(testInput);
                    }
                });
                
                // Footer link for session info
                const footerSessionInfo = document.getElementById('footer-session-info');
                if (footerSessionInfo) {
                    footerSessionInfo.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.showSessionInfo();
                    });
                }
                
                // Footer link for quick save
                document.getElementById('save-data-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.saveSessionToFile();
                });
                
                // Modal close button
                const modalCloseButton = document.querySelector('.modal-close');
                if (modalCloseButton) {
                    modalCloseButton.addEventListener('click', () => this.hideModal());
                }
            }
            
            /**
             * Process an uploaded training file
             */
            processTrainingFile(file) {
                if (!file || !file.name.endsWith('.json')) {
                    this.showToast('Please upload a JSON file');
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        // Parse the JSON file
                        const trainingData = JSON.parse(e.target.result);
                        
                        // Show the training status
                        const trainingStatus = document.getElementById('training-status');
                        trainingStatus.classList.remove('hidden');
                        trainingStatus.classList.add('active');
                        
                        // Update status message
                        const statusMessage = document.getElementById('status-message');
                        statusMessage.textContent = 'PROCESSING TRAINING FILE...';
                        
                        // Show matrix animation
                        this.animateMatrixVisualization();
                        
                        // Process the training data with a delay for visual effect
                        setTimeout(() => {
                            this.loadTrainingData(trainingData);
                        }, 2000);
                    } catch (error) {
                        console.error('Error processing training file:', error);
                        this.showToast('Error processing training file. Check console for details.');
                    }
                };
                
                reader.onerror = () => {
                    this.showToast('Error reading file');
                };
                
                reader.readAsText(file);
            }
            
            /**
             * Load training data from JSON
             */
            loadTrainingData(trainingData) {
                try {
                    // Update status
                    const statusMessage = document.getElementById('status-message');
                    statusMessage.textContent = 'LOADING PATTERNS AND FACTS...';
                    
                    let patternsAdded = 0;
                    let factsAdded = 0;
                    
                    // Load facts if present
                    if (trainingData.facts) {
                        // Calculate the highest fact ID to update the counter
                        const factIds = Object.keys(trainingData.facts).map(id => parseInt(id));
                        const highestFactId = factIds.length > 0 ? Math.max(...factIds) : 0;
                        
                        // Update the fact ID counter if needed
                        if (highestFactId >= this.knowledgeBase.factIdCounter) {
                            this.knowledgeBase.factIdCounter = highestFactId + 1;
                        }
                        
                        // Add facts to the knowledge base
                        for (const factId in trainingData.facts) {
                            const fact = trainingData.facts[factId];
                            
                            // Only add the fact if it doesn't already exist
                            if (!this.knowledgeBase.facts[factId]) {
                                this.knowledgeBase.facts[factId] = fact;
                                factsAdded++;
                            }
                        }
                        
                        console.log(`Added ${factsAdded} facts from training data`);
                    }
                    
                    // Load factIdCounter if present and higher than current
                    if (trainingData.factIdCounter && trainingData.factIdCounter > this.knowledgeBase.factIdCounter) {
                        this.knowledgeBase.factIdCounter = trainingData.factIdCounter;
                    }
                    
                    // Load patterns if present
                    if (trainingData.patterns && Array.isArray(trainingData.patterns)) {
                        // Add each pattern
                        trainingData.patterns.forEach(pattern => {
                            if (this.patternMatcher.addPattern(pattern)) {
                                patternsAdded++;
                            }
                        });
                        
                        console.log(`Added ${patternsAdded} patterns from training data`);
                    }
                    
                    // Update status
                    statusMessage.textContent = 'TRAINING COMPLETE';
                    
                    // Save to localStorage
                    this.saveToLocalStorage();
                    
                    // Show results
                    const trainingResults = document.getElementById('training-results');
                    trainingResults.innerHTML = `
                        <h4>Training Successful</h4>
                        <p><strong>${patternsAdded}</strong> patterns added to the system.</p>
                        <p><strong>${factsAdded}</strong> facts added to the knowledge base.</p>
                        <p>Total patterns in system: <strong>${this.patternMatcher.patterns.length}</strong></p>
                        <p>Total facts in system: <strong>${Object.keys(this.knowledgeBase.facts).length}</strong></p>
                    `;
                    
                    // Add button to test patterns
                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'button-container';
                    
                    const testPatternsButton = document.createElement('button');
                    testPatternsButton.className = 'primary-button';
                    testPatternsButton.textContent = 'Test Patterns';
                    testPatternsButton.addEventListener('click', () => {
                        this.showPatternsDebug();
                    });
                    
                    const goToChatButton = document.createElement('button');
                    goToChatButton.className = 'secondary-button';
                    goToChatButton.textContent = 'Go to Chat';
                    goToChatButton.addEventListener('click', () => {
                        this.switchSection('section-home');
                    });
                    
                    buttonContainer.appendChild(testPatternsButton);
                    buttonContainer.appendChild(goToChatButton);
                    
                    trainingResults.appendChild(buttonContainer);
                } catch (error) {
                    console.error('Error loading training data:', error);
                    
                    // Update status
                    const statusMessage = document.getElementById('status-message');
                    statusMessage.textContent = 'ERROR LOADING TRAINING DATA';
                    
                    // Show error in results
                    const trainingResults = document.getElementById('training-results');
                    trainingResults.innerHTML = `
                        <h4>Training Error</h4>
                        <p>An error occurred while loading the training data:</p>
                        <pre class="results-pattern">${this.escapeHtml(error.message)}</pre>
                    `;
                }
            }
            
            /**
             * Show debug information about patterns
             */
            showPatternsDebug() {
                try {
                    const patternCount = this.patternMatcher.patterns.length;
                    
                    let content = `<h3>Pattern Debugger</h3>`;
                    
                    if (!this.patternMatcher.patterns || patternCount === 0) {
                        content += `<p>No patterns are currently loaded. This is why the model can't match any inputs.</p>`;
                    } else {
                        content += `<p>Currently loaded patterns: <strong>${patternCount}</strong></p>
                        <div class="pattern-debug-list">`;
                        
                        this.patternMatcher.patterns.forEach((pattern, index) => {
                            if (!pattern) {
                                content += `<div class="pattern-debug-item"><div class="pattern-index">#${index + 1}</div><div class="pattern-details">Invalid pattern (null or undefined)</div></div>`;
                                return;
                            }
                            
                            content += `
                            <div class="pattern-debug-item">
                                <div class="pattern-index">#${index + 1}</div>
                                <div class="pattern-details">
                                    <div><strong>Pattern:</strong> "${this.escapeHtml(pattern.pattern || 'No pattern')}"</div>
                                    <div><strong>Response:</strong> "${this.escapeHtml((pattern.response || 'No response').substring(0, 50))}${(pattern.response || '').length > 50 ? '...' : ''}"</div>
                                    <div><strong>Facts:</strong> ${pattern.factIds ? pattern.factIds.length : 0}</div>
                                    <div><strong>ID:</strong> ${pattern.id || 'No ID'}</div>
                                    <div><strong>Match Type:</strong> ${
                                        pattern.constraints?.exactMatch ? 'Exact' : 
                                        pattern.constraints?.substringMatch ? 'Substring' : 
                                        'Unknown'
                                    }</div>
                                </div>
                            </div>`;
                        });
                        
                        content += `</div>`;
                    }
                    
                    content += `
                    <div class="debug-actions">
                        <button id="debug-test-pattern" class="primary-button">Test Pattern Matching</button>
                        <button id="debug-export-patterns" class="secondary-button">Export Patterns JSON</button>
                    </div>`;
                    
                    this.showModal('Pattern Debugging', content, [
                        { text: 'Close', action: 'close' }
                    ]);
                    
                    // Add event listeners
                    setTimeout(() => {
                        try {
                            const testButton = document.getElementById('debug-test-pattern');
                            if (testButton) {
                                testButton.addEventListener('click', () => {
                                    this.hideModal();
                                    
                                    // Prompt for an input to test
                                    const testInput = prompt("Enter an input to test pattern matching:");
                                    if (!testInput) return;
                                    
                                    // Test matching and show results
                                    this.testInputAgainstPatterns(testInput);
                                });
                            }
                            
                            const exportButton = document.getElementById('debug-export-patterns');
                            if (exportButton) {
                                exportButton.addEventListener('click', () => {
                                    try {
                                        // Export just the patterns as JSON
                                        const jsonData = this.patternMatcher.toJSON();
                                        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
                                        const downloadNode = document.createElement('a');
                                        downloadNode.setAttribute("href", dataStr);
                                        downloadNode.setAttribute("download", "smallllm-patterns-debug.json");
                                        document.body.appendChild(downloadNode);
                                        downloadNode.click();
                                        downloadNode.remove();
                                        
                                        this.showToast('Pattern debug data exported');
                                    } catch (error) {
                                        console.error('Error exporting pattern debug data:', error);
                                        this.showToast('Error exporting pattern debug data');
                                    }
                                });
                            }
                        } catch (listenerError) {
                            console.error('Error setting up debug button listeners:', listenerError);
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error showing pattern debugger:', error);
                    alert('Error showing pattern debugger. Check console for details.');
                }
            }
            
            /**
             * Test an input against stored patterns
             */
            testInputAgainstPatterns(input) {
                if (!input) {
                    input = prompt("Enter an input to test against stored patterns:");
                    if (!input) return;
                }
                
                console.log(`Testing input: "${input}" against ${this.patternMatcher.patterns.length} patterns`);
                
                // Try to find a matching pattern
                const matchingPattern = this.patternMatcher.findMatchingPattern(input);
                
                if (matchingPattern) {
                    console.log("Match found:", matchingPattern);
                    
                    // Show a toast notification
                    this.showToast(`Match found for: "${input}"`);
                    
                    // Create result message
                    const resultMessage = `
                        <h3>Pattern Match Results</h3>
                        <p><strong>Input:</strong> "${this.escapeHtml(input)}"</p>
                        <p><strong>Matched pattern:</strong> "${this.escapeHtml(matchingPattern.pattern || '')}"</p>
                        <p><strong>ID:</strong> ${matchingPattern.id || 'Unknown'}</p>
                        <p><strong>Response:</strong></p>
                        <div class="response-preview">${this.escapeHtml((matchingPattern.response || '').substring(0, 200))}${(matchingPattern.response || '').length > 200 ? '...' : ''}</div>
                    `;
                    
                    // Show the modal
                    this.showModal('Pattern Match Found', resultMessage, [
                        { text: 'Close', action: 'close' },
                        { 
                            text: 'Show in Chat', 
                            action: () => {
                                this.hideModal();
                                this.switchSection('section-home');
                                this.addMessageToChat('user', input);
                                
                                // Use setTimeout to visually separate the actions
                                setTimeout(() => {
                                    this.addThinkingMessage();
                                    
                                    setTimeout(() => {
                                        this.removeThinkingMessage();
                                        this.addMessageToChat('system', matchingPattern.response);
                                    }, 500);
                                }, 300);
                            },
                            primary: true
                        }
                    ]);
                } else {
                    console.log("No match found");
                    this.showToast('No pattern match found');
                    
                    // Create debug message
                    const debugMessage = `
                        <h3>No Match Found</h3>
                        <p>The input "${this.escapeHtml(input)}" did not match any of the ${this.patternMatcher.patterns.length} stored patterns.</p>
                        <p>This explains why the model responds with "I don't have a pattern match for that input".</p>
                    `;
                    
                    this.showModal('No Pattern Match', debugMessage, [
                        { text: 'Close', action: 'close' }
                    ]);
                }
            }
            
            /**
             * Show session information
             */
            showSessionInfo() {
                const factCount = Object.keys(this.knowledgeBase.facts).length;
                const patternCount = this.patternMatcher.patterns.length;
                const trustedFactCount = this.knowledgeBase.getTrustedFactCount();
                
                let modalContent = `
                    <h3>Current Session</h3>
                    
                    <div class="session-stats">
                        <div class="stat-group">
                            <div class="stat-item large">
                                <span class="stat-value">${factCount}</span>
                                <span class="stat-label">Total Facts</span>
                            </div>
                            <div class="stat-item large">
                                <span class="stat-value">${patternCount}</span>
                                <span class="stat-label">Response Patterns</span>
                            </div>
                        </div>
                        
                        <div class="stat-divider"></div>
                        
                        <div class="stat-group">
                            <div class="stat-item">
                                <span class="stat-value">${trustedFactCount}</span>
                                <span class="stat-label">Trusted Facts</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${factCount - trustedFactCount}</span>
                                <span class="stat-label">Untrusted Facts</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${this.knowledgeBase.getDomainCount()}</span>
                                <span class="stat-label">Domains</span>
                            </div>
                        </div>
                    </div>
                    
                    <h4>Pattern Examples</h4>
                    <div class="pattern-examples">
                `;
                
                // Show up to 5 patterns as examples
                const examplePatterns = this.patternMatcher.patterns.slice(0, 5);
                
                if (examplePatterns.length === 0) {
                    modalContent += `<p class="text-dim">No patterns available. Try uploading a training file.</p>`;
                } else {
                    modalContent += `<ul class="pattern-list">`;
                    examplePatterns.forEach(pattern => {
                        modalContent += `
                            <li class="pattern-item">
                                <div class="pattern-text">"${this.escapeHtml(pattern.pattern || '')}"</div>
                                <div class="pattern-info">
                                    <span class="pattern-facts">${pattern.factIds ? pattern.factIds.length : 0} facts</span>
                                    <span class="pattern-mode">${
                                        pattern.constraints?.exactMatch ? 'Exact match' : 
                                        pattern.constraints?.substringMatch ? 'Substring match' : 
                                        'Unknown'
                                    }</span>
                                </div>
                            </li>
                        `;
                    });
                    modalContent += `</ul>`;
                    
                    if (this.patternMatcher.patterns.length > 5) {
                        modalContent += `<p class="text-dim">And ${this.patternMatcher.patterns.length - 5} more patterns...</p>`;
                    }
                }
                
                modalContent += `
                    </div>
                    
                    <div class="session-actions">
                        <button id="export-session-btn" class="secondary-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                            Export Session
                        </button>
                        <button id="import-session-btn" class="secondary-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                            Import Session
                        </button>
                        <button id="reset-session-btn" class="warning-button">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line></svg>
                            Reset Session
                        </button>
                    </div>
                `;
                
                this.showModal('Session Information', modalContent, [
                    { text: 'Close', action: 'close', primary: true }
                ]);
                
                // Add event listeners to the buttons
                setTimeout(() => {
                    document.getElementById('export-session-btn').addEventListener('click', () => {
                        this.hideModal();
                        this.saveSessionToFile();
                    });
                    
                    document.getElementById('import-session-btn').addEventListener('click', () => {
                        this.hideModal();
                        this.loadSessionFromFile();
                    });
                    
                    document.getElementById('reset-session-btn').addEventListener('click', () => {
                        this.hideModal();
                        this.resetSession();
                    });
                }, 100);
            }
            
            /**
             * Reset the session
             */
            resetSession() {
                this.showModal('Confirm Reset', 'Are you sure you want to reset the entire session? This will clear all knowledge, patterns, and settings.', [
                    { text: 'Cancel', action: 'close' },
                    { 
                        text: 'Reset Session', 
                        warning: true,
                        action: () => {
                            // Clear knowledge base
                            this.knowledgeBase = new KnowledgeBase();
                            
                            // Clear patterns
                            this.patternMatcher.patterns = [];
                            
                            // Reset settings to defaults
                            this.settings = {
                                showSources: true,
                                responseStyle: 'concise',
                                databaseModeEnabled: false
                            };
                            
                            // Save to local storage
                            this.saveToLocalStorage();
                            
                            // Update UI
                            this.updateUI();
                            
                            this.hideModal();
                            this.showToast('Session reset complete');
                        }
                    }
                ]);
            }
            
            /**
             * Initialize the modal dialog
             */
            initializeModal() {
                try {
                    // Check if the modal exists
                    const existingModal = document.getElementById('main-modal');
                    
                    if (!existingModal) {
                        console.log('Creating main modal structure in DOM...');
                        
                        // Create the modal structure
                        const modal = document.createElement('div');
                        modal.id = 'main-modal';
                        modal.className = 'modal';
                        modal.setAttribute('role', 'dialog');
                        modal.setAttribute('aria-modal', 'true');
                        
                        modal.innerHTML = `
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h2 id="modal-title" class="modal-title">Modal Title</h2>
                                    <button class="modal-close" aria-label="Close modal">&times;</button>
                                </div>
                                <div id="modal-body" class="modal-body">
                                    Modal content will go here
                                </div>
                                <div id="modal-footer" class="modal-footer">
                                    <!-- Buttons will be added dynamically -->
                                </div>
                            </div>
                        `;
                        
                        // Add the modal to the document body
                        document.body.appendChild(modal);
                        
                        // Add event listener to close button
                        const closeButton = modal.querySelector('.modal-close');
                        if (closeButton) {
                            closeButton.addEventListener('click', () => this.hideModal());
                        }
                        
                        return true;
                    } else {
                        // Modal exists, but make sure it has all required elements
                        const modalTitle = document.getElementById('modal-title');
                        const modalBody = document.getElementById('modal-body');
                        const modalFooter = document.getElementById('modal-footer');
                        
                        if (!modalTitle || !modalBody || !modalFooter) {
                            console.warn('Modal exists but is missing required elements. Replacing with complete modal...');
                            
                            // Remove the existing modal
                            existingModal.parentNode.removeChild(existingModal);
                            
                            // Recursively call this method to create a new, complete modal
                            return this.initializeModal();
                        }
                        
                        return true;
                    }
                } catch (error) {
                    console.error('Error initializing modal:', error);
                    return false;
                }
            }
            
            /**
             * Show a modal dialog
             */
            showModal(title, content, buttons) {
                try {
                    // First try to initialize the modal
                    if (!this.initializeModal()) {
                        // If modal initialization fails, fallback to alert
                        console.warn('Modal initialization failed. Falling back to alert.');
                        alert(`${title || 'Message'}\n\n${this.stripHtml(content) || ''}`);
                        return;
                    }
                    
                    // Get modal elements
                    const modal = document.getElementById('main-modal');
                    const modalTitle = document.getElementById('modal-title');
                    const modalBody = document.getElementById('modal-body');
                    const modalFooter = document.getElementById('modal-footer');
                    
                    // Double-check elements exist
                    if (!modal || !modalTitle || !modalBody || !modalFooter) {
                        console.error('Modal elements not found even after initialization');
                        alert(`${title || 'Message'}\n\n${this.stripHtml(content) || ''}`);
                        return;
                    }
                    
                    // Set modal title
                    modalTitle.textContent = title || 'Modal';
                    
                    // Set modal content - could be HTML or text
                    modalBody.innerHTML = content || '';
                    
                    // Set modal buttons
                    modalFooter.innerHTML = '';
                    
                    if (buttons && buttons.length > 0) {
                        buttons.forEach(button => {
                            const btn = document.createElement('button');
                            btn.textContent = button.text || 'Button';
                            
                            if (button.primary) {
                                btn.className = 'primary-button';
                            } else if (button.warning) {
                                btn.className = 'warning-button';
                            } else {
                                btn.className = 'secondary-button';
                            }
                            
                            if (button.action === 'close') {
                                btn.addEventListener('click', () => this.hideModal());
                            } else if (typeof button.action === 'function') {
                                btn.addEventListener('click', button.action);
                            }
                            
                            modalFooter.appendChild(btn);
                        });
                    } else {
                        // Add a default close button if none provided
                        const closeBtn = document.createElement('button');
                        closeBtn.textContent = 'Close';
                        closeBtn.className = 'primary-button';
                        closeBtn.addEventListener('click', () => this.hideModal());
                        modalFooter.appendChild(closeBtn);
                    }
                    
                    // Show modal
                    modal.style.display = 'flex';
                    
                } catch (error) {
                    console.error('Error showing modal:', error);
                    // Fallback to a simple alert
                    alert(`${title || 'Message'}\n\n${this.stripHtml(content) || ''}`);
                }
            }
            
            /**
             * Hide the modal dialog
             */
            hideModal() {
                try {
                    const modal = document.getElementById('main-modal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error hiding modal:', error);
                }
            }
            
            /**
             * Strip HTML tags from text
             */
            stripHtml(html) {
                if (!html || typeof html !== 'string') return '';
                
                // Create a temporary div
                const temp = document.createElement('div');
                temp.innerHTML = html;
                
                // Return just the text
                return temp.textContent || temp.innerText || '';
            }
            
            /**
             * Handle user input from the chat interface
             */
            handleUserInput() {
                const inputField = document.getElementById('user-input');
                const prompt = inputField.value.trim();
                
                if (prompt) {
                    // Add user message to chat
                    this.addMessageToChat('user', prompt);
                    
                    // Clear input field
                    inputField.value = '';
                    
                    // Show "thinking" indicator
                    this.addThinkingMessage();
                    
                    // Get domain filter
                    const domainFilter = document.getElementById('domain-filter').value;
                    
                    // Check if user wants to include unverified information
                    const includeUnverified = document.getElementById('include-unverified').checked;
                    
                    // Process the prompt with a small delay to show the thinking state
                    setTimeout(() => {
                        this.processPrompt(prompt, domainFilter, includeUnverified);
                    }, 500);
                }
            }
            
            /**
             * Process a user prompt
             */
            async processPrompt(prompt, domainFilter, includeUnverified) {
                try {
                    // Generate response
                    const response = await this.responseGenerator.generateResponse(
                        prompt, 
                        domainFilter,
                        this.settings.responseStyle,
                        this.settings.showSources,
                        includeUnverified
                    );
                    
                    // Remove thinking message
                    this.removeThinkingMessage();
                    
                    // Add response to chat
                    this.addMessageToChat('system', response);
                    
                } catch (error) {
                    console.error('Error processing prompt:', error);
                    
                    // Remove thinking message
                    this.removeThinkingMessage();
                    
                    // Add error message to chat
                    this.addMessageToChat('system', `I encountered an error while processing your request. (Error: ${error.message})`);
                }
            }
            
            /**
             * Add a message to the chat history
             */
            addMessageToChat(role, content) {
                const chatHistory = document.getElementById('chat-history');
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                // For system messages, use the formatted HTML directly
                // For user messages, apply basic formatting only
                if (role === 'system') {
                    // Check if the content already contains HTML from the ResponseGenerator
                    if (content.includes('<') && content.includes('>')) {
                        // Content is already formatted HTML
                        contentDiv.innerHTML = content;
                    } else {
                        // Apply basic formatting for plain text
                        contentDiv.innerHTML = this.formatMessageContent(content);
                    }
                } else {
                    // For user messages, just apply basic formatting
                    contentDiv.innerHTML = this.formatMessageContent(content);
                }
                
                messageDiv.appendChild(contentDiv);
                chatHistory.appendChild(messageDiv);
                
                // Scroll to bottom
                chatHistory.scrollTop = chatHistory.scrollHeight;
                
                // Make code blocks copyable
                this.makeCodeBlocksCopyable();
                
                // For system messages, add copy button for the entire message
                if (role === 'system') {
                    // Create the copy button for the whole message
                    const copyMessageButton = document.createElement('button');
                    copyMessageButton.className = 'copy-message-button';
                    copyMessageButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg> Copy Response';
                    copyMessageButton.title = "Copy entire response to clipboard";
                    
                    copyMessageButton.addEventListener('click', () => {
                        // Get the text content of the message
                        const messageText = contentDiv.textContent;
                        
                        navigator.clipboard.writeText(messageText).then(() => {
                            copyMessageButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!';
                            copyMessageButton.classList.add('copied');
                            
                            setTimeout(() => {

                                copyMessageButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg> Copy Response';
                                copyMessageButton.classList.remove('copied');
                            }, 2000);
                        });
                    });
                    
                    // Add the button to the message div
                    const messageControls = document.createElement('div');
                    messageControls.className = 'message-controls';
                    messageControls.appendChild(copyMessageButton);
                    messageDiv.appendChild(messageControls);
                }
            }
            
            /**
             * Make code blocks copyable
             */
            makeCodeBlocksCopyable() {
                const codeBlocks = document.querySelectorAll('.message-content pre.code-block');
                
                codeBlocks.forEach(block => {
                    // Skip if already processed
                    if (block.querySelector('.copy-button')) return;
                    
                    // Create wrapper for positioning
                    const wrapper = document.createElement('div');
                    wrapper.className = 'code-block-wrapper';
                    block.parentNode.insertBefore(wrapper, block);
                    wrapper.appendChild(block);
                    
                    // Create copy button
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button';
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg>';
                    copyButton.title = "Copy to clipboard";
                    
                    copyButton.addEventListener('click', () => {
                        const codeText = block.textContent;
                        navigator.clipboard.writeText(codeText).then(() => {
                            copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                            copyButton.classList.add('copied');
                            
                            setTimeout(() => {
                                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg>';
                                copyButton.classList.remove('copied');
                            }, 2000);
                        });
                    });
                    
                    wrapper.appendChild(copyButton);
                });
            }
            
            /**
             * Add a thinking message to the chat
             */
            addThinkingMessage() {
                const chatHistory = document.getElementById('chat-history');
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message thinking';
                messageDiv.id = 'thinking-message';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = '<p>Processing pattern match...</p>';
                
                messageDiv.appendChild(contentDiv);
                chatHistory.appendChild(messageDiv);
                
                // Scroll to bottom
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }
            
            /**
             * Remove the thinking message from the chat
             */
            removeThinkingMessage() {
                const thinkingMessage = document.getElementById('thinking-message');
                if (thinkingMessage) {
                    thinkingMessage.remove();
                }
            }
            
            /**
             * Format message content
             */
            formatMessageContent(content) {
                // Basic formatting for markdown-like syntax
                
                // Format links
                content = content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                
                // Format bold text
                content = content.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                
                // Format italic text
                content = content.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                
                // Format code
                content = content.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Format paragraphs
                content = content.split('\n\n').map(p => `<p>${p}</p>`).join('');
                
                // Format line breaks
                content = content.replace(/\n/g, '<br>');
                
                return content;
            }
            
            /**
             * Clear the chat history
             */
            clearChat() {
                const chatHistory = document.getElementById('chat-history');
                
                // Remove all messages except the welcome message
                while (chatHistory.children.length > 1) {
                    chatHistory.removeChild(chatHistory.lastChild);
                }
            }
            
            /**
             * Update the knowledge base table
             */
            updateKnowledgeBaseTable() {
                const filteredFacts = this.getFilteredFacts();
                const tbodyElement = document.getElementById('kb-table-body');
                tbodyElement.innerHTML = '';
                
                // Calculate pagination
                const totalFacts = filteredFacts.length;
                const totalPages = Math.ceil(totalFacts / this.kbPageSize);
                const startIndex = (this.kbPage - 1) * this.kbPageSize;
                const endIndex = Math.min(startIndex + this.kbPageSize, totalFacts);
                
                // Update page info
                document.getElementById('kb-page-info').textContent = `Page ${this.kbPage} of ${totalPages || 1}`;
                
                // Update pagination buttons
                document.getElementById('kb-prev-page').disabled = this.kbPage <= 1;
                document.getElementById('kb-next-page').disabled = this.kbPage >= totalPages;
                
                // Display facts for current page
                for (let i = startIndex; i < endIndex; i++) {
                    const fact = filteredFacts[i];
                    
                    const tr = document.createElement('tr');
                    
                    // Add class based on trusted status
                    if (fact.trusted) {
                        tr.classList.add('trusted-fact');
                    } else {
                        tr.classList.add('untrusted-fact');
                    }
                    
                    // Fact text
                    const tdFact = document.createElement('td');
                    tdFact.textContent = fact.text;
                    tr.appendChild(tdFact);
                    
                    // Domain
                    const tdDomain = document.createElement('td');
                    tdDomain.textContent = fact.domain;
                    tr.appendChild(tdDomain);
                    
                    // Source
                    const tdSource = document.createElement('td');
                    tdSource.textContent = fact.source;
                    tr.appendChild(tdSource);
                    
                    // Trusted status
                    const tdStatus = document.createElement('td');
                    tdStatus.innerHTML = fact.trusted ? 
                        '<span class="trusted-badge">Trusted</span>' : 
                        '<span class="untrusted-badge">Untrusted</span>';
                    tr.appendChild(tdStatus);
                    
                    // Actions
                    const tdActions = document.createElement('td');
                    
                    const editButton = document.createElement('button');
                    editButton.className = 'secondary-button';
                    editButton.textContent = 'Edit';
                    editButton.addEventListener('click', () => this.editFact(fact.id));
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'warning-button';
                    deleteButton.textContent = 'Delete';
                    deleteButton.addEventListener('click', () => this.deleteFact(fact.id));
                    
                    tdActions.appendChild(editButton);
                    tdActions.appendChild(document.createTextNode(' '));
                    tdActions.appendChild(deleteButton);
                    
                    tr.appendChild(tdActions);
                    
                    tbodyElement.appendChild(tr);
                }
                
                // Update stats
                document.getElementById('kb-total-facts').textContent = this.knowledgeBase.getFactCount();
                document.getElementById('kb-trusted-facts').textContent = this.knowledgeBase.getTrustedFactCount();
                document.getElementById('kb-domains').textContent = this.knowledgeBase.getDomainCount();
            }
            
            /**
             * Get filtered facts based on current filters
             */
            getFilteredFacts() {
                const facts = this.knowledgeBase.getAllFacts();
                
                return facts.filter(fact => {
                    // Apply text filter
                    if (this.kbFilter && !fact.text.toLowerCase().includes(this.kbFilter) &&
                        !fact.source.toLowerCase().includes(this.kbFilter)) {
                        return false;
                    }
                    
                    // Apply domain filter
                    if (this.kbDomainFilter !== 'all' && fact.domain !== this.kbDomainFilter) {
                        return false;
                    }
                    
                    // Apply trusted filter
                    if (this.kbTrustedFilter === 'trusted' && !fact.trusted) {
                        return false;
                    } else if (this.kbTrustedFilter === 'untrusted' && fact.trusted) {
                        return false;
                    }
                    
                    return true;
                });
            }
            
            /**
             * Update the database table
             */
            updateDatabaseTable() {
                const filteredFacts = this.getFilteredDatabaseFacts();
                const tbodyElement = document.getElementById('database-table-body');
                tbodyElement.innerHTML = '';
                
                // Calculate pagination
                const totalFacts = filteredFacts.length;
                const totalPages = Math.ceil(totalFacts / this.dbPageSize);
                const startIndex = (this.dbPage - 1) * this.dbPageSize;
                const endIndex = Math.min(startIndex + this.dbPageSize, totalFacts);
                
                // Update page info
                document.getElementById('db-page-info').textContent = `Page ${this.dbPage} of ${totalPages || 1}`;
                
                // Update pagination buttons
                document.getElementById('db-prev-page').disabled = this.dbPage <= 1;
                document.getElementById('db-next-page').disabled = this.dbPage >= totalPages;
                
                // Display facts for current page
                for (let i = startIndex; i < endIndex; i++) {
                    const fact = filteredFacts[i];
                    
                    const tr = document.createElement('tr');
                    
                    // Add class based on trusted status
                    if (fact.trusted) {
                        tr.classList.add('trusted-fact');
                    } else {
                        tr.classList.add('untrusted-fact');
                    }
                    
                    // Fact text
                    const tdFact = document.createElement('td');
                    tdFact.textContent = fact.text;
                    tr.appendChild(tdFact);
                    
                    // Domain
                    const tdDomain = document.createElement('td');
                    tdDomain.textContent = fact.domain;
                    tr.appendChild(tdDomain);
                    
                    // Source
                    const tdSource = document.createElement('td');
                    tdSource.textContent = fact.source;
                    tr.appendChild(tdSource);
                    
                    // Trusted status
                    const tdStatus = document.createElement('td');
                    tdStatus.innerHTML = fact.trusted ? 
                        '<span class="trusted-badge">Trusted</span>' : 
                        '<span class="untrusted-badge">Untrusted</span>';
                    tr.appendChild(tdStatus);
                    
                    tbodyElement.appendChild(tr);
                }
                
                // Update stats
                const allFacts = this.knowledgeBase.getAllFacts();
                document.getElementById('db-total-facts').textContent = allFacts.length;
                document.getElementById('db-trusted-facts').textContent = 
                    allFacts.filter(f => f.trusted).length;
                document.getElementById('db-untrusted-facts').textContent = 
                    allFacts.filter(f => !f.trusted).length;
            }
            
            /**
             * Get filtered facts for database view
             */
            getFilteredDatabaseFacts() {
                const facts = this.knowledgeBase.getAllFacts();
                
                // Filter facts
                const filtered = facts.filter(fact => {
                    // Apply search term
                    if (this.dbFilter && !fact.text.toLowerCase().includes(this.dbFilter) && 
                        !fact.source.toLowerCase().includes(this.dbFilter)) {
                        return false;
                    }
                    
                    // Apply domain filter
                    if (this.dbDomainFilter !== 'all' && fact.domain !== this.dbDomainFilter) {
                        return false;
                    }
                    
                    return true;
                });
                
                // Sort facts
                switch (this.dbSortBy) {
                    case 'newest':
                        filtered.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                        break;
                    case 'oldest':
                        filtered.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                        break;
                    case 'domain':
                        filtered.sort((a, b) => a.domain.localeCompare(b.domain));
                        break;
                    case 'trusted':
                        filtered.sort((a, b) => (b.trusted ? 1 : 0) - (a.trusted ? 1 : 0));
                        break;
                }
                
                return filtered;
            }
            
            /**
             * Edit a fact
             */
            editFact(factId) {
                const fact = this.knowledgeBase.getFact(factId);
                
                if (!fact) {
                    return;
                }
                
                // Show modal with edit form
                const modalContent = `
                    <div class="edit-fact-form">
                        <div class="form-group">
                            <label for="edit-fact-text">Fact:</label>
                            <textarea id="edit-fact-text">${fact.text}</textarea>
                        </div>
                        <div class="form-group">
                            <label for="edit-fact-source">Source:</label>
                            <input type="text" id="edit-fact-source" value="${fact.source}">
                        </div>
                        <div class="form-group">
                            <label for="edit-fact-domain">Domain:</label>
                            <select id="edit-fact-domain">
                                <option value="general" ${fact.domain === 'general' ? 'selected' : ''}>General Knowledge</option>
                                <option value="science" ${fact.domain === 'science' ? 'selected' : ''}>Science</option>
                                <option value="history" ${fact.domain === 'history' ? 'selected' : ''}>History</option>
                                <option value="law" ${fact.domain === 'law' ? 'selected' : ''}>Law</option>
                                <option value="technology" ${fact.domain === 'technology' ? 'selected' : ''}>Technology</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Verification Status:</label>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="trusted-status" value="trusted" ${fact.trusted ? 'checked' : ''}>
                                    Trusted
                                </label>
                                <label>
                                    <input type="radio" name="trusted-status" value="untrusted" ${!fact.trusted ? 'checked' : ''}>
                                    Untrusted
                                </label>
                            </div>
                        </div>
                    </div>
                `;
                
                this.showModal('Edit Fact', modalContent, [
                    { text: 'Cancel', action: 'close' },
                    { 
                        text: 'Save', 
                        action: () => {
                            const newText = document.getElementById('edit-fact-text').value.trim();
                            const newSource = document.getElementById('edit-fact-source').value.trim();
                            const newDomain = document.getElementById('edit-fact-domain').value;
                            const newTrustedStatus = document.querySelector('input[name="trusted-status"]:checked').value === 'trusted';
                            
                            if (newText && newSource) {
                                this.knowledgeBase.updateFact(factId, newText, newSource, newDomain, newTrustedStatus);
                                this.saveToLocalStorage();
                                
                                // Update tables if visible
                                if (this.currentSection === 'section-knowledge-base') {
                                    this.updateKnowledgeBaseTable();
                                } else if (this.currentSection === 'section-database') {
                                    this.updateDatabaseTable();
                                }
                                
                                this.hideModal();
                            } else {
                                alert('Please provide both text and source for the fact.');
                            }
                        },
                        primary: true
                    }
                ]);
            }
            
            /**
             * Delete a fact
             */
            deleteFact(factId) {
                // Show confirmation dialog
                this.showModal('Confirm Deletion', 'Are you sure you want to delete this fact? This action cannot be undone.', [
                    { text: 'Cancel', action: 'close' },
                    { 
                        text: 'Delete', 
                        action: () => {
                            this.knowledgeBase.removeFact(factId);
                            this.saveToLocalStorage();
                            
                            // Update tables if visible
                            if (this.currentSection === 'section-knowledge-base') {
                                this.updateKnowledgeBaseTable();
                            } else if (this.currentSection === 'section-database') {
                                this.updateDatabaseTable();
                            }
                            
                            this.hideModal();
                        },
                        warning: true
                    }
                ]);
            }
            
            /**
             * Update settings UI
             */
            updateSettingsUI() {
                // Update settings form with current values
                document.getElementById('show-sources').checked = this.settings.showSources;
                document.getElementById('enable-database-mode').checked = this.settings.databaseModeEnabled;
                document.getElementById('response-style').value = this.settings.responseStyle;
            }
            
            /**
             * Save settings
             */
            saveSettings() {
                // Get values from settings form
                this.settings.showSources = document.getElementById('show-sources').checked;
                this.settings.databaseModeEnabled = document.getElementById('enable-database-mode').checked;
                this.settings.responseStyle = document.getElementById('response-style').value;
                
                // Save to local storage
                this.saveToLocalStorage();
                
                // Show confirmation
                this.showToast('Settings saved successfully');
            }
            
            /**
             * Reset settings to defaults
             */
            resetSettings() {
                // Reset to default settings
                this.settings = {
                    showSources: true,
                    responseStyle: 'concise',
                    databaseModeEnabled: false
                };
                
                // Update UI
                this.updateSettingsUI();
                
                // Save to local storage
                this.saveToLocalStorage();
                
                // Show confirmation
                this.showToast('Settings reset to defaults');
            }
            
            /**
             * Export knowledge base
             */
            exportKnowledgeBase() {
                try {
                    const kbData = this.knowledgeBase.toJSON();
                    
                    // Create download link
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(kbData);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "smallllm-knowledge-base.json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    
                    this.showToast('Knowledge base exported successfully');
                } catch (e) {
                    console.error('Error exporting knowledge base:', e);
                    this.showModal('Export Error', `Failed to export knowledge base: ${e.message}`, [
                        { text: 'OK', action: 'close', primary: true }
                    ]);
                }
            }
            
            /**
             * Import knowledge base
             */
            importKnowledgeBase() {
                // Create file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const kbData = event.target.result;
                            this.knowledgeBase.fromJSON(kbData);
                            this.saveToLocalStorage();
                            
                            // Update tables if visible
                            if (this.currentSection === 'section-knowledge-base') {
                                this.updateKnowledgeBaseTable();
                            } else if (this.currentSection === 'section-database') {
                                this.updateDatabaseTable();
                            }
                            
                            this.showToast('Knowledge base imported successfully');
                        } catch (error) {
                            console.error('Error importing knowledge base:', error);
                            this.showModal('Import Error', `Failed to import knowledge base: ${error.message}`, [
                                { text: 'OK', action: 'close', primary: true }
                            ]);
                        }
                    };
                    
                    reader.readAsText(file);
                    
                    // Remove the input element
                    fileInput.remove();
                });
                
                document.body.appendChild(fileInput);
                fileInput.click();
            }
            
            /**
             * Reset knowledge base
             */
            resetKnowledgeBase() {
                this.showModal('Confirm Reset', 'Are you sure you want to clear the entire knowledge base? This action cannot be undone.', [
                    { text: 'Cancel', action: 'close' },
                    { 
                        text: 'Reset Knowledge Base', 
                        action: () => {
                            this.knowledgeBase.clear();
                            this.saveToLocalStorage();
                            
                            // Update tables if visible
                            if (this.currentSection === 'section-knowledge-base') {
                                this.updateKnowledgeBaseTable();
                            } else if (this.currentSection === 'section-database') {
                                this.updateDatabaseTable();
                            }
                            
                            this.hideModal();
                            this.showToast('Knowledge base cleared');
                        },
                        warning: true
                    }
                ]);
            }
            
            /**
             * Save character map
             */
            saveCharMap() {
                if (!this.isCharMapLoaded || this.charMap.length === 0) {
                    this.showToast('No character map available to save');
                    return;
                }
                
                try {
                    // Create JSON representation
                    const charMapData = JSON.stringify(this.charMap);
                    
                    // Create download link
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(charMapData);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "smallllm-charmap.json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    
                    this.showToast('Character map saved successfully');
                } catch (e) {
                    console.error('Error saving character map:', e);
                    this.showToast('Error saving character map');
                }
            }
            
            /**
             * Load character map
             */
            loadCharMap() {
                // Create file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const charMapData = event.target.result;
                            this.charMap = JSON.parse(charMapData);
                            this.isCharMapLoaded = this.charMap.length > 0;
                            
                            // Make charMap available globally
                            window.charMap = this.charMap;
                            
                            // Save to local storage
                            this.saveToLocalStorage();
                            
                            // Update character map display if on training tab
                            if (this.currentSection === 'section-train') {
                                this.displayCharMap();
                                this.updateCharMapStatus(`STATUS: LOADED CHARACTER MAP (${this.charMap.length} CHARACTERS)`);
                            }
                            
                            this.showToast('Character map loaded successfully');
                        } catch (error) {
                            console.error('Error loading character map:', error);
                            this.showToast('Error loading character map');
                        }
                    };
                    
                    reader.readAsText(file);
                    
                    // Remove the input element
                    fileInput.remove();
                });
                
                document.body.appendChild(fileInput);
                fileInput.click();
            }
            
            /**
             * Save session to file
             */
            saveSessionToFile() {
                try {
                    // Create complete session data
                    const sessionData = {
                        version: "1.0.0",
                        timestamp: new Date().toISOString(),
                        knowledgeBase: JSON.parse(this.knowledgeBase.toJSON()),
                        patterns: this.patternMatcher.patterns,
                        settings: this.settings,
                        charMap: this.charMap
                    };
                    
                    // Convert to JSON
                    const sessionJSON = JSON.stringify(sessionData, null, 2);
                    
                    // Create download link
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(sessionJSON);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", this.sessionFilename);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    
                    this.showToast('Session saved successfully');
                } catch (e) {
                    console.error('Error saving session:', e);
                    this.showToast('Error saving session');
                }
            }
            
            /**
             * Load session from file
             */
            loadSessionFromFile() {
                // Create file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            // Parse the session data
                            const sessionData = JSON.parse(event.target.result);
                            
                            // Show loading status
                            this.showToast("Loading session file...");
                            
                            // Load the session directly
                            if (sessionData.knowledgeBase) {
                                this.knowledgeBase = new KnowledgeBase();
                                this.knowledgeBase.fromJSON(JSON.stringify(sessionData.knowledgeBase));
                            }
                            
                            if (sessionData.patterns) {
                                this.patternMatcher.patterns = sessionData.patterns;
                            }
                            
                            if (sessionData.settings) {
                                this.settings = sessionData.settings;
                            }
                            
                            if (sessionData.charMap) {
                                this.charMap = sessionData.charMap;
                                this.isCharMapLoaded = this.charMap.length > 0;
                                window.charMap = this.charMap;
                            }
                            
                            // Ensure all patterns have proper constraints
                            this.patternMatcher.patterns.forEach(pattern => {
                                if (!pattern.constraints) {
                                    pattern.constraints = {
                                        exactMatch: true,
                                        substringMatch: false,
                                        caseSensitive: false
                                    };
                                }
                            });
                            
                            // Save to local storage
                            this.saveToLocalStorage();
                            
                            // Update UI
                            this.updateUI();
                            
                            // Show success message
                            this.showToast(`Session loaded: ${this.patternMatcher.patterns.length} patterns, ${Object.keys(this.knowledgeBase.facts).length} facts`);
                            
                        } catch (error) {
                            console.error('Error loading session:', error);
                            this.showModal('Import Error', `Failed to parse session file: ${error.message}`, [
                                { text: 'OK', action: 'close', primary: true }
                            ]);
                        }
                    };
                    
                    reader.readAsText(file);
                    
                    // Remove the input element
                    fileInput.remove();
                });
                
                document.body.appendChild(fileInput);
                fileInput.click();
            }
            
            /**
             * Set up the file drop handler
             */
            setupFileDrop() {
                // Setup drag and drop for the entire window
                window.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.body.classList.add('drag-highlight');
                });
                
                window.addEventListener('dragleave', (e) => {
                    if (!e.relatedTarget || e.relatedTarget === document.body) {
                        document.body.classList.remove('drag-highlight');
                    }
                });
                
                window.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.body.classList.remove('drag-highlight');
                    
                    // Process dropped files
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        
                        // Check if it's a JSON file
                        if (file.name.endsWith('.json')) {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                try {
                                    const data = JSON.parse(event.target.result);
                                    
                                    // Show confirmation dialog
                                    this.showModal('Load File', `What type of file is "${file.name}"?`, [
                                        { text: 'Cancel', action: 'close' },
                                        { 
                                            text: 'Training Data', 
                                            action: () => {
                                                this.hideModal();
                                                this.processTrainingFile(file);
                                            },
                                            primary: true
                                        },
                                        {
                                            text: 'Session File',
                                            action: () => {
                                                this.hideModal();
                                                
                                                // Load as session
                                                try {
                                                    const sessionData = JSON.parse(event.target.result);
                                                    
                                                    if (sessionData.knowledgeBase) {
                                                        this.knowledgeBase = new KnowledgeBase();
                                                        this.knowledgeBase.fromJSON(JSON.stringify(sessionData.knowledgeBase));
                                                    }
                                                    
                                                    if (sessionData.patterns) {
                                                        this.patternMatcher.patterns = sessionData.patterns;
                                                    }
                                                    
                                                    if (sessionData.settings) {
                                                        this.settings = sessionData.settings;
                                                    }
                                                    
                                                    if (sessionData.charMap) {
                                                        this.charMap = sessionData.charMap;
                                                        this.isCharMapLoaded = this.charMap.length > 0;
                                                        window.charMap = this.charMap;
                                                    }
                                                    
                                                    // Save to local storage
                                                    this.saveToLocalStorage();
                                                    
                                                    // Update UI
                                                    this.updateUI();
                                                    
                                                    this.showToast(`Session loaded: ${this.patternMatcher.patterns.length} patterns, ${Object.keys(this.knowledgeBase.facts).length} facts`);
                                                } catch (error) {
                                                    console.error('Error loading session file:', error);
                                                    this.showToast('Error loading session file');
                                                }
                                            }
                                        }
                                    ]);
                                } catch (error) {
                                    console.error('Error parsing JSON file:', error);
                                    this.showToast('Error: Invalid JSON file');
                                }
                            };
                            
                            reader.readAsText(file);
                        } else {
                            this.showToast('Please drop a .json file');
                        }
                    }
                });
            }
            
            /**
             * Switch section
             */
            switchSection(sectionId) {
                // Hide all sections
                document.querySelectorAll('main > section').forEach(section => {
                    section.classList.add('hidden-section');
                    section.classList.remove('active-section');
                });
                
                // Show selected section
                document.getElementById(sectionId).classList.remove('hidden-section');
                document.getElementById(sectionId).classList.add('active-section');
                
                // Update navigation
                document.querySelectorAll('nav a').forEach(link => {
                    link.classList.remove('active');
                });
                
                // Determine which nav item to activate
                let navId = null;
                switch (sectionId) {
                    case 'section-home': navId = 'nav-home'; break;
                    case 'section-train': navId = 'nav-train'; break;
                    case 'section-knowledge-base': navId = 'nav-knowledge-base'; break;
                    case 'section-database': navId = 'nav-database'; break;
                    case 'section-settings': navId = 'nav-settings'; break;
                }
                
                if (navId) {
                    document.getElementById(navId).classList.add('active');
                }
                
                this.currentSection = sectionId;
            }
            
            /**
             * Fix accessibility issues
             */
            fixAccessibilityIssues() {
                // Add labels to form elements
                document.querySelectorAll('select, input, textarea').forEach(element => {
                    if (!element.getAttribute('aria-label') && !element.getAttribute('title') && !element.hasAttribute('aria-labelledby')) {
                        // Try to find label by id
                        const labelledBy = document.querySelector(`label[for="${element.id}"]`);
                        if (!labelledBy && element.id) {
                            element.setAttribute('title', element.id.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase()));
                        }
                    }
                });
                
                // Ensure modal has proper attributes
                const modal = document.getElementById('main-modal');
                if (modal) {
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');
                    
                    const modalTitle = document.getElementById('modal-title');
                    if (modalTitle) {
                        modalTitle.id = 'modal-title';
                        modal.setAttribute('aria-labelledby', 'modal-title');
                    }
                }
            }
            
            /**
             * Update UI elements
             */
            updateUI() {
                // Update knowledge base table
                if (this.currentSection === 'section-knowledge-base') {
                    this.updateKnowledgeBaseTable();
                }
                
                // Update database view
                if (this.currentSection === 'section-database') {
                    this.updateDatabaseTable();
                }
                
                // Update settings UI
                if (this.currentSection === 'section-settings') {
                    this.updateSettingsUI();
                }
                
                // Update character map display if on training tab
                if (this.currentSection === 'section-train' && this.isCharMapLoaded) {
                    this.displayCharMap();
                }
                
                // Update database mode checkbox
                const databaseModeCheckbox = document.getElementById('include-unverified');
                if (databaseModeCheckbox) {
                    databaseModeCheckbox.checked = this.settings.databaseModeEnabled;
                }
            }
            
            /**
             * Show a toast notification
             */
            showToast(message) {
                // Create toast element
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                
                // Add to document
                document.body.appendChild(toast);
                
                // Trigger animation
                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);
                
                // Remove after delay
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, 3000);
            }
            
            /**
             * Escape HTML
             */
            escapeHtml(text) {
                if (typeof text !== 'string') return '';
                
                return text
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
            
            // Character Map Management
            createStandardMap() {
                // Clear existing character map
                this.charMap = new Array(128); // Create a fixed-size array for ASCII
                
                // ASCII control characters (0-31) and DEL (127)
                for (let i = 0; i < 32; i++) {
                    // Only add specific control characters that are useful
                    if (i === 9) this.charMap[i] = '\t'; // Tab
                    else if (i === 10) this.charMap[i] = '\n'; // Line feed
                    else if (i === 13) this.charMap[i] = '\r'; // Carriage return
                    // Leave other control characters as undefined
                }
                
                // Space (32)
                this.charMap[32] = ' ';
                
                // Standard printable ASCII (33-126)
                for (let i = 33; i <= 126; i++) {
                    this.charMap[i] = String.fromCharCode(i);
                }
                
                this.isCharMapLoaded = true;
                
                // Make charMap available globally
                window.charMap = this.charMap;
                
                // Save to local storage
                this.saveToLocalStorage();
                
                // Update UI
                this.displayCharMap();
                
                // Count actual characters
                let charCount = this.countActualCharacters();
                
                this.updateCharMapStatus(`STATUS: STANDARD ASCII MAP LOADED (${charCount} CHARACTERS)`);
            }
            
            countActualCharacters() {
                let count = 0;
                for (let i = 0; i < this.charMap.length; i++) {
                    if (this.charMap[i] !== undefined) count++;
                }
                return count;
            }
            
            importCustomMap() {
                // Create a simple prompt for demo
                const customMap = prompt(
                    "Enter custom character map as comma-separated values:\n" +
                    "Format: index:character,index:character\n" +
                    "Example: 1:a,2:b,3:c,4:d,5:e\n\n" +
                    "Special characters can be entered as:\n" +
                    "\\n for newline, \\t for tab, \\r for carriage return, \\s for space"
                );
                
                if (!customMap) return;
                
                // Create a new character map
                this.charMap = new Array(128); // Default size for ASCII
                
                const entries = customMap.split(',');
                let count = 0;
                
                for (const entry of entries) {
                    const [indexStr, charValue] = entry.split(':');
                    
                    if (indexStr && charValue) {
                        const index = parseInt(indexStr.trim(), 10);
                        if (!isNaN(index) && index >= 0) {
                            // Process special character codes
                            let char = charValue.trim();
                            
                            if (char === '\\n') char = '\n';
                            else if (char === '\\t') char = '\t';
                            else if (char === '\\r') char = '\r';
                            else if (char === '\\s') char = ' ';
                            
                            this.charMap[index] = char;
                            count++;
                        }
                    }
                }
                
                if (count > 0) {
                    this.isCharMapLoaded = true;
                    
                    // Make charMap available globally
                    window.charMap = this.charMap;
                    
                    // Save to local storage
                    this.saveToLocalStorage();
                    
                    // Update UI
                    this.displayCharMap();
                    this.updateCharMapStatus(`STATUS: CUSTOM MAP LOADED (${count} CHARACTERS)`);
                } else {
                    this.updateCharMapStatus("STATUS: FAILED TO LOAD CUSTOM MAP");
                }
            }
            
            displayCharMap() {
                const charMapGrid = document.getElementById('char-map-grid');
                charMapGrid.innerHTML = '';
                
                if (!this.isCharMapLoaded || !this.charMap || this.charMap.length === 0) {
                    charMapGrid.innerHTML = '<div class="grid-placeholder">No character map loaded</div>';
                    return;
                }
                
                // Count actual characters
                let actualCharCount = this.countActualCharacters();
                
                // Check if the character map appears to be empty despite being "loaded"
                if (actualCharCount === 0) {
                    console.error("Character map is marked as loaded but contains no characters");
                    charMapGrid.innerHTML = '<div class="grid-placeholder">Character map appears to be empty</div>';
                    this.isCharMapLoaded = false;
                    return;
                }
                
                // Create a clean representation of the character map for display
                const displayMap = new Array(Math.max(127, this.charMap.length)).fill(null);
                
                // Fill in the known characters
                for (let i = 0; i < this.charMap.length; i++) {
                    if (this.charMap[i] !== undefined) {
                        displayMap[i] = this.charMap[i];
                    }
                }
                
                // Generate display items for the grid
                for (let i = 0; i < displayMap.length; i++) {
                    const charValue = displayMap[i];
                    
                    // Skip truly empty/undefined slots to save space
                    if (charValue === undefined) continue;
                    
                    const charItem = document.createElement('div');
                    charItem.className = 'char-map-item';
                    if (charValue === null) charItem.classList.add('null-char');
                    
                    // Display the character (with special handling for control characters)
                    let displayChar = charValue;
                    let displayClass = '';
                    
                    if (charValue === null) {
                        displayChar = 'null';
                        displayClass = 'null-value';
                    } else if (charValue === '') {
                        displayChar = '∅';
                        displayClass = 'empty-value';
                    } else if (charValue === '\n') {
                        displayChar = '\\n';
                        displayClass = 'special-char';
                    } else if (charValue === '\r') {
                        displayChar = '\\r';
                        displayClass = 'special-char';
                    } else if (charValue === '\t') {
                        displayChar = '\\t';
                        displayClass = 'special-char';
                    } else if (charValue === ' ') {
                        displayChar = '␣'; // Space symbol
                        displayClass = 'space-char';
                    } else {
                        // Check if it's a printable character
                        const code = charValue.charCodeAt(0);
                        if (code < 32 || code === 127) { // Control characters
                            displayChar = `\\x${code.toString(16).padStart(2, '0')}`;
                            displayClass = 'control-char';
                        }
                    }
                    
                    charItem.innerHTML = `
                        <span class="char-map-value ${displayClass}">${displayChar}</span>
                        <span class="char-map-index">${i}</span>
                    `;
                    
                    charMapGrid.appendChild(charItem);
                }
                
                // Update the character map status
                this.updateCharMapStatus(`STATUS: LOADED CHARACTER MAP (${actualCharCount} CHARACTERS)`);
            }
            
            updateCharMapStatus(message) {
                const charMapStatus = document.getElementById('char-map-status');
                if (charMapStatus) {
                    charMapStatus.textContent = message;
                }
            }
            
            // Animation for training visualization
            animateMatrixVisualization() {
                const matrixVisualizationGrid = document.getElementById('matrix-visualization-grid');
                matrixVisualizationGrid.innerHTML = '';
                
                // Create grid cells
                for (let i = 0; i < 32 * 8; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    
                    // Add random 0s and 1s for animation
                    cell.textContent = Math.random() > 0.5 ? '1' : '0';
                    
                    matrixVisualizationGrid.appendChild(cell);
                }
                
                // Animation loop
                let animationFrame = 0;
                const maxFrames = 30;
                
                const updateMatrix = () => {
                    // Update some cells randomly
                    const cells = matrixVisualizationGrid.children;
                    for (let i = 0; i < cells.length; i++) {
                        if (Math.random() > 0.8) {
                            cells[i].textContent = Math.random() > 0.5 ? '1' : '0';
                            
                            // Add random opacity
                            cells[i].style.opacity = Math.random() * 0.5 + 0.5;
                        }
                    }
                    
                    animationFrame++;
                    
                    if (animationFrame < maxFrames) {
                        requestAnimationFrame(updateMatrix);
                    }
                };
                
                // Start animation
                updateMatrix();
            }
            
            // Initialize deterministic training system
            initDeterministicTrainingSystem() {
                // Set up event listeners for character map controls
                const createStandardMapBtn = document.getElementById('create-standard-map');
                const importCustomMapBtn = document.getElementById('import-custom-map');
                
                if (createStandardMapBtn) {
                    createStandardMapBtn.addEventListener('click', () => this.createStandardMap());
                }
                
                if (importCustomMapBtn) {
                    importCustomMapBtn.addEventListener('click', () => this.importCustomMap());
                }
                
                // Initialize character map display if it's already loaded
                if (this.isCharMapLoaded) {
                    this.displayCharMap();
                    const actualCharCount = this.countActualCharacters();
                    this.updateCharMapStatus(`STATUS: LOADED CHARACTER MAP (${actualCharCount} CHARACTERS)`);
                }
            }
        }
        
        // Initialize the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.app = new SmallLLM();
        });
    </script>
</body>
</html>