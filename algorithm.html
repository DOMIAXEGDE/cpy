<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Bank Manager</title>
	<link rel="stylesheet" href="algorithm-themes.css">
</head>
<body>

    <!-- Theme Selector -->
    <div class="theme-selector">
        <label for="themeSelect">Theme:</label>
        <select id="themeSelect">
            <option value="default">Default</option>
            <option value="cpp">C++ Developer</option>
            <option value="minecraft">Minecraft Java</option>
        </select>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Header -->
        <header>
            <h1>DATA BANK MANAGER</h1>
            <p>Manage and query multi-level reference data files</p>
        </header>

        <!-- Main scrollable content area -->
        <div class="main-content">
            <!-- Bank Configuration Section -->
            <section class="config-section">
                <h2>BANK CONFIGURATION</h2>
                <div class="config-grid">
                    <div class="config-item">
                        <label for="maxRegisters">Max Registers Per Bank</label>
                        <input type="number" id="maxRegisters" min="1" max="100" value="10">
                    </div>
                    <div class="config-item">
                        <label for="maxAddresses">Max Addresses Per Register</label>
                        <input type="number" id="maxAddresses" min="1" max="100" value="20">
                    </div>
                    <div class="config-item">
                        <label for="readingMode">Reading Mode</label>
                        <select id="readingMode">
                            <option value="raw">raw</option>
                            <option value="resolve">resolve</option>
                        </select>
                    </div>
                </div>
                <div class="file-actions">
                    <label>Bank Files</label>
                    <button id="uploadButton" tabindex="0">UPLOAD FILES</button>
                    <button id="createNewButton" tabindex="0">CREATE NEW BANK</button>
                    <button id="downloadAllButton" tabindex="0">DOWNLOAD ALL</button>
                    <input type="file" id="fileUpload" multiple accept=".txt" style="display: none;">
                </div>
            </section>

            <!-- Data Banks Section -->
            <section class="banks-section">
                <h2>DATA BANKS</h2>
                <div class="tab-container" id="bankTabs" role="tablist">
                    <div class="tab" id="addBankTab" role="tab" tabindex="0" aria-selected="false">+ Add</div>
                </div>
                <div class="tab-contents" id="bankContents">
                    <!-- Bank content will be dynamically added here -->
                </div>
            </section>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="statusBar">READY</div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast" role="alert"></div>

    <!-- New Bank Modal -->
    <div class="modal-overlay" id="newBankModal" role="dialog" aria-labelledby="newBankTitle">
        <div class="modal">
            <div class="modal-title" id="newBankTitle">Create New Bank</div>
            <div class="form-row">
                <label for="bankId">Bank ID Number</label>
                <input type="number" id="bankId" min="1" value="1">
            </div>
            <div class="form-row">
                <label for="numRegisters">Number of Registers</label>
                <input type="number" id="numRegisters" min="1" value="3">
            </div>
            <div class="form-row">
                <label for="numAddresses">Addresses Per Register</label>
                <input type="number" id="numAddresses" min="1" value="5">
            </div>
            <div class="modal-buttons">
                <button id="cancelNewBank" tabindex="0">Cancel</button>
                <button id="createBank" tabindex="0">Create</button>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const app = {
            maxRegisters: 10,
            maxAddresses: 20,
            readingMode: "raw",
            banks: {},
            currentBankId: null,
            editMode: {},
			currentTheme: "default" // Default theme
        };

        // DOM Elements
        const elements = {
            maxRegisters: document.getElementById("maxRegisters"),
            maxAddresses: document.getElementById("maxAddresses"),
            readingMode: document.getElementById("readingMode"),
            uploadButton: document.getElementById("uploadButton"),
            fileUpload: document.getElementById("fileUpload"),
            createNewButton: document.getElementById("createNewButton"),
            downloadAllButton: document.getElementById("downloadAllButton"),
            bankTabs: document.getElementById("bankTabs"),
            bankContents: document.getElementById("bankContents"),
            statusBar: document.getElementById("statusBar"),
            toast: document.getElementById("toast"),
            newBankModal: document.getElementById("newBankModal"),
            bankId: document.getElementById("bankId"),
            numRegisters: document.getElementById("numRegisters"),
            numAddresses: document.getElementById("numAddresses"),
            cancelNewBank: document.getElementById("cancelNewBank"),
            createBank: document.getElementById("createBank"),
            addBankTab: document.getElementById("addBankTab"),
            themeSelect: document.getElementById("themeSelect")
        };

        // Initialize application
        function initApp() {
            // Set up event listeners
            elements.maxRegisters.addEventListener("change", updateConfig);
            elements.maxAddresses.addEventListener("change", updateConfig);
            elements.readingMode.addEventListener("change", updateReadingMode);
            elements.uploadButton.addEventListener("click", () => elements.fileUpload.click());
            elements.fileUpload.addEventListener("change", handleFileUpload);
            elements.createNewButton.addEventListener("click", showNewBankModal);
            elements.downloadAllButton.addEventListener("click", downloadAllBanks);
            elements.addBankTab.addEventListener("click", showNewBankModal);
            elements.cancelNewBank.addEventListener("click", hideNewBankModal);
            elements.createBank.addEventListener("click", createNewBank);
			elements.themeSelect.addEventListener("change", changeTheme);

            // Add keyboard accessibility for tabs
            elements.addBankTab.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    showNewBankModal();
                }
            });

            // Load config from storage
            loadConfigFromStorage();

            // Apply saved theme
            loadThemeFromStorage();

        }
		
        // Theme management
        function changeTheme() {
            const selectedTheme = elements.themeSelect.value;
            
            // Remove existing theme classes
            document.body.classList.remove('theme-cpp', 'theme-minecraft');
            
            // Add new theme class if not default
            if (selectedTheme !== 'default') {
                document.body.classList.add(`theme-${selectedTheme}`);
            }
            
            // Save theme preference
            app.currentTheme = selectedTheme;
            saveThemeToStorage();
            
            showToast(`Theme changed to ${selectedTheme}`);
        }
        
        function saveThemeToStorage() {
            try {
                localStorage.setItem("dataBankTheme", app.currentTheme);
            } catch (e) {
                console.error("Error saving theme:", e);
            }
        }
        
        function loadThemeFromStorage() {
            try {
                const savedTheme = localStorage.getItem("dataBankTheme");
                if (savedTheme) {
                    app.currentTheme = savedTheme;
                    elements.themeSelect.value = savedTheme;
                    
                    // Apply the theme
                    if (savedTheme !== 'default') {
                        document.body.classList.add(`theme-${savedTheme}`);
                    }
                }
            } catch (e) {
                console.error("Error loading theme:", e);
            }
        }

        // Configuration methods
        function loadConfigFromStorage() {
            try {
                const storedConfig = localStorage.getItem("dataBankConfig");
                if (storedConfig) {
                    const config = JSON.parse(storedConfig);
                    app.maxRegisters = config.maxRegisters || 10;
                    app.maxAddresses = config.maxAddresses || 20;
                    app.readingMode = config.readingMode || "raw";

                    // Update UI controls
                    elements.maxRegisters.value = app.maxRegisters;
                    elements.maxAddresses.value = app.maxAddresses;
                    elements.readingMode.value = app.readingMode;
                }
            } catch (e) {
                console.error("Error loading config:", e);
            }
        }

        function saveConfigToStorage() {
            try {
                localStorage.setItem("dataBankConfig", JSON.stringify({
                    maxRegisters: app.maxRegisters,
                    maxAddresses: app.maxAddresses,
                    readingMode: app.readingMode
                }));
            } catch (e) {
                console.error("Error saving config:", e);
            }
        }

        function updateConfig() {
            try {
                app.maxRegisters = parseInt(elements.maxRegisters.value);
                app.maxAddresses = parseInt(elements.maxAddresses.value);
                saveConfigToStorage();
                showToast("Configuration updated");
            } catch (e) {
                showToast(`Error updating config: ${e}`);
            }
        }

        function updateReadingMode() {
            const previousMode = app.readingMode;
            app.readingMode = elements.readingMode.value;

            if (previousMode !== app.readingMode) {
                saveConfigToStorage();
                refreshAllBanks();
                showToast(`Reading mode changed to: ${app.readingMode}`);
            }
        }

        // File handling methods
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            setStatusMessage("Processing files...");

            let processedCount = 0;
            let errorCount = 0;

            // Process each file
            Array.from(files).forEach(file => {
                // Check filename format (should be number.txt)
                const match = file.name.match(/^(\d+)\.txt$/);

                if (!match) {
                    showToast(`Skipped ${file.name} - Invalid filename format. Should be 'number.txt'`);
                    errorCount++;
                    return;
                }

                const bankId = parseInt(match[1]);

                // Read file content
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        processFileContent(bankId, content);
                        processedCount++;

                        // Show notification when all files are processed
                        if (processedCount + errorCount === files.length) {
                            setStatusMessage("File processing complete");
                            showToast(`Processed ${processedCount} bank files, ${errorCount} errors`);
                        }
                    } catch (e) {
                        errorCount++;
                        showToast(`Failed to read file: ${file.name} - ${e.message}`);
                    }
                };

                reader.readAsText(file);
            });

            // Reset file input
            event.target.value = "";
        }

        function processFileContent(bankId, content) {
            try {
                const bank = parseBankData(bankId, content);
                app.banks[bankId] = bank;

                // Create or update the bank tab
                createBankTab(bankId);

                // If this is the first bank, select it
                if (app.currentBankId === null) {
                    selectBank(bankId);
                }

                showToast(`Bank ${bankId} loaded successfully`);
            } catch (e) {
                showToast(`Error processing Bank ${bankId}: ${e.message}`);
                console.error(`Error processing Bank ${bankId}:`, e);
            }
        }

        // Modified parseBankData function to support multi-line values
        function parseBankData(bankId, content) {
            const lines = content.split('\n');
            const bank = {
                id: bankId,
                registers: {}
            };

            let currentRegister = null;
            let inMultiLineValue = false;
            let currentAddressId = null;
            let multiLineBuffer = [];

            // Process each line
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // If we're collecting a multi-line value
                if (inMultiLineValue) {
                    // Check if this line ends the multi-line value
                    if (line.trim() === '"""') {
                        // Save the multi-line value
                        bank.registers[currentRegister].addresses[currentAddressId] = multiLineBuffer.join('\n');
                        multiLineBuffer = [];
                        inMultiLineValue = false;
                    } else {
                        // Add to multi-line buffer
                        multiLineBuffer.push(line);
                    }
                    continue;
                }

                // Skip empty lines when not in multi-line mode
                if (!line.trim() && !inMultiLineValue) {
                    continue;
                }

                // Check if it's a register line (no tab at the beginning)
                if (!line.startsWith('\t')) {
                    // It's a register number
                    try {
                        currentRegister = parseInt(line.trim());
                    } catch (e) {
                        throw new Error(`Invalid register number at line ${i + 1}`);
                    }

                    // Initialize register if not exists
                    if (!bank.registers[currentRegister]) {
                        bank.registers[currentRegister] = {
                            addresses: {}
                        };
                    }
                } else {
                    // It's an address line (starts with tab)
                    if (currentRegister === null) {
                        throw new Error(`Address found before any register at line ${i + 1}`);
                    }

                    // Extract the content after the tab
                    const addressLine = line.replace(/^\t+/, '');

                    // Split into address ID and value using the first tab as delimiter
                    const parts = addressLine.split('\t', 2);

                    try {
                        const addressId = parseInt(parts[0].trim());
                        currentAddressId = addressId;
                        
                        if (parts.length === 1) {
                            // Empty value
                            bank.registers[currentRegister].addresses[addressId] = "";
                        } else {
                            // Check if this is a multi-line value start
                            if (parts[1].trim() === '"""') {
                                inMultiLineValue = true;
                                multiLineBuffer = [];
                            } else {
                                // Single-line value
                                bank.registers[currentRegister].addresses[addressId] = parts[1];
                            }
                        }
                    } catch (e) {
                        throw new Error(`Invalid address format at line ${i + 1}`);
                    }
                }
            }

            // Check if we ended with an unclosed multi-line value
            if (inMultiLineValue) {
                throw new Error('Unclosed multi-line value at end of file');
            }

            return bank;
        }

        // Tab management methods
        function createBankTab(bankId) {
            // Check if tab already exists
            const existingTab = document.getElementById(`bankTab_${bankId}`);
            if (existingTab) {
                return; // Tab already exists
            }

            // Create new tab
            const tab = document.createElement("div");
            tab.className = "tab";
            tab.id = `bankTab_${bankId}`;
            tab.textContent = `Bank ${bankId}`;
            tab.setAttribute("role", "tab");
            tab.setAttribute("tabindex", "0");
            tab.setAttribute("aria-selected", "false");
            
            // Add event listeners
            tab.addEventListener("click", () => selectBank(bankId));
            tab.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    selectBank(bankId);
                }
            });

            // Insert before the Add tab
            elements.bankTabs.insertBefore(tab, elements.addBankTab);

            // Create content container for this bank
            const content = document.createElement("div");
            content.className = "tab-content";
            content.id = `bankContent_${bankId}`;
            content.setAttribute("role", "tabpanel");
            content.setAttribute("aria-labelledby", `bankTab_${bankId}`);
            elements.bankContents.appendChild(content);
        }

        function selectBank(bankId) {
            // Update current bank ID
            app.currentBankId = bankId;

            // Update tab styles and ARIA attributes
            const tabs = elements.bankTabs.querySelectorAll(".tab");
            tabs.forEach(tab => {
                tab.classList.remove("active");
                tab.setAttribute("aria-selected", "false");
            });
            
            const selectedTab = document.getElementById(`bankTab_${bankId}`);
            if (selectedTab) {
                selectedTab.classList.add("active");
                selectedTab.setAttribute("aria-selected", "true");
            }

            // Update content visibility
            const contents = elements.bankContents.querySelectorAll(".tab-content");
            contents.forEach(content => content.classList.remove("active"));
            const selectedContent = document.getElementById(`bankContent_${bankId}`);
            if (selectedContent) {
                selectedContent.classList.add("active");
                displayBankData(bankId);
            }
        }

        // Bank data display methods
        function displayBankData(bankId) {
            // Get the bank data
            const bank = app.banks[bankId];
            if (!bank) return;

            // Get the content container
            const contentContainer = document.getElementById(`bankContent_${bankId}`);
            if (!contentContainer) return;

            // Clear the container
            contentContainer.innerHTML = "";

            // Check if in edit mode
            if (app.editMode[bankId]) {
                displayEditMode(bankId, contentContainer);
            } else {
                displayViewMode(bankId, contentContainer);
            }
        }

        function displayEditMode(bankId, container) {
            const bank = app.banks[bankId];

            // Create edit control toolbar
            const toolbar = document.createElement("div");
            toolbar.className = "bank-toolbar";
            toolbar.innerHTML = `
                <div>Editing Bank ${bankId}</div>
                <div>
                    <button id="cancelEditBank_${bankId}" tabindex="0">Cancel</button>
                    <button id="saveEditBank_${bankId}" tabindex="0">Save</button>
                </div>
            `;
            container.appendChild(toolbar);

            // Add event listeners to buttons
            document.getElementById(`cancelEditBank_${bankId}`).addEventListener("click", () => cancelBankEdits(bankId));
            document.getElementById(`saveEditBank_${bankId}`).addEventListener("click", () => saveBankEdits(bankId));

            // Create editor container to control flex sizing
            const editorContainer = document.createElement("div");
            editorContainer.className = "editor-container";
            container.appendChild(editorContainer);

            // Create text editor
            const textEditor = document.createElement("textarea");
            textEditor.className = "text-editor";
            textEditor.id = `textEditor_${bankId}`;
            textEditor.spellcheck = false;
            
            // Enable tab character insertion
            textEditor.addEventListener("keydown", function(e) {
                if (e.key === "Tab") {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert tab at cursor position
                    this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                    
                    // Move cursor after the inserted tab
                    this.selectionStart = this.selectionEnd = start + 1;
                }
            });
            
            editorContainer.appendChild(textEditor);

            // Generate bank text content
            const bankText = generateBankText(bank);
            textEditor.value = bankText;
            
            // Focus the editor
            setTimeout(() => textEditor.focus(), 0);
        }

        function displayViewMode(bankId, container) {
            const bank = app.banks[bankId];

            // Create toolbar
            const toolbar = document.createElement("div");
            toolbar.className = "bank-toolbar";
            toolbar.innerHTML = `
                <div>Bank ${bankId}</div>
                <div>
                    <button id="editBank_${bankId}" tabindex="0">Edit Bank</button>
                    <button id="downloadBank_${bankId}" tabindex="0">Download</button>
                </div>
            `;
            container.appendChild(toolbar);

            // Add event listeners to buttons
            document.getElementById(`editBank_${bankId}`).addEventListener("click", () => startEditMode(bankId));
            document.getElementById(`downloadBank_${bankId}`).addEventListener("click", () => downloadBank(bankId));

            // Create a scrollable container for registers
            const registersContainer = document.createElement("div");
            registersContainer.className = "registers-container";
            container.appendChild(registersContainer);

            // Sort registers by ID
            const registerIds = Object.keys(bank.registers).map(id => parseInt(id)).sort((a, b) => a - b);

            // Create UI for each register
            registerIds.forEach(registerId => {
                const register = bank.registers[registerId];

                // Register container
                const registerContainer = document.createElement("div");
                registerContainer.className = "register-container";
                registersContainer.appendChild(registerContainer);

                // Register header
                const registerHeader = document.createElement("div");
                registerHeader.className = "register-header";
                registerHeader.textContent = `Register ${registerId}`;
                registerContainer.appendChild(registerHeader);

                // Addresses table
                const table = document.createElement("table");
                table.className = "addresses-table";
                registerContainer.appendChild(table);

                // Table header
                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr>
                        <th>Address</th>
                        <th>Value</th>
                    </tr>
                `;
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement("tbody");
                table.appendChild(tbody);

                // Sort addresses by ID
                const addressIds = Object.keys(register.addresses).map(id => parseInt(id)).sort((a, b) => a - b);

                // Create rows for each address
                addressIds.forEach(addressId => {
                    const value = register.addresses[addressId];
                    const row = document.createElement("tr");
                    
                    // Address ID cell
                    const addressCell = document.createElement("td");
                    addressCell.textContent = addressId;
                    addressCell.setAttribute("data-label", "Address:");
                    row.appendChild(addressCell);
                    
                    // Value cell
                    const valueCell = document.createElement("td");
                    valueCell.setAttribute("data-label", "Value:");
                    
                    if (app.readingMode === "resolve" && containsReferences(value)) {
                        // Raw value with reference highlighting
                        valueCell.appendChild(formatValueWithReferences(value, bankId, registerId, addressId));
                        
                        // Resolved value
                        const resolvedValue = resolveValue(value);
                        const resolvedDiv = document.createElement("div");
                        resolvedDiv.className = "resolved-value";
                        
                        if (resolvedValue.includes('\n')) {
                            // Multi-line resolved value
                            resolvedDiv.appendChild(document.createTextNode("→ "));
                            const pre = document.createElement("pre");
                            pre.style.margin = "0";
                            pre.style.whiteSpace = "pre-wrap";
                            pre.style.fontFamily = "inherit";
                            pre.textContent = resolvedValue;
                            resolvedDiv.appendChild(pre);
                        } else {
                            // Single-line resolved value
                            resolvedDiv.textContent = `→ ${resolvedValue}`;
                        }
                        
                        valueCell.appendChild(resolvedDiv);
                    } else {
                        // Display raw value with proper formatting
                        valueCell.appendChild(displayValueWithFormatting(value));
                    }
                    
                    row.appendChild(valueCell);
                    tbody.appendChild(row);
                });
            });
        }

        // Helper function to display value with proper formatting
        function displayValueWithFormatting(value) {
            const container = document.createElement("div");
            
            // Add special class for multi-line values
            if (value && value.includes('\n')) {
                container.classList.add("multi-line-value");
            }
            
            // Create a text node that preserves whitespace
            const pre = document.createElement("pre");
            pre.style.margin = "0";
            pre.style.whiteSpace = "pre-wrap";
            pre.style.wordBreak = "break-word";
            pre.style.fontFamily = "inherit";
            pre.textContent = value || "";
            
            container.appendChild(pre);
            return container;
        }

        function containsReferences(value) {
            if (!value) return false;
            
            // Regular expression to find references (e.g., 1.2.3)
            const refRegex = /\d+\.\d+\.\d+/;
            return refRegex.test(value);
        }

        function formatValueWithReferences(value, bankId, registerId, addressId) {
            if (!value) return document.createTextNode("");
            
            // Create a container for the formatted text
            const container = document.createElement("div");
            
            // For multi-line content, we need to process each line separately
            // while maintaining the line breaks
            if (value.includes('\n')) {
                container.classList.add("multi-line-value");
                
                const lines = value.split('\n');
                
                lines.forEach((line, lineIndex) => {
                    // Process references in this line
                    const lineElement = processLineWithReferences(line, bankId, registerId, addressId);
                    container.appendChild(lineElement);
                    
                    // Add line break for all but the last line
                    if (lineIndex < lines.length - 1) {
                        container.appendChild(document.createElement("br"));
                    }
                });
            } else {
                // Single line processing
                const processedLine = processLineWithReferences(value, bankId, registerId, addressId);
                container.appendChild(processedLine);
            }
            
            return container;
        }

        function processLineWithReferences(line, bankId, registerId, addressId) {
            const container = document.createElement("span");
            
            // Regular expression to find references
            const refRegex = /(\d+\.\d+\.\d+)/g;
            
            // Split the text by references
            const parts = line.split(refRegex);
            
            // Add each part to the container
            parts.forEach((part, i) => {
                if (i % 2 === 0) {
                    // Regular text - preserve whitespace
                    if (part) {
                        const textSpan = document.createElement("span");
                        textSpan.style.whiteSpace = "pre";
                        textSpan.textContent = part;
                        container.appendChild(textSpan);
                    }
                } else {
                    // Reference - make it a button
                    const refLink = document.createElement("span");
                    refLink.className = "reference";
                    refLink.textContent = part;
                    refLink.setAttribute("tabindex", "0"); // Make focusable
                    refLink.setAttribute("role", "button");
                    refLink.setAttribute("aria-label", `Navigate to reference ${part}`);
                    
                    // Add click and keyboard handlers
                    refLink.addEventListener("click", () => handleReferenceClick(part));
                    refLink.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            handleReferenceClick(part);
                        }
                    });
                    
                    container.appendChild(refLink);
                }
            });
            
            return container;
        }

        function handleReferenceClick(refPath) {
            // Parse the reference path (e.g., "1.2.3")
            try {
                const [bankId, registerId, addressId] = refPath.split('.').map(part => parseInt(part));
                
                // Check if we need to switch banks
                if (app.currentBankId !== bankId && app.banks[bankId]) {
                    selectBank(bankId);
                    
                    // We need to give the UI time to update before trying to highlight
                    setTimeout(() => highlightReference(bankId, registerId, addressId), 100);
                } else {
                    highlightReference(bankId, registerId, addressId);
                }
                
            } catch (e) {
                showToast(`Invalid reference format: ${refPath}`);
            }
        }

        function highlightReference(bankId, registerId, addressId) {
            // Find the cell containing the reference
            const registerContainers = document.querySelectorAll('.register-container');
            
            for (const container of registerContainers) {
                const header = container.querySelector('.register-header');
                if (header && header.textContent === `Register ${registerId}`) {
                    const rows = container.querySelectorAll('tbody tr');
                    
                    for (const row of rows) {
                        const addressCell = row.querySelector('td:first-child');
                        if (addressCell && addressCell.textContent === addressId.toString()) {
                            // Highlight the row
                            row.style.backgroundColor = '#fff3cd'; // Soft yellow
                            
                            // Scroll to the row
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            
                            // Remove highlight after a delay
                            setTimeout(() => {
                                row.style.backgroundColor = '';
                            }, 2000);
                            
                            return;
                        }
                    }
                }
            }
            
            showToast(`Reference not found: Bank ${bankId}, Register ${registerId}, Address ${addressId}`);
        }

        function resolveValue(value, visited = null) {
            if (visited === null) visited = new Set();
            if (!value) return "";
            
            // Regular expression to find references
            const refRegex = /(\d+)\.(\d+)\.(\d+)/g;
            
            return value.replace(refRegex, (match, bankIdStr, registerIdStr, addressIdStr) => {
                const bankId = parseInt(bankIdStr);
                const registerId = parseInt(registerIdStr);
                const addressId = parseInt(addressIdStr);
                
                // Check for circular references
                const refKey = `${bankId}.${registerId}.${addressId}`;
                if (visited.has(refKey)) {
                    return `[Circular Ref: ${match}]`;
                }
                
                // Get referenced value
                const referencedValue = getReferencedValue(bankId, registerId, addressId);
                
                // Handle errors
                if (!referencedValue.success) {
                    return `[${referencedValue.error}]`;
                }
                
                // Check for nested references
                if (containsReferences(referencedValue.value)) {
                    const newVisited = new Set(visited);
                    newVisited.add(refKey);
                    return resolveValue(referencedValue.value, newVisited);
                }
                
                return referencedValue.value;
            });
        }

        function getReferencedValue(bankId, registerId, addressId) {
            // Check if bank exists
            if (!app.banks[bankId]) {
                return { success: false, error: `Bank ${bankId} not found` };
            }
            
            // Check if register exists
            if (!app.banks[bankId].registers[registerId]) {
                return { success: false, error: `Register ${registerId} not found in Bank ${bankId}` };
            }
            
            // Check if address exists
            if (!app.banks[bankId].registers[registerId].addresses[addressId] === undefined) {
                return { success: false, error: `Address ${addressId} not found in Bank ${bankId}, Register ${registerId}` };
            }
            
            // Return the value
            return {
                success: true,
                value: app.banks[bankId].registers[registerId].addresses[addressId] || ""
            };
        }

        // Bank editing methods
        function startEditMode(bankId) {
            app.editMode[bankId] = true;
            displayBankData(bankId);
        }

        function saveBankEdits(bankId) {
            const textEditor = document.getElementById(`textEditor_${bankId}`);
            if (!textEditor) return;
            
            const bankText = textEditor.value;
            
            try {
                // Parse the edited text
                const updatedBank = parseBankData(bankId, bankText);
                
                // Update the bank
                app.banks[bankId] = updatedBank;
                
                // Exit edit mode
                app.editMode[bankId] = false;
                
                // Refresh display
                displayBankData(bankId);
                
                showToast(`Bank ${bankId} saved successfully`);
            } catch (e) {
                showToast(`Error saving bank: ${e.message}`);
                console.error(`Error saving bank:`, e);
            }
        }

        function cancelBankEdits(bankId) {
            app.editMode[bankId] = false;
            displayBankData(bankId);
        }

        // Updated generateBankText function to support multi-line values
        function generateBankText(bank) {
            let text = "";
            
            // Sort registers by ID
            const registerIds = Object.keys(bank.registers).map(id => parseInt(id)).sort((a, b) => a - b);
            
            for (const registerId of registerIds) {
                const register = bank.registers[registerId];
                
                // Add register header
                text += `${registerId}\n`;
                
                // Sort addresses by ID
                const addressIds = Object.keys(register.addresses).map(id => parseInt(id)).sort((a, b) => a - b);
                
                // Add each address
                for (const addressId of addressIds) {
                    const value = register.addresses[addressId] || "";
                    
                    // Determine if this value should be multi-line
                    if (value.includes('\n')) {
                        text += `\t${addressId}\t"""\n`;
                        text += `${value}\n`;
                        text += `"""\n`;
                    } else {
                        text += `\t${addressId}\t${value}\n`;
                    }
                }
                
                // Add a blank line between registers
                text += "\n";
            }
            
            return text;
        }

        // New bank modal methods
        function showNewBankModal() {
            // Find next available bank ID
            const bankIds = Object.keys(app.banks).map(id => parseInt(id));
            const nextId = bankIds.length > 0 ? Math.max(...bankIds) + 1 : 1;
            
            // Set default values
            elements.bankId.value = nextId;
            elements.numRegisters.value = 3;
            elements.numAddresses.value = 5;
            
            // Show modal
            elements.newBankModal.style.display = "flex";
            
            // Focus first input
            setTimeout(() => elements.bankId.focus(), 0);
        }

        function hideNewBankModal() {
            elements.newBankModal.style.display = "none";
        }

        function createNewBank() {
            // Get values from form
            const bankId = parseInt(elements.bankId.value);
            const numRegisters = parseInt(elements.numRegisters.value);
            const numAddresses = parseInt(elements.numAddresses.value);
            
            // Validate inputs
            if (bankId < 1) {
                showToast("Bank ID must be a positive number");
                return;
            }
            
            if (numRegisters < 1 || numRegisters > app.maxRegisters) {
                showToast(`Number of registers must be between 1 and ${app.maxRegisters}`);
                return;
            }
            
            if (numAddresses < 1 || numAddresses > app.maxAddresses) {
                showToast(`Number of addresses must be between 1 and ${app.maxAddresses}`);
                return;
            }
            
            // Check if bank already exists
            if (app.banks[bankId]) {
                if (!confirm(`Bank ${bankId} already exists. Overwrite?`)) {
                    return;
                }
            }
            
            // Create empty bank
            const bank = {
                id: bankId,
                registers: {}
            };
            
            // Create registers and addresses
            for (let r = 1; r <= numRegisters; r++) {
                bank.registers[r] = {
                    addresses: {}
                };
                
                for (let a = 1; a <= numAddresses; a++) {
                    bank.registers[r].addresses[a] = `Value ${r}.${a}`;
                }
            }
            
            // Add a multi-line example in the first register
            if (numRegisters > 0 && numAddresses > 0) {
                bank.registers[1].addresses[1] = `This is a\nmulti-line\nvalue example\n  with preserved indentation`;
            }
            
            // Add to app state
            app.banks[bankId] = bank;
            
            // Create tab and select it
            createBankTab(bankId);
            selectBank(bankId);
            
            // Enter edit mode
            app.editMode[bankId] = true;
            displayBankData(bankId);
            
            // Close modal
            hideNewBankModal();
            
            showToast(`Bank ${bankId} created successfully`);
        }

        // File download method for a single bank
        function downloadBank(bankId) {
            const bank = app.banks[bankId];
            if (!bank) {
                showToast(`Bank ${bankId} not found`);
                return;
            }
            
            try {
                // Generate bank content
                const content = generateBankText(bank);
                
                // Create blob
                const blob = new Blob([content], { type: 'text/plain' });
                
                // Create download link
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${bankId}.txt`;
                link.click();
                
                showToast(`Bank ${bankId} downloaded successfully`);
            } catch (e) {
                showToast(`Error downloading bank: ${e.message}`);
                console.error(`Error downloading bank:`, e);
            }
        }

        // File download method for all banks
        function downloadAllBanks() {
            const bankIds = Object.keys(app.banks);
            if (bankIds.length === 0) {
                showToast("No banks to download");
                return;
            }
            
            setStatusMessage("Creating ZIP file...");
            
            try {
                // Create a JSZip instance
                const zip = new JSZip();
                
                // Add each bank to the zip
                for (const bankId of bankIds) {
                    const bank = app.banks[bankId];
                    const content = generateBankText(bank);
                    zip.file(`${bankId}.txt`, content);
                }
                
                // Generate zip and trigger download
                zip.generateAsync({ type: "blob" }).then(function(content) {
                    // Create download link
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = "databanks.zip";
                    link.click();
                    
                    setStatusMessage("ZIP file downloaded");
                    showToast(`${bankIds.length} banks downloaded as ZIP`);
                });
            } catch (e) {
                setStatusMessage("Error creating ZIP file");
                showToast(`Failed to create ZIP file: ${e.message}`);
                console.error("Error creating ZIP:", e);
            }
        }

        function refreshAllBanks() {
            // Refresh the current bank display if any
            if (app.currentBankId !== null) {
                displayBankData(app.currentBankId);
            }
        }

        // Utility methods
        function setStatusMessage(message) {
            elements.statusBar.textContent = message;
        }

        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.style.display = "block";
            
            // Hide toast after 3 seconds
            setTimeout(() => {
                elements.toast.style.display = "none";
            }, 3000);
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Add JSZip for ZIP file creation
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = function() {
            // Initialize application after JSZip is loaded
            initApp();
        };
        document.head.appendChild(script);
    </script>
</body>
</html>