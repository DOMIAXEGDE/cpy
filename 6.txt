1
	1	[(a(b) + c)d = (e + f + g)] xor [(a(b) + c)d ::: (e, f, g)]
	2	"""

1	o
2	v
3	(e + f)
4	(1, 2, 3 xor 5) as (origin, vector, (e + f) xor (e, f, g))
5	(e, f, g)


"""
	3	(origin, vector, (e + f + g) xor (e, f, g))
	4	h = {(6.1.1), 6.1.3}
	5	"""

1	The keyword is 'linking'. This 'h' system, is purposed to be used as an event linking algorithm (For error correction and optimization), in any context that is mathematically classifiable. Where one of many uses of the ':::' operator is to populate (e, f, g) as a three dimensional coordinate using '(a(b) + c)d', where a, b, c, d, are each different or the same, in value for each e, f, g. That is just one example use of the ':::' operator (Pronounced as shiff). Due to the purpose of the 'h' system, it is critically important that a large language is used also, for semantic reasoning purposes (Where this 'large language' is embedded into the ':::' operator). Therefore, in that light, we may view this 'h' system as a formal programming language. This is because, the 'h' system is reducible, constructable, and stackable, in any context that is mathematically classifiable.

The importance of the shiff operator is significant. This is because, it serves (Due to it also being an embedded large language), as an context escape sequence, in the case where the initial 'h' system does not hold. In this instance, it is therefore required by ':::' to execute the escape sequence by: h shiff p, where p is different system that does in fact hold. Importantly the new 'p' system would also use the ':::' operator. Hence the name given to the 'traversal' event linking algorithm is: shiff <h>

'<h>' indicates the escape sequence capability as 'h' becomes a 'traversal event linking algorithm' variable. Where the escape sequence operation by shiff is denoted as: h shiff p, meaning that shiff <h> transforms to shiff <p>.

Hence shiff <h> as h = {([(a(b) + c)d = (e + f + g)] xor [(a(b) + c)d ::: (e, f, g)]), (origin, vector, (e + f + g) xor (e, f, g))}

completes the formalism initialization of this event linking algorithm. Let us name this event linking algorithm as 'The traversal event linking algorithm: shiff <h>'.


"""
	6	"""

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Traversal Event Linking Algorithm: shiff &lt;h&gt;</title>
    <style>
        :root {
            --primary: #0a192f;
            --secondary: #172a45;
            --accent: #64ffda;
            --text: #e6f1ff;
            --highlight: #ff5e62;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: var(--primary);
            color: var(--text);
            line-height: 1.7;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem;
            background: var(--secondary);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent 49%, var(--accent) 50%, transparent 51%);
            background-size: 10px 10px;
            opacity: 0.1;
            z-index: 0;
            animation: shiftBackground 20s linear infinite;
        }
        
        @keyframes shiftBackground {
            0% { background-position: 0 0; }
            100% { background-position: 100px 100px; }
        }
        
        h1, h2, h3 {
            font-family: 'Arial', sans-serif;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 1.5rem;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1rem;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-top: 3rem;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 0.5rem;
        }
        
        h3 {
            font-size: 1.3rem;
            margin-top: 2rem;
        }
        
        p {
            margin-bottom: 1.5rem;
            text-align: justify;
            position: relative;
            z-index: 1;
        }
        
        .highlight {
            color: var(--highlight);
            font-weight: bold;
        }
        
        .operator {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background-color: rgba(100, 255, 218, 0.2);
            border-radius: 4px;
            font-weight: bold;
            margin: 0 2px;
        }
        
        .formula-container {
            background-color: var(--secondary);
            padding: 2rem;
            border-radius: 8px;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
            perspective: 1000px;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s;
            padding: 1rem;
            border: 1px solid var(--accent);
            border-radius: 4px;
            cursor: pointer;
        }
        
        .formula:hover {
            transform: translateZ(20px);
            box-shadow: 0 0 20px var(--accent);
        }
        
        .section {
            margin: 4rem 0;
            background-color: rgba(23, 42, 69, 0.5);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            transform: translateY(0);
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }
        
        .interactive-demo {
            padding: 2rem;
            background-color: var(--secondary);
            border-radius: 8px;
            margin: 2rem 0;
            position: relative;
        }
        
        .demo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
        }
        
        .demo-system {
            width: 80%;
            padding: 1.5rem;
            background-color: var(--primary);
            border: 2px solid var(--accent);
            border-radius: 8px;
            text-align: center;
            position: relative;
            transition: all 0.5s;
        }
        
        .demo-system h3 {
            margin-top: 0;
        }
        
        .arrow {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-size: 2rem;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s;
        }
        
        .trajectory-path {
            position: relative;
            width: 100%;
            height: 50px;
            margin: 1rem 0;
        }
        
        .trajectory-path::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 0;
            height: 2px;
            background-color: var(--accent);
            transition: width 1.5s ease-in-out;
        }
        
        .active-path::after {
            width: 100%;
        }
        
        .button {
            padding: 0.8rem 1.5rem;
            background-color: var(--accent);
            color: var(--primary);
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 2rem;
            transition: all 0.3s;
        }
        
        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent);
        }
        
        .applications {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .application-card {
            background-color: var(--secondary);
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
            transition: all 0.3s;
        }
        
        .application-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.4rem;
            }
            
            h3 {
                font-size: 1.1rem;
            }
            
            .formula {
                font-size: 0.9rem;
                overflow-x: auto;
                white-space: nowrap;
            }
            
            .container {
                padding: 1rem;
            }
            
            .section {
                padding: 1.5rem;
            }
        }
        
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .particle {
            position: absolute;
            background-color: var(--accent);
            border-radius: 50%;
            opacity: 0.3;
            animation: float 15s infinite ease-in-out;
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0) translateX(0);
            }
            25% {
                transform: translateY(-20px) translateX(10px);
            }
            50% {
                transform: translateY(-10px) translateX(20px);
            }
            75% {
                transform: translateY(10px) translateX(-10px);
            }
        }
    </style>
</head>
<body>
    <div class="floating-particles" id="particles"></div>

    <div class="container">
        <header>
            <h1>The Traversal Event Linking Algorithm: shiff &lt;h&gt;</h1>
            <p>A revolutionary framework for mathematical context traversal and semantic reasoning</p>
        </header>

        <section class="section">
            <h2>System Overview</h2>
            <p>The <span class="highlight">'h' system</span> is a sophisticated event linking algorithm designed for error correction and optimization across any mathematically classifiable context. Its power lies in its ability to seamlessly traverse between different mathematical frameworks while maintaining computational coherence.</p>
            
            <div class="formula-container">
                <div class="formula" id="formula">
                    shiff &lt;h&gt as h = {([(a(b) + c)d = (e + f + g)] xor [(a(b) + c)d ::: (e, f, g)]), (origin, vector, (e + f + g) xor (e, f, g))}
                </div>
            </div>
            
            <p>This formalism establishes a meta-system with three fundamental properties:</p>
            <ul style="list-style-type: none; margin-left: 2rem;">
                <li>ðŸ”¹ <span class="highlight">Reducibility:</span> Components can be simplified to fundamental elements</li>
                <li>ðŸ”¹ <span class="highlight">Constructability:</span> Complex structures can be built from simpler elements</li>
                <li>ðŸ”¹ <span class="highlight">Stackability:</span> Operations can be composed and nested hierarchically</li>
            </ul>
        </section>

        <section class="section">
            <h2>The Shiff Operator <span class="operator">:::</span></h2>
            <p>At the heart of this system is the <span class="highlight">shiff operator</span> (pronounced "shiff" and denoted as <span class="operator">:::</span>), which serves dual critical functions:</p>
            
            <div class="applications">
                <div class="application-card">
                    <h3>Coordinate Mapping</h3>
                    <p>Populates (e, f, g) as three-dimensional coordinates using (a(b) + c)d, where a, b, c, d can be identical or different in value for each coordinate.</p>
                </div>
                
                <div class="application-card">
                    <h3>Context Escape Mechanism</h3>
                    <p>Facilitates system traversal through "h shiff p" operations, enabling the algorithm to transcend formal boundaries when necessary.</p>
                </div>
            </div>
            
            <p>The shiff operator incorporates an embedded large language model for semantic reasoning, allowing it to interpret mathematical statements contextually and facilitate natural language transformations of formal structures.</p>
        </section>

        <section class="section">
            <h2>Traversal Mechanics</h2>
            <p>When represented as <span class="highlight">shiff &lt;h&gt;</span>, the algorithm encapsulates h as a variable parameter rather than a fixed system. This enables:</p>
            
            <div class="interactive-demo">
                <h3>Interactive Traversal Demonstration</h3>
                <div class="demo-container">
                    <div class="demo-system" id="system-h">
                        <h3>System h</h3>
                        <p>Current framework where constraints are applied and operations are performed</p>
                    </div>
                    
                    <div class="trajectory-path" id="path"></div>
                    
                    <div class="demo-system" id="system-p" style="opacity: 0.3;">
                        <h3>System p</h3>
                        <p>Alternative framework with different mathematical constraints</p>
                    </div>
                </div>
                
                <button class="button" id="traverse-btn">Execute Traversal: h shiff p</button>
            </div>
            
            <p>This traversal capability makes "shiff &lt;h&gt;" uniquely powerful for complex problems requiring different mathematical approaches at different solution stages.</p>
        </section>

        <section class="section">
            <h2>Applications</h2>
            <p>The traversal event linking algorithm has profound applications across multiple domains:</p>
            
            <div class="applications">
                <div class="application-card">
                    <h3>Scientific Simulation</h3>
                    <p>Maps causal relationships between events in complex systems with automatic framework selection.</p>
                </div>
                
                <div class="application-card">
                    <h3>Error-Correcting Networks</h3>
                    <p>Creates self-healing computational systems that can traverse to alternative frameworks when errors occur.</p>
                </div>
                
                <div class="application-card">
                    <h3>Optimization Problems</h3>
                    <p>Finds optimal paths through multidimensional solution spaces by traversing between appropriate mathematical contexts.</p>
                </div>
                
                <div class="application-card">
                    <h3>Knowledge Representation</h3>
                    <p>Builds flexible ontologies that adapt to context through semantic reasoning capabilities.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Significance</h2>
            <p>The traversal event linking algorithm represents a paradigm shift in mathematical computing by:</p>
            
            <ul style="list-style-type: none; margin-left: 2rem;">
                <li>ðŸ”¹ Eliminating traditional boundaries between formal systems</li>
                <li>ðŸ”¹ Integrating semantic reasoning with rigorous mathematical formalism</li>
                <li>ðŸ”¹ Enabling self-adaptive computation across domain boundaries</li>
                <li>ðŸ”¹ Creating a meta-algorithmic approach to problem-solving</li>
            </ul>
            
            <p>Through its unique combination of formal rigor and semantic flexibility, "shiff &lt;h&gt;" provides a universal framework for mathematical traversal that transcends the limitations of traditional computational approaches.</p>
        </section>
    </div>

    <script>
        // Create floating particles
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // Random size between 3px and 8px
                const size = Math.random() * 5 + 3;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Random position
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                // Random animation duration and delay
                const duration = Math.random() * 10 + 10;
                const delay = Math.random() * 5;
                particle.style.animationDuration = `${duration}s`;
                particle.style.animationDelay = `${delay}s`;
                
                particlesContainer.appendChild(particle);
            }
        }
        
        // Formula 3D effect
        function initFormula() {
            const formula = document.getElementById('formula');
            
            formula.addEventListener('mousemove', (e) => {
                const rect = formula.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                const rotateY = (x - centerX) / 20;
                const rotateX = (centerY - y) / 10;
                
                formula.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(20px)`;
            });
            
            formula.addEventListener('mouseleave', () => {
                formula.style.transform = 'rotateX(0) rotateY(0) translateZ(0)';
            });
        }
        
        // Traversal demonstration
        function initTraversal() {
            const traverseBtn = document.getElementById('traverse-btn');
            const systemH = document.getElementById('system-h');
            const systemP = document.getElementById('system-p');
            const path = document.getElementById('path');
            
            traverseBtn.addEventListener('click', () => {
                // Animate the traversal
                path.classList.add('active-path');
                
                setTimeout(() => {
                    systemH.style.opacity = '0.3';
                    systemP.style.opacity = '1';
                    systemP.style.borderColor = '#ff5e62';
                    traverseBtn.textContent = 'Traversal Complete: shiff <p>';
                    traverseBtn.disabled = true;
                }, 1500);
            });
        }
        
        // Initialize everything when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            createParticles();
            initFormula();
            initTraversal();
        });
    </script>
</body>
</html>


"""
	7	"""

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

/*
COMBINATION GENERATOR
COMPILATION AND EXECUTION

# Compilation and Execution Instructions

## Prerequisites
- A C compiler (GCC, Clang, or Microsoft Visual C++)
- Basic command-line knowledge

## Compilation Instructions

### On Linux/macOS:
1. Save the code to a file, for example `combination_generator.c`
2. Open a terminal window
3. Navigate to the directory containing the file
4. Compile the code with gcc:

```bash
gcc -o combination_generator combination_generator.c -lm
```

Note: The `-lm` flag is necessary to link the math library (for the `pow()` function).

### On Windows:
1. Save the code to a file, for example `combination_generator.c`
2. If using MinGW:
   ```bash
   gcc -o combination_generator.exe combination_generator.c -lm
   ```
3. If using Microsoft Visual C++ (from Developer Command Prompt):
   ```bash
   cl combination_generator.c
   ```

## Execution Instructions

### On Linux/macOS:
Run the program with:
```bash
./combination_generator <max_length> <output_filename.txt>
```

Example:
```bash
./combination_generator 3 output.txt
```

### On Windows:
Run the program with:
```bash
combination_generator.exe <max_length> <output_filename.txt>
```

Example:
```bash
combination_generator.exe 3 output.txt
```

## Expected Interaction

1. The program will ask you to enter the number of characters in your set:
   ```
   Enter the number of characters in your set:
   ```
   Enter a positive number (e.g., 4) and press Enter.

2. Then, it will prompt you to enter each character one by one:
   ```
   Enter each character one by one:
   Character 1:
   ```
   Type the character and press Enter. Repeat for each character.

3. The program will confirm your character set:
   ```
   Your character set: a b c d
   ```

4. If successful, the program will create a 'generated' directory (if it doesn't exist) and output a message:
   ```
   Combinations successfully written to generated/output.txt
   ```

5. The output file will contain all combinations of the specified characters, from length 1 up to the max length specified.

## Troubleshooting

- If you get errors about the math library, make sure you've included the `-lm` flag during compilation.
- If the program fails to create the 'generated' directory, check if you have write permissions for the current directory.
- If the input prompts behave unexpectedly, try adding extra `getchar()` calls or modify the input handling logic.


*/

// Function to ensure the directory exists
void ensure_directory_exists(const char* dir) {
    #ifdef _WIN32
    mkdir(dir);
    #else
    mkdir(dir, 0777);
    #endif
}

// Function to generate combinations
void generate_combinations(int max_length, char* filename, char a[], int char_set_size) {
    // Create 'generated' directory if it doesn't exist
    ensure_directory_exists("generated");
    
    // Create full path for the output file
    char filepath[512];
    sprintf(filepath, "generated/%s", filename);
    
    // Open the file for writing
    FILE *p = fopen(filepath, "w");
    if (!p) {
        printf("Error: Could not open file %s for writing.\n", filepath);
        return;
    }
    
    // Generate combinations from length 1 to max_length
    for (int n = 1; n <= max_length; n++) {
        int total_combinations = pow(char_set_size, n);
        
        for (int i = 0; i < total_combinations; i++) {
            int temp = i;
            // Generate each combination
            for (int j = n - 1; j >= 0; j--) {
                int divisor = pow(char_set_size, j);
                int index = temp / divisor;
                fprintf(p, "%c", a[index]);
                temp = temp % divisor;
            }
            fprintf(p, " ");
        }
    }
    
    fclose(p);
    printf("Combinations successfully written to %s\n", filepath);
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <max combination length> <output filename>\n", argv[0]);
        return 1;
    }

    int max_length = atoi(argv[1]);
    char* filename = argv[2];
    
    // Let user specify the characters
    printf("Enter the number of characters in your set: ");
    int char_set_size;
    scanf("%d", &char_set_size);
    
    // Validate input
    if (char_set_size <= 0) {
        printf("Error: Character set size must be positive.\n");
        return 1;
    }
    
    // Allocate memory for the character set
    char* a = (char*)malloc(char_set_size * sizeof(char));
    if (!a) {
        printf("Error: Memory allocation failed.\n");
        return 1;
    }
    
    // Get each character from the user
    printf("Enter each character one by one:\n");
    char buffer[2]; // Buffer to hold each character input
    getchar(); // Clear the newline left by previous scanf
    
    for (int i = 0; i < char_set_size; i++) {
        printf("Character %d: ", i + 1);
        fgets(buffer, sizeof(buffer), stdin);
        a[i] = buffer[0];
        getchar(); // Clear the newline
    }
    
    // Print the character set for confirmation
    printf("Your character set: ");
    for (int i = 0; i < char_set_size; i++) {
        printf("%c ", a[i]);
    }
    printf("\n");
    
    generate_combinations(max_length, filename, a, char_set_size);
    
    // Free allocated memory
    free(a);
    
    return 0;
}


"""
	8	"""

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantMatrix Encoder/Decoder Suite</title>
    <style>
        :root {
            /* Color scheme */
            --bg-dark: #121218;
            --bg-main: #1a1a24;
            --bg-light: #222233;
            --accent-blue: #0088cc;
            --accent-purple: #6a5acd;
            --accent-green: #00cc88;
            --accent-red: #ff3366;
            --text-bright: #ffffff;
            --text-normal: #ccccdd;
            --text-dim: #9999aa;
            --border: #333344;
            --highlight: #3355bb;
            --digit-color: #33ccff;
            --keyword-color: #ff6688;
            --grid-line: #333344;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-normal);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .matrix-header {
            height: 60px;
            background-color: var(--bg-dark);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-bottom: 1px solid var(--border);
            overflow: hidden;
        }
        
        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .vline {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background-color: var(--grid-line);
        }
        
        .hline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: var(--grid-line);
        }
        
        .header-title {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 1;
        }
        
        .math-symbols {
            display: flex;
            justify-content: center;
            z-index: 1;
        }
        
        .math-symbol {
            color: var(--accent-purple);
            font-size: 16px;
            margin: 0 20px;
        }
        
        /* Main container */
        .container {
            flex: 1;
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            background-color: var(--bg-dark);
            border-bottom: 1px solid var(--border);
            margin-bottom: var(--spacing-md);
        }
        
        .tab {
            padding: var(--spacing-md) var(--spacing-lg);
            background-color: var(--bg-light);
            color: var(--text-normal);
            font-weight: bold;
            cursor: pointer;
            border: none;
            outline: none;
        }
        
        .tab.active {
            background-color: var(--accent-blue);
            color: var(--text-bright);
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            flex: 1;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        /* Binary labels */
        .binary-label {
            color: var(--text-dim);
            font-family: monospace;
            font-size: 8px;
            margin-bottom: var(--spacing-xs);
        }
        
        /* Frames */
        .frame {
            border: 1px solid var(--border);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            background-color: var(--bg-main);
            border-radius: 4px;
        }
        
        .frame-title {
            color: var(--accent-blue);
            font-weight: bold;
            margin-bottom: var(--spacing-sm);
        }

        .frame-subtitle {
            color: var(--accent-purple);
            font-weight: bold;
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-xs);
            border-bottom: 1px solid var(--border);
            padding-bottom: var(--spacing-xs);
        }
        
        /* Input controls */
        .input-row {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }
        
        .input-label {
            color: var(--text-normal);
            margin-right: var(--spacing-xs);
        }
        
        .input-field {
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text-bright);
            padding: var(--spacing-sm);
            font-family: inherit;
            border-radius: 4px;
        }
        
        .file-input {
            display: none;
        }
        
        /* Buttons */
        .btn {
            background-color: var(--accent-blue);
            color: var(--text-bright);
            border: none;
            padding: var(--spacing-sm) var(--spacing-md);
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: var(--highlight);
        }
        
        .btn-green {
            background-color: var(--accent-green);
        }
        
        .btn-green:hover {
            background-color: #00bb77;
        }
        
        .btn-purple {
            background-color: var(--accent-purple);
        }
        
        .btn-purple:hover {
            background-color: #5949b8;
        }
        
        /* Text displays */
        .text-display {
            flex: 1;
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text-bright);
            font-family: 'Consolas', monospace;
            padding: var(--spacing-md);
            overflow: auto;
            white-space: pre-wrap;
            border-radius: 4px;
            min-height: 300px;
        }
        
        .text-display-small {
            flex: 0 0 auto;
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text-bright);
            font-family: 'Consolas', monospace;
            padding: var(--spacing-md);
            overflow: auto;
            white-space: pre-wrap;
            border-radius: 4px;
            min-height: 150px;
            max-height: 200px;
            margin-bottom: var(--spacing-md);
        }
        
        /* Split view */
        .split-view {
            display: flex;
            gap: var(--spacing-md);
            flex: 1;
        }
        
        .split-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* Status bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-dark);
            padding: var(--spacing-sm) var(--spacing-md);
            border-top: 1px solid var(--border);
        }
        
        .status-message {
            color: var(--accent-green);
        }
        
        /* Progress bar */
        .progress-container {
            width: 200px;
            height: 10px;
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--accent-green);
            width: 100%;
            transition: width 0.3s;
        }
        
        /* Dialog */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: var(--bg-main);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: var(--spacing-md);
            width: 400px;
            max-width: 90%;
        }
        
        .modal-title {
            color: var(--text-bright);
            margin-bottom: var(--spacing-md);
            font-weight: bold;
        }
        
        .modal-body {
            margin-bottom: var(--spacing-md);
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--bg-main);
            color: var(--text-bright);
            padding: var(--spacing-md);
            border-radius: 4px;
            border-left: 4px solid var(--accent-green);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Syntax highlighting */
        .blue { color: var(--accent-blue); }
        .green { color: var(--accent-green); }
        .red { color: var(--accent-red); }
        .purple { color: var(--accent-purple); }
        .digit { color: var(--digit-color); }
        .keyword { color: var(--keyword-color); }
        .preprocessor { color: var(--accent-purple); }
        .comment { color: var(--text-dim); }
        .string { color: var(--accent-green); }
        .number { color: var(--digit-color); }
        
        /* Corner accent */
        .corner-accent {
            color: var(--accent-blue);
            margin-right: var(--spacing-md);
        }
        
        /* Section headers */
        .section-header {
            margin-bottom: var(--spacing-sm);
        }
        
        /* Character frequency table */
        .freq-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            background-color: var(--bg-light);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .freq-table th, 
        .freq-table td {
            padding: var(--spacing-xs) var(--spacing-sm);
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .freq-table th {
            background-color: var(--bg-dark);
            color: var(--accent-blue);
            font-weight: bold;
        }
        
        .freq-table tr:hover {
            background-color: var(--bg-dark);
        }
        
        .freq-table td.char-cell {
            font-family: 'Consolas', monospace;
            color: var(--accent-green);
        }
        
        .freq-table td.count-cell {
            font-family: 'Consolas', monospace;
            color: var(--digit-color);
            text-align: right;
        }
        
        .freq-table td.percent-cell {
            font-family: 'Consolas', monospace;
            color: var(--accent-purple);
            text-align: right;
        }
        
        /* Base conversion controls */
        .base-conversion {
            background-color: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }
        
        .base-chars {
            font-family: 'Consolas', monospace;
            letter-spacing: 1px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .split-view {
                flex-direction: column;
            }
            
            .input-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .input-row > * {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Matrix-style header -->
    <div class="matrix-header">
        <div class="grid-lines" id="grid-lines"></div>
        <div class="header-title">QUANTMATRIX ENCODER/DECODER</div>
        <div class="math-symbols">
            <span class="math-symbol">âˆ‘</span>
            <span class="math-symbol">âˆ«</span>
            <span class="math-symbol">âˆ‚</span>
            <span class="math-symbol">âˆš</span>
            <span class="math-symbol">Ï€</span>
            <span class="math-symbol">Î”</span>
            <span class="math-symbol">Î©</span>
        </div>
    </div>
    
    <!-- Main container -->
    <div class="container">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="charmap-tab">CHARACTER MAP</button>
            <button class="tab" data-tab="encode-tab">ENCODE</button>
            <button class="tab" data-tab="decode-tab">DECODE</button>
        </div>
        
        <!-- Character Map Tab -->
        <div class="tab-content active" id="charmap-tab">
            <div class="binary-label">01001010110100101010010101</div>
            
            <div class="frame">
                <div class="input-row">
                    <span class="corner-accent">â– </span>
                    <span class="input-label">CHARACTER MAP FILE NUMBER:</span>
                    <input type="text" id="charmap-file-entry" class="input-field" maxlength="20">
                    <button id="browse-charmap-btn" class="btn">BROWSE FILES</button>
                    <input type="file" id="charmap-file-input" class="file-input" accept=".txt">
                    <button id="load-charmap-btn" class="btn">LOAD MAP</button>
                </div>
            </div>
            
            <!-- Base Conversion Section -->
            <div class="frame">
                <div class="frame-title">BASE CONVERSION SETTINGS</div>
                <p class="frame-subtitle">REMAP BASE 10 INDICES TO CUSTOM BASE</p>
                
                <div class="input-row">
                    <span class="input-label">ENABLE BASE CONVERSION:</span>
                    <input type="checkbox" id="enable-base-conversion">
                </div>
                
                <div class="input-row">
                    <span class="input-label">TARGET BASE:</span>
                    <input type="number" id="target-base" class="input-field" min="2" max="36" value="16">
                    <span class="input-label">CHARACTERS:</span>
                    <input type="text" id="base-chars" class="input-field base-chars" value="0123456789ABCDEF">
                </div>
                
                <div class="input-row">
                    <button id="update-base-btn" class="btn btn-purple">UPDATE BASE SETTINGS</button>
                    <button id="reset-base-btn" class="btn">RESET TO DECIMAL</button>
                </div>
                
                <div id="base-conversion-preview" class="text-display-small">
                    Base conversion preview will appear here...
                </div>
            </div>
            
            <div class="frame">
                <div class="frame-title">CHARACTER MATRIX VISUALIZATION</div>
                <div class="text-display" id="charmap-display">
                    &lt; Character mapping will be displayed here &gt;
                    Load a character map file to begin...
                </div>
            </div>
        </div>
        
        <!-- Encode Tab -->
        <div class="tab-content" id="encode-tab">
            <div class="section-header blue">â–¶â–¶â–¶ ENCODING MATRIX â–¶â–¶â–¶</div>
            <div class="binary-label" style="text-align: right;">0x01 0x02 0x03 0x04</div>
            
            <div class="frame">
                <div class="input-row">
                    <span class="input-label">SOURCE CODE FILE:</span>
                    <input type="text" id="encode-input-entry" class="input-field" style="flex: 1;">
                    <button id="browse-encode-btn" class="btn">BROWSE</button>
                    <input type="file" id="encode-file-input" class="file-input">
                    
                    <span style="margin: 0 10px;">|</span>
                    
                    <span class="input-label">OUTPUT FILE ID:</span>
                    <input type="text" id="encode-output-entry" class="input-field" maxlength="10">
                    <button id="encode-btn" class="btn">â–¶ ENCODE</button>
                </div>
            </div>
            
            <!-- Character Frequency Report -->
            <div class="frame" id="char-freq-section" style="display: none;">
                <div class="frame-title">CHARACTER FREQUENCY REPORT</div>
                <div class="input-row">
                    <button id="copy-freq-report-btn" class="btn btn-green">COPY REPORT</button>
                    <button id="download-freq-report-btn" class="btn">DOWNLOAD REPORT</button>
                </div>
                <div class="freq-container">
                    <table class="freq-table" id="char-freq-table">
                        <thead>
                            <tr>
                                <th>Character</th>
                                <th>Index</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Frequency data will be added here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="frame" style="flex: 1; display: flex; flex-direction: column;">
                <div class="frame-title">CODE TRANSFORMATION MATRIX</div>
                <div class="split-view">
                    <div class="split-pane">
                        <div class="frame-title">SOURCE CODE</div>
                        <div class="text-display" id="encode-input-preview"></div>
                    </div>
                    <div class="split-pane">
                        <div class="frame-title">ENCODED OUTPUT</div>
                        <div class="text-display" id="encode-output-preview"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Decode Tab -->
        <div class="tab-content" id="decode-tab">
            <div class="section-header purple">â—€â—€â—€ DECODING MATRIX â—€â—€â—€</div>
            <div class="binary-label" style="text-align: right;">MATRIX TRANSLATION ACTIVE</div>
            
            <div class="frame">
                <div class="input-row">
                    <span class="input-label">ENCODED FILE ID:</span>
                    <input type="text" id="decode-input-entry" class="input-field" maxlength="20">
                    <button id="browse-decode-btn" class="btn">BROWSE</button>
                    <input type="file" id="decode-file-input" class="file-input">
                    
                    <span style="margin: 0 10px;">|</span>
                    
                    <span class="input-label">OUTPUT FILE ID:</span>
                    <input type="text" id="decode-output-entry" class="input-field" maxlength="10">
                    <button id="decode-btn" class="btn btn-purple">â—€ DECODE</button>
                </div>
            </div>
            
            <div class="frame" style="flex: 1; display: flex; flex-direction: column;">
                <div class="frame-title">REVERSE ENGINEERING MATRIX</div>
                <div class="split-view">
                    <div class="split-pane">
                        <div class="frame-title">ENCODED INPUT</div>
                        <div class="text-display" id="decode-input-preview"></div>
                    </div>
                    <div class="split-pane">
                        <div class="frame-title">DECODED SOURCE CODE</div>
                        <div class="text-display" id="decode-output-preview"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status bar -->
    <div class="status-bar">
        <div class="status-message" id="status-bar">SYSTEM READY â€¢ AWAITING OPERATION</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
    
    <!-- Dialog for messages -->
    <div class="modal" id="message-dialog">
        <div class="modal-content">
            <div class="modal-title" id="dialog-title">MESSAGE</div>
            <div class="modal-body" id="dialog-message"></div>
            <div class="modal-footer">
                <button class="btn" id="dialog-ok-btn">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Toast notification -->
    <div class="toast" id="toast-notification"></div>
    
    <script>
        /**
         * QuantMatrix Encoder/Decoder Suite - JavaScript Implementation
         * A web application for encoding and decoding text files
         * using character mapping with optional base conversion
         */
        
        // Application state
        const app = {
            // Character mapping data
            charMap: [],
            charMapSize: 0,
            isMapLoaded: false,
            
            // Base conversion settings
            useBaseConversion: false,
            targetBase: 16,
            baseChars: "0123456789ABCDEF",
            
            // Character frequency data
            charFrequency: {},
            totalCharCount: 0,
            
            // Syntax highlighting patterns
            cKeywords: [
                "int", "char", "void", "if", "else", "for", "while", "return",
                "break", "continue", "switch", "case", "default", "struct",
                "typedef", "union", "extern", "static", "const", "enum", "sizeof"
            ]
        };
        
        // Initialize the application
        function initApp() {
            // Create grid lines for the matrix header
            createGridLines();
            
            // Set up tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const tabId = tab.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Set up file browsing
            document.getElementById('browse-charmap-btn').addEventListener('click', () => {
                document.getElementById('charmap-file-input').click();
            });
            
            document.getElementById('charmap-file-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    // Extract file number if possible
                    let fileName = file.name;
                    let fileNumber = fileName.split('.')[0];
                    
                    // Check if fileNumber is numeric
                    if (/^\d+$/.test(fileNumber)) {
                        document.getElementById('charmap-file-entry').value = fileNumber;
                    } else {
                        document.getElementById('charmap-file-entry').value = file.name;
                    }
                }
            });
            
            document.getElementById('browse-encode-btn').addEventListener('click', () => {
                document.getElementById('encode-file-input').click();
            });
            
            document.getElementById('encode-file-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    document.getElementById('encode-input-entry').value = file.name;
                    
                    // Load file for preview
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        document.getElementById('encode-input-preview').textContent = content;
                        
                        // Syntax highlighting for C files
                        if (file.name.endsWith('.c') || file.name.endsWith('.h')) {
                            highlightCCode('encode-input-preview');
                        }
                        
                        setProgressValue(0.5);
                        setStatusMessage('SOURCE CODE LOADED â€¢ READY FOR ENCODING');
                    };
                    reader.readAsText(file);
                }
            });
            
            document.getElementById('browse-decode-btn').addEventListener('click', () => {
                document.getElementById('decode-file-input').click();
            });
            
            document.getElementById('decode-file-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    
                    // Extract file number if possible
                    let fileName = file.name;
                    let fileNumber = fileName.split('.')[0];
                    
                    // Check if fileNumber is numeric
                    if (/^\d+$/.test(fileNumber)) {
                        document.getElementById('decode-input-entry').value = fileNumber;
                    } else {
                        document.getElementById('decode-input-entry').value = file.name;
                    }
                    
                    // Load file for preview
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const content = event.target.result;
                        const previewElement = document.getElementById('decode-input-preview');
                        previewElement.textContent = content;
                        previewElement.innerHTML = `<span class="digit">${previewElement.innerHTML}</span>`;
                        
                        setProgressValue(0.5);
                        setStatusMessage('ENCODED FILE LOADED â€¢ READY FOR DECODING');
                    };
                    reader.readAsText(file);
                }
            });
            
            // Set up operation buttons
            document.getElementById('load-charmap-btn').addEventListener('click', loadCharMap);
            document.getElementById('encode-btn').addEventListener('click', encodeFile);
            document.getElementById('decode-btn').addEventListener('click', decodeFile);
            
            // Set up base conversion controls
            document.getElementById('update-base-btn').addEventListener('click', updateBaseSettings);
            document.getElementById('reset-base-btn').addEventListener('click', resetBaseSettings);
            
            // Set up character frequency report buttons
            document.getElementById('copy-freq-report-btn').addEventListener('click', copyFrequencyReport);
            document.getElementById('download-freq-report-btn').addEventListener('click', downloadFrequencyReport);
            
            // Set up dialog
            document.getElementById('dialog-ok-btn').addEventListener('click', () => {
                document.getElementById('message-dialog').style.display = 'none';
            });
            
            // Initialize base conversion preview
            updateBaseConversionPreview();
        }
        
        // Create grid lines for the matrix header
        function createGridLines() {
            const gridLinesContainer = document.getElementById('grid-lines');
            
            // Create vertical lines
            for (let i = 0; i < 20; i++) {
                const vline = document.createElement('div');
                vline.className = 'vline';
                vline.style.left = `${i * 55}px`;
                gridLinesContainer.appendChild(vline);
            }
            
            // Create horizontal lines
            for (let i = 0; i < 3; i++) {
                const hline = document.createElement('div');
                hline.className = 'hline';
                hline.style.top = `${i * 20}px`;
                gridLinesContainer.appendChild(hline);
            }
        }
        
        // Update base conversion settings
        function updateBaseSettings() {
            const enableCheckbox = document.getElementById('enable-base-conversion');
            const baseInput = document.getElementById('target-base');
            const charsInput = document.getElementById('base-chars');
            
            // Get values
            app.useBaseConversion = enableCheckbox.checked;
            app.targetBase = parseInt(baseInput.value, 10);
            app.baseChars = charsInput.value;
            
            // Validate base
            if (app.targetBase < 2) {
                app.targetBase = 2;
                baseInput.value = 2;
                showToast("Base must be at least 2, adjusted automatically.");
            }
            
            // Validate base chars
            if (app.baseChars.length < app.targetBase) {
                showDialog('ERROR', `You must provide at least ${app.targetBase} unique characters for base ${app.targetBase}.`);
                return;
            }
            
            // Check for duplicate characters
            const charSet = new Set(app.baseChars);
            if (charSet.size < app.targetBase) {
                showDialog('ERROR', `All characters for base ${app.targetBase} must be unique.`);
                return;
            }
            
            // Update the preview
            updateBaseConversionPreview();
            
            showToast(`Base conversion settings updated: ${app.useBaseConversion ? 'Enabled' : 'Disabled'}, Base ${app.targetBase}`);
        }
        
        // Reset base conversion settings
        function resetBaseSettings() {
            document.getElementById('enable-base-conversion').checked = false;
            document.getElementById('target-base').value = 16;
            document.getElementById('base-chars').value = "0123456789ABCDEF";
            
            app.useBaseConversion = false;
            app.targetBase = 16;
            app.baseChars = "0123456789ABCDEF";
            
            updateBaseConversionPreview();
            
            showToast("Base conversion settings reset to default (decimal)");
        }
        
        // Update base conversion preview
        function updateBaseConversionPreview() {
            const previewElement = document.getElementById('base-conversion-preview');
            
            if (!app.useBaseConversion) {
                previewElement.innerHTML = "<span class='red'>Base conversion is currently disabled.</span>\n\n" +
                                          "Encoded output will use space-delimited decimal indices (base 10).\n" +
                                          "Example: 1 2 3 4 represents indices 1, 2, 3, 4";
                return;
            }
            
            // Create a preview with sample conversions
            let preview = `<span class='green'>Base conversion is enabled: Converting to base ${app.targetBase}</span>\n\n`;
            preview += `Using characters: <span class='purple'>${app.baseChars.substring(0, app.targetBase)}</span>\n\n`;
            preview += "Example conversions:\n";
            
            // Show some example conversions
            for (let i = 1; i <= 20; i++) {
                const converted = convertToBase(i, app.targetBase, app.baseChars);
                preview += `Decimal ${i} â†’ <span class='digit'>${converted}</span>\n`;
            }
            
            previewElement.innerHTML = preview;
        }
        
        // Convert a decimal number to the target base
        function convertToBase(decimalNum, base, chars) {
            if (base === 10) return decimalNum.toString();
            
            let result = "";
            let num = decimalNum;
            
            while (num > 0) {
                result = chars[num % base] + result;
                num = Math.floor(num / base);
            }
            
            return result || chars[0]; // Return at least the zero character if number is 0
        }
        
        // Convert from custom base back to decimal
        function convertFromBase(baseNum, base, chars) {
            if (base === 10) return parseInt(baseNum, 10);
            
            let result = 0;
            let power = 1;
            
            // Process the string from right to left
            for (let i = baseNum.length - 1; i >= 0; i--) {
                const char = baseNum[i];
                const digitValue = chars.indexOf(char);
                
                if (digitValue === -1 || digitValue >= base) {
                    // Invalid character for this base
                    return NaN;
                }
                
                result += digitValue * power;
                power *= base;
            }
            
            return result;
        }
        
        // Load character map
        function loadCharMap() {
            const fileInput = document.getElementById('charmap-file-entry').value.trim();
            
            if (!fileInput) {
                showDialog('WARNING', 'Please enter a character map file number or path.');
                return;
            }
            
            // Animation effect
            setProgressValue(0);
            
            // Process file input - could be a number or a path
            let filename;
            if (/^\d+$/.test(fileInput)) {
                filename = fileInput + '.txt';
            } else {
                filename = fileInput;
            }
            
            setStatusMessage('LOADING CHARACTER MAP...');
            
            // Try to load the file from an input element if we have one
            const fileInputElement = document.getElementById('charmap-file-input');
            if (fileInputElement.files.length > 0) {
                const file = fileInputElement.files[0];
                const reader = new FileReader();
                
                reader.onload = (e) => processCharMapContent(e.target.result, filename);
                reader.onerror = () => {
                    showDialog('ERROR', 'Failed to read the character map file.');
                    setProgressValue(0);
                    setStatusMessage('ERROR: Failed to read file');
                };
                
                reader.readAsText(file);
            } else {
                // Simulate loading from the local file in our example - in a real app
                // you would fetch this from your server
                simulateFileLoad(filename);
            }
        }
        
        // Simulate loading a file (for the demo)
        function simulateFileLoad(filename) {
            // Simulate a delay
            setProgressValue(0.2);
            
            setTimeout(() => {
                // Generate a simple map for demo purposes
                const demoMap = 
                    "1\ta\n" +
                    "2\tb\n" +
                    "3\tc\n" +
                    "4\td\n" +
                    "5\te\n" +
                    "6\tf\n" +
                    "7\tg\n" +
                    "8\th\n" +
                    "9\ti\n" +
                    "10\tj\n" +
                    "11\tk\n" +
                    "12\tl\n" +
                    "13\tm\n" +
                    "14\tn\n" +
                    "15\to\n" +
                    "16\tp\n" +
                    "17\tq\n" +
                    "18\tr\n" +
                    "19\ts\n" +
                    "20\tt\n" +
                    "21\tu\n" +
                    "22\tv\n" +
                    "23\tw\n" +
                    "24\tx\n" +
                    "25\ty\n" +
                    "26\tz\n" +
                    "27\tA\n" +
                    "28\tB\n" +
                    "29\tC\n" +
                    "30\tD\n" +
                    "31\tE\n" +
                    "32\tF\n" +
                    "33\tG\n" +
                    "34\tH\n" +
                    "35\tI\n" +
                    "36\tJ\n" +
                    "37\tK\n" +
                    "38\tL\n" +
                    "39\tM\n" +
                    "40\tN\n" +
                    "41\tO\n" +
                    "42\tP\n" +
                    "43\tQ\n" +
                    "44\tR\n" +
                    "45\tS\n" +
                    "46\tT\n" +
                    "47\tU\n" +
                    "48\tV\n" +
                    "49\tW\n" +
                    "50\tX\n" +
                    "51\tY\n" +
                    "52\tZ\n" +
                    "53\t0\n" +
                    "54\t1\n" +
                    "55\t2\n" +
                    "56\t3\n" +
                    "57\t4\n" +
                    "58\t5\n" +
                    "59\t6\n" +
                    "60\t7\n" +
                    "61\t8\n" +
                    "62\t9\n" +
                    "63\t+\n" +
                    "64\t-\n" +
                    "65\t*\n" +
                    "66\t/\n" +
                    "67\t%\n" +
                    "68\t=\n" +
                    "69\t!\n" +
                    "70\t<\n" +
                    "71\t>\n" +
                    "72\t&\n" +
                    "73\t|\n" +
                    "74\t^\n" +
                    "75\t~\n" +
                    "76\t?\n" +
                    "77\t:\n" +
                    "78\t;\n" +
                    "79\t,\n" +
                    "80\t.\n" +
                    "81\t(\n" +
                    "82\t)\n" +
                    "83\t[\n" +
                    "84\t]\n" +
                    "85\t{\n" +
                    "86\t}\n" +
                    "87\t#\n" +
                    "88\t\"\n" +
                    "89\t'\n" +
                    "90\t\\\n" +
                    "91\t_\n" +
                    "92\t@\n" +
                    "93\t$\n" +
                    "94\t`\n" +
                    "95\t\\t\n" +
                    "96\tSpace\n" +
                    "97\t\\n\n" +
                    "98\t\\0\n";
                    
                processCharMapContent(demoMap, filename);
            }, 500);
        }
        
        // Process character map content
        function processCharMapContent(content, filename) {
            setProgressValue(0.4);
            
            // Reset the character map
            app.charMap = [];
            app.charMapSize = 0;
            app.isMapLoaded = false;
            
            // Buffer for the character map text display
            let charMapText = '';
            
            // Parse the content line by line
            const lines = content.split('\n');
            let lineNum = 0;
            
            for (const line of lines) {
                lineNum++;
                
                // Skip empty lines
                if (!line.trim()) continue;
                
                // Parse the line: index<tab>character
                const parts = line.split('\t');
                if (parts.length !== 2) {
                    charMapText += `WARNING: Line ${lineNum} is not in the expected format (index<tab>character), skipping\n`;
                    continue;
                }
                
                // Convert the index part to an integer
                const index = parseInt(parts[0].trim(), 10);
                if (isNaN(index)) {
                    charMapText += `WARNING: Line ${lineNum} has an invalid index, skipping\n`;
                    continue;
                }
                
                // Process the character part
                const charPart = parts[1].trim();
                
                // Ensure the array is big enough
                if (index > app.charMapSize) {
                    app.charMapSize = index;
                }
                
                // Handle special cases
                if (charPart === 'Space') {
                    app.charMap[index - 1] = ' ';
                } else if (charPart === 'Tab') {
                    app.charMap[index - 1] = '\t';
                } else if (charPart === '') {
                    // Empty character treated as space
                    app.charMap[index - 1] = ' ';
                    charMapText += `Note: Empty character at line ${lineNum} interpreted as space\n`;
                } else if (charPart.length === 1) {
                    // Regular single character
                    app.charMap[index - 1] = charPart;
                } else if (charPart.length === 2 && charPart[0] === '\\') {
                    // Escape sequences
                    let escapeChar = '';
                    
                    switch (charPart[1]) {
                        case 'n': escapeChar = '\n'; break;
                        case 't': escapeChar = '\t'; break;
                        case 'r': escapeChar = '\r'; break;
                        case '0': escapeChar = '\0'; break;
                        case '\\': escapeChar = '\\'; break;
                        case '\'': escapeChar = '\''; break;
                        case '\"': escapeChar = '\"'; break;
                        default:
                            charMapText += `WARNING: Unknown escape sequence ${charPart}, ignoring\n`;
                            continue;
                    }
                    
                    app.charMap[index - 1] = escapeChar;
                } else if (charPart.length > 0) {
                    // More complex representation - just take the first character
                    charMapText += `WARNING: Character part '${charPart}' contains multiple characters, using first one: '${charPart[0]}'\n`;
                    app.charMap[index - 1] = charPart[0];
                }
            }
            
            setProgressValue(0.6);
            
            app.isMapLoaded = true;
            charMapText += `\nâœ“ CHARACTER MAPPING LOADED SUCCESSFULLY WITH ${app.charMapSize} CHARACTERS.\n\n`;
            charMapText += "== LOADED CHARACTER MAP ==\n";
            
            // Display the character map
            for (let i = 0; i < app.charMapSize; i++) {
                if (app.charMap[i] === undefined) {
                    continue;
                }
                
                // Check if the character is printable
                const c = app.charMap[i];
                if (c !== '\t' && c !== '\n' && c !== '\r' && c !== '\0') {
                    charMapText += `MAP[${i+1}] = '${c}'\n`;
                } else {
                    let hexCode;
                    switch (c) {
                        case '\t': hexCode = '\\t'; break;
                        case '\n': hexCode = '\\n'; break;
                        case '\r': hexCode = '\\r'; break;
                        case '\0': hexCode = '\\0'; break;
                        default: hexCode = `\\x${c.charCodeAt(0).toString(16).padStart(2, '0')}`;
                    }
                    charMapText += `MAP[${i+1}] = '${hexCode}'\n`;
                }
            }
            
            setProgressValue(0.9);
            
            // Update the display
            const display = document.getElementById('charmap-display');
            display.textContent = charMapText;
            
            // Apply color tags
            applyColorTagsToCharMap();
            
            // Update status and complete progress
            setProgressValue(1.0);
            
            const statusMsg = `CHARACTER MAP LOADED FROM ${filename} â€¢ ${app.charMapSize} CHARACTERS`;
            setStatusMessage(statusMsg);
            
            showToast(`Character map loaded with ${app.charMapSize} characters`);
        }
        
        // Apply color tags to character map display
        function applyColorTagsToCharMap() {
            const display = document.getElementById('charmap-display');
            const content = display.textContent;
            
            // Apply highlighting
            let html = content.replace(/MAP\[\d+\]/g, match => `<span class="blue">${match}</span>`);
            html = html.replace(/'.*'/g, match => `<span class="green">${match}</span>`);
            html = html.replace(/WARNING:.*/g, match => `<span class="red">${match}</span>`);
            html = html.replace(/âœ“.*CHARACTERS\./g, match => `<span class="green">${match}</span>`);
            html = html.replace(/==.*==/g, match => `<span class="purple">${match}</span>`);
            
            display.innerHTML = html;
        }
        
        // Find the index of a character in the char_map array
        function findCharIndex(c) {
            for (let i = 0; i < app.charMapSize; i++) {
                if (app.charMap[i] === c) {
                    return i + 1; // +1 because our list is 1-indexed
                }
            }
            return -1; // Character not found
        }
        
        // Encode a source file with optional base conversion
        function encodeFile() {
            if (!app.isMapLoaded) {
                showDialog('WARNING', 'Please load a character map first.');
                return;
            }
            
            const inputFilename = document.getElementById('encode-input-entry').value.trim();
            const outputFileNumber = document.getElementById('encode-output-entry').value.trim();
            
            if (!inputFilename) {
                showDialog('WARNING', 'Please enter an input filename.');
                return;
            }
            
            if (!outputFileNumber) {
                showDialog('WARNING', 'Please enter an output file number.');
                return;
            }
            
            // Check if output file number is valid
            if (!/^\d+$/.test(outputFileNumber)) {
                showDialog('WARNING', 'Output file number must be a number.');
                return;
            }
            
            // Animation effect
            setProgressValue(0);
            setStatusMessage('INITIALIZING ENCODING PROCESS...');
            
            const outputFilename = `${outputFileNumber}.txt`;
            
            // Get the source content
            const sourceContent = document.getElementById('encode-input-preview').textContent;
            if (!sourceContent) {
                showDialog('ERROR', 'No source content to encode.');
                setProgressValue(0);
                setStatusMessage('ERROR: No source content');
                return;
            }
            
            setProgressValue(0.3);
            setStatusMessage('ANALYZING SOURCE CODE...');
            
            setTimeout(() => {
                setProgressValue(0.5);
                setStatusMessage('APPLYING CHARACTER MAPPING...');
                
                // Reset character frequency data
                app.charFrequency = {};
                app.totalCharCount = 0;
                
                // Buffer for encoded output
                let encodedContent = '';
                
                // Encode each character
                for (let i = 0; i < sourceContent.length; i++) {
                    const c = sourceContent[i];
                    const index = findCharIndex(c);
                    
                    if (index !== -1) {
                        // Track character frequency
                        app.charFrequency[index] = (app.charFrequency[index] || 0) + 1;
                        app.totalCharCount++;
                        
                        // Apply base conversion if enabled
                        if (app.useBaseConversion) {
                            encodedContent += convertToBase(index, app.targetBase, app.baseChars) + ' ';
                        } else {
                            encodedContent += index + ' ';
                        }
                    } else {
                        // For characters not in our mapping, use a special token or skip
                        // Here we use 0 but you could customize this behavior
                        encodedContent += (app.useBaseConversion ? app.baseChars[0] : '0') + ' ';
                    }
                }
                
                // Trim trailing spaces
                encodedContent = encodedContent.trim();
                
                setProgressValue(0.8);
                setStatusMessage('FINALIZING ENCODED OUTPUT...');
                
                // Update output preview
                const outputPreview = document.getElementById('encode-output-preview');
                outputPreview.innerHTML = `<span class="digit">${encodedContent}</span>`;
                
                // Create a download for the encoded file
                triggerDownload(encodedContent, outputFilename);
                
                // Show character frequency report
                generateCharFrequencyReport();
                
                setProgressValue(1.0);
                const statusMsg = `ENCODING COMPLETE: ${inputFilename} â†’ ${outputFilename}`;
                setStatusMessage(statusMsg);
                
                showToast(`File encoded and downloaded as ${outputFilename}`);
            }, 800);
        }
        
        // Generate character frequency report
        function generateCharFrequencyReport() {
            // Sort characters by frequency (descending)
            const sortedFreq = Object.entries(app.charFrequency)
                .sort((a, b) => b[1] - a[1])
                .map(([index, count]) => ({
                    index: parseInt(index, 10),
                    char: app.charMap[parseInt(index, 10) - 1],
                    count,
                    percent: (count / app.totalCharCount * 100).toFixed(2)
                }));
            
            // Generate the HTML table
            const tableBody = document.getElementById('char-freq-table').querySelector('tbody');
            tableBody.innerHTML = '';
            
            for (const item of sortedFreq) {
                const row = document.createElement('tr');
                
                // Character cell
                const charCell = document.createElement('td');
                charCell.className = 'char-cell';
                
                // Handle special characters
                if (item.char === '\n') {
                    charCell.textContent = '\\n';
                } else if (item.char === '\t') {
                    charCell.textContent = '\\t';
                } else if (item.char === '\r') {
                    charCell.textContent = '\\r';
                } else if (item.char === '\0') {
                    charCell.textContent = '\\0';
                } else if (item.char === ' ') {
                    charCell.textContent = 'âŽµ'; // Space symbol
                } else {
                    charCell.textContent = item.char;
                }
                
                // Index cell
                const indexCell = document.createElement('td');
                if (app.useBaseConversion) {
                    indexCell.innerHTML = `${item.index} <span class="purple">(${convertToBase(item.index, app.targetBase, app.baseChars)})</span>`;
                } else {
                    indexCell.textContent = item.index;
                }
                
                // Count cell
                const countCell = document.createElement('td');
                countCell.className = 'count-cell';
                countCell.textContent = item.count;
                
                // Percent cell
                const percentCell = document.createElement('td');
                percentCell.className = 'percent-cell';
                percentCell.textContent = item.percent + '%';
                
                row.appendChild(charCell);
                row.appendChild(indexCell);
                row.appendChild(countCell);
                row.appendChild(percentCell);
                
                tableBody.appendChild(row);
            }
            
            // Show the report section
            document.getElementById('char-freq-section').style.display = 'block';
        }
        
        // Copy frequency report to clipboard
        function copyFrequencyReport() {
            // Create a text representation of the frequency report
            const sortedFreq = Object.entries(app.charFrequency)
                .sort((a, b) => b[1] - a[1])
                .map(([index, count]) => ({
                    index: parseInt(index, 10),
                    char: app.charMap[parseInt(index, 10) - 1],
                    count,
                    percent: (count / app.totalCharCount * 100).toFixed(2)
                }));
            
            let reportText = "CHARACTER FREQUENCY REPORT\n";
            reportText += "==========================\n\n";
            reportText += "Total characters: " + app.totalCharCount + "\n\n";
            reportText += "Character | Index";
            
            if (app.useBaseConversion) {
                reportText += ` | Base ${app.targetBase}`;
            }
            
            reportText += " | Count | Percentage\n";
            reportText += "-".repeat(50) + "\n";
            
            for (const item of sortedFreq) {
                // Handle special characters
                let charDisplay;
                if (item.char === '\n') charDisplay = '\\n';
                else if (item.char === '\t') charDisplay = '\\t';
                else if (item.char === '\r') charDisplay = '\\r';
                else if (item.char === '\0') charDisplay = '\\0';
                else if (item.char === ' ') charDisplay = 'âŽµ';
                else charDisplay = item.char;
                
                reportText += `${charDisplay.padEnd(9)} | ${item.index.toString().padEnd(5)}`;
                
                if (app.useBaseConversion) {
                    reportText += ` | ${convertToBase(item.index, app.targetBase, app.baseChars).padEnd(8)}`;
                }
                
                reportText += ` | ${item.count.toString().padEnd(5)} | ${item.percent}%\n`;
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(reportText).then(() => {
                showToast('Frequency report copied to clipboard');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showToast('Failed to copy report to clipboard');
            });
        }
        
        // Download frequency report
        function downloadFrequencyReport() {
            // Create a text representation of the frequency report (same as copy function)
            const sortedFreq = Object.entries(app.charFrequency)
                .sort((a, b) => b[1] - a[1])
                .map(([index, count]) => ({
                    index: parseInt(index, 10),
                    char: app.charMap[parseInt(index, 10) - 1],
                    count,
                    percent: (count / app.totalCharCount * 100).toFixed(2)
                }));
            
            let reportText = "CHARACTER FREQUENCY REPORT\n";
            reportText += "==========================\n\n";
            reportText += "Total characters: " + app.totalCharCount + "\n\n";
            reportText += "Character | Index";
            
            if (app.useBaseConversion) {
                reportText += ` | Base ${app.targetBase}`;
            }
            
            reportText += " | Count | Percentage\n";
            reportText += "-".repeat(50) + "\n";
            
            for (const item of sortedFreq) {
                // Handle special characters
                let charDisplay;
                if (item.char === '\n') charDisplay = '\\n';
                else if (item.char === '\t') charDisplay = '\\t';
                else if (item.char === '\r') charDisplay = '\\r';
                else if (item.char === '\0') charDisplay = '\\0';
                else if (item.char === ' ') charDisplay = 'âŽµ';
                else charDisplay = item.char;
                
                reportText += `${charDisplay.padEnd(9)} | ${item.index.toString().padEnd(5)}`;
                
                if (app.useBaseConversion) {
                    reportText += ` | ${convertToBase(item.index, app.targetBase, app.baseChars).padEnd(8)}`;
                }
                
                reportText += ` | ${item.count.toString().padEnd(5)} | ${item.percent}%\n`;
            }
            
            // Trigger download
            const blob = new Blob([reportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'frequency_report.txt';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            showToast('Frequency report downloaded');
        }
        
        // Decode a file with optional base conversion
        function decodeFile() {
            if (!app.isMapLoaded) {
                showDialog('WARNING', 'Please load a character map first.');
                return;
            }
            
            const inputFileNumber = document.getElementById('decode-input-entry').value.trim();
            const outputFileNumber = document.getElementById('decode-output-entry').value.trim();
            
            if (!inputFileNumber) {
                showDialog('WARNING', 'Please enter an input file number.');
                return;
            }
            
            if (!outputFileNumber) {
                showDialog('WARNING', 'Please enter an output file number.');
                return;
            }
            
            // Animation effect
            setProgressValue(0);
            setStatusMessage('INITIALIZING DECODING PROCESS...');
            
            // Determine input filename
            let inputFilename;
            if (/^\d+$/.test(inputFileNumber)) {
                inputFilename = `${inputFileNumber}.txt`;
            } else {
                inputFilename = inputFileNumber;
            }
            
            const outputFilename = `${outputFileNumber}.txt`;
            
            // Get the encoded content
            const encodedContent = document.getElementById('decode-input-preview').textContent;
            if (!encodedContent) {
                showDialog('ERROR', 'No encoded content to decode.');
                setProgressValue(0);
                setStatusMessage('ERROR: No encoded content');
                return;
            }
            
            setProgressValue(0.4);
            setStatusMessage('REVERSING CHARACTER MAPPING...');
            
            setTimeout(() => {
                setProgressValue(0.6);
                setStatusMessage('GENERATING SOURCE CODE...');
                
                // Clean up the content - normalize whitespace and trim
                const cleanContent = encodedContent.replace(/\s+/g, ' ').trim();
                
                // Split by space to get all indices or base-converted values
                const encodedIndices = cleanContent.split(' ').filter(str => str.length > 0);
                
                // Buffer for decoded output
                let decodedContent = '';
                
                // Process each index
                for (const encodedIndex of encodedIndices) {
                    let charIndex;
                    
                    // Convert from the custom base if needed
                    if (app.useBaseConversion) {
                        charIndex = convertFromBase(encodedIndex, app.targetBase, app.baseChars);
                    } else {
                        charIndex = parseInt(encodedIndex, 10);
                    }
                    
                    // Only add valid characters
                    if (!isNaN(charIndex) && charIndex > 0 && charIndex <= app.charMapSize && app.charMap[charIndex - 1] !== undefined) {
                        decodedContent += app.charMap[charIndex - 1];
                    }
                    // Skip unmapped characters
                }
                
                setProgressValue(0.8);
                setStatusMessage('FINALIZING DECODED OUTPUT...');
                
                // Update output preview
                const outputPreview = document.getElementById('decode-output-preview');
                outputPreview.textContent = decodedContent;
                
                // Apply syntax highlighting if it looks like C code
                if (decodedContent.includes('#include') || 
                    decodedContent.includes('int ') || 
                    decodedContent.includes('void ')) {
                    highlightCCode('decode-output-preview');
                }
                
                // Create a download for the decoded file
                triggerDownload(decodedContent, outputFilename);
                
                setProgressValue(1.0);
                const statusMsg = `DECODING COMPLETE: ${inputFilename} â†’ ${outputFilename}`;
                setStatusMessage(statusMsg);
                
                showToast(`File decoded and downloaded as ${outputFilename}`);
            }, 800);
        }
        
        // Trigger file download
        function triggerDownload(content, filename) {
            // Create a blob and download link
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = filename;
            downloadLink.style.display = 'none';
            
            // Add to document, trigger click, then remove
            document.body.appendChild(downloadLink);
            downloadLink.click();
            
            // Clean up after a short delay
            setTimeout(() => {
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Highlight C syntax in a text element
        function highlightCCode(elementId) {
            const element = document.getElementById(elementId);
            let content = element.textContent;
            
            // Create a temporary div to work with HTML
            const tempDiv = document.createElement('div');
            
            // Escape HTML
            tempDiv.textContent = content;
            content = tempDiv.innerHTML;
            
            // Highlight keywords
            for (const keyword of app.cKeywords) {
                const regex = new RegExp(`\\b${keyword}\\b`, 'g');
                content = content.replace(regex, `<span class="keyword">${keyword}</span>`);
            }
            
            // Highlight preprocessor directives
            content = content.replace(/(^|\n)(\s*#\s*\w+.*)/g, '$1<span class="preprocessor">$2</span>');
            
            // Highlight comments
            content = content.replace(/\/\/.*?(\n|$)/g, '<span class="comment">$&</span>');
            content = content.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            // Highlight strings
            content = content.replace(/".*?"/g, '<span class="string">$&</span>');
            content = content.replace(/'.*?'/g, '<span class="string">$&</span>');
            
            // Highlight numbers
            content = content.replace(/\b(\d+)\b/g, '<span class="number">$1</span>');
            
            element.innerHTML = content;
        }
        
        // Set the status message
        function setStatusMessage(message) {
            document.getElementById('status-bar').textContent = message;
        }
        
        // Set the progress bar value
        function setProgressValue(progress) {
            document.getElementById('progress-bar').style.width = `${progress * 100}%`;
        }
        
        // Show a message dialog
        function showDialog(title, message) {
            document.getElementById('dialog-title').textContent = title;
            document.getElementById('dialog-message').textContent = message;
            document.getElementById('message-dialog').style.display = 'flex';
        }
        
        // Show a toast notification
        function showToast(message) {
            const toast = document.getElementById('toast-notification');
            toast.textContent = message;
            toast.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Initialize everything when the page loads
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>


"""
	9	"""

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Bank Manager</title>
    <link rel="stylesheet" href="algorithm-themes.css">
</head>
<body>

    <!-- Theme Selector -->
    <div class="theme-selector">
        <label for="themeSelect">Theme:</label>
        <select id="themeSelect">
            <option value="default">Default</option>
            <option value="cpp">C++ Developer</option>
            <option value="dark">Dark Mode</option>
            <option value="light">Light Mode</option>
        </select>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Header -->
        <header>
            <h1>DATA BANK MANAGER</h1>
            <p>Manage and query multi-level reference data files</p>
        </header>

        <!-- Main scrollable content area -->
        <div class="main-content">
            <!-- Bank Configuration Section -->
            <section class="config-section">
                <h2>BANK CONFIGURATION</h2>
                <div class="config-grid">
                    <div class="config-item">
                        <label for="maxRegisters">Max Registers Per Bank</label>
                        <input type="number" id="maxRegisters" min="1" max="100" value="10">
                    </div>
                    <div class="config-item">
                        <label for="maxAddresses">Max Addresses Per Register</label>
                        <input type="number" id="maxAddresses" min="1" max="100" value="20">
                    </div>
                    <div class="config-item">
                        <label for="readingMode">Reading Mode</label>
                        <select id="readingMode">
                            <option value="raw">raw</option>
                            <option value="resolve">resolve</option>
                        </select>
                    </div>
                </div>
                <div class="file-actions">
                    <label>Bank Files</label>
                    <button id="uploadButton" tabindex="0" aria-label="Upload bank files">UPLOAD FILES</button>
                    <button id="createNewButton" tabindex="0" aria-label="Create a new bank">CREATE NEW BANK</button>
                    <button id="downloadAllButton" tabindex="0" aria-label="Download all banks as a ZIP file">DOWNLOAD ALL</button>
                    <input type="file" id="fileUpload" multiple accept=".txt" style="display: none;">
                </div>
            </section>

            <!-- Data Banks Section -->
            <section class="banks-section">
                <h2>DATA BANKS</h2>
                <div class="tab-container" id="bankTabs" role="tablist">
                    <div class="tab" id="addBankTab" role="tab" tabindex="0" aria-selected="false" aria-label="Add a new bank">+ Add</div>
                </div>
                <div class="tab-contents" id="bankContents">
                    <!-- Bank content will be dynamically added here -->
                </div>
            </section>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="statusBar" aria-live="polite">READY</div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast" role="alert" aria-live="assertive"></div>

    <!-- New Bank Modal -->
    <div class="modal-overlay" id="newBankModal" role="dialog" aria-labelledby="newBankTitle" aria-modal="true">
        <div class="modal">
            <div class="modal-title" id="newBankTitle">Create New Bank</div>
            <div class="form-row">
                <label for="bankId">Bank ID Number</label>
                <input type="number" id="bankId" min="1" value="1" aria-required="true">
            </div>
            <div class="form-row">
                <label for="numRegisters">Number of Registers</label>
                <input type="number" id="numRegisters" min="1" value="3" aria-required="true">
            </div>
            <div class="form-row">
                <label for="numAddresses">Addresses Per Register</label>
                <input type="number" id="numAddresses" min="1" value="5" aria-required="true">
            </div>
            <div class="modal-buttons">
                <button id="cancelNewBank" tabindex="0">Cancel</button>
                <button id="createBank" tabindex="0">Create</button>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const app = {
            maxRegisters: 10,
            maxAddresses: 20,
            readingMode: "raw",
            banks: {},
            currentBankId: null,
            editMode: {},
            currentTheme: "default", // Default theme
            undoHistory: {},         // Store previous bank states for undo
            searchTerm: "",          // For search functionality
            filterMode: "all"        // For filtering displays
        };

        // DOM Elements
        const elements = {
            maxRegisters: document.getElementById("maxRegisters"),
            maxAddresses: document.getElementById("maxAddresses"),
            readingMode: document.getElementById("readingMode"),
            uploadButton: document.getElementById("uploadButton"),
            fileUpload: document.getElementById("fileUpload"),
            createNewButton: document.getElementById("createNewButton"),
            downloadAllButton: document.getElementById("downloadAllButton"),
            bankTabs: document.getElementById("bankTabs"),
            bankContents: document.getElementById("bankContents"),
            statusBar: document.getElementById("statusBar"),
            toast: document.getElementById("toast"),
            newBankModal: document.getElementById("newBankModal"),
            bankId: document.getElementById("bankId"),
            numRegisters: document.getElementById("numRegisters"),
            numAddresses: document.getElementById("numAddresses"),
            cancelNewBank: document.getElementById("cancelNewBank"),
            createBank: document.getElementById("createBank"),
            addBankTab: document.getElementById("addBankTab"),
            themeSelect: document.getElementById("themeSelect")
        };

        // Initialize application
        function initApp() {
            // Set up event listeners
            elements.maxRegisters.addEventListener("change", updateConfig);
            elements.maxAddresses.addEventListener("change", updateConfig);
            elements.readingMode.addEventListener("change", updateReadingMode);
            elements.uploadButton.addEventListener("click", () => elements.fileUpload.click());
            elements.fileUpload.addEventListener("change", handleFileUpload);
            elements.createNewButton.addEventListener("click", showNewBankModal);
            elements.downloadAllButton.addEventListener("click", downloadAllBanks);
            elements.addBankTab.addEventListener("click", showNewBankModal);
            elements.cancelNewBank.addEventListener("click", hideNewBankModal);
            elements.createBank.addEventListener("click", createNewBank);
            elements.themeSelect.addEventListener("change", changeTheme);

            // Add keyboard accessibility
            setupKeyboardShortcuts();

            // Add keyboard accessibility for tabs
            elements.addBankTab.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    showNewBankModal();
                }
            });

            // Add modal handling for escape key
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && elements.newBankModal.style.display === "flex") {
                    hideNewBankModal();
                }
            });

            // Load config from storage
            loadConfigFromStorage();

            // Apply saved theme
            loadThemeFromStorage();

            // Add welcome message
            showWelcomeMessage();
        }

        // Show welcome message for first-time users
        function showWelcomeMessage() {
            if (!localStorage.getItem("dataBankWelcomed")) {
                // Create a friendly welcome message
                const welcomeHtml = `
                    <div style="margin-bottom: 10px"><strong>Welcome to Data Bank Manager!</strong></div>
                    <div>Get started by:</div>
                    <div>â€¢ Uploading existing bank files</div>
                    <div>â€¢ Creating a new bank with the "CREATE NEW BANK" button</div>
                    <div style="margin-top: 10px">Press ESC to close this message</div>
                `;
                
                // Show in the toast with extended duration
                elements.toast.innerHTML = welcomeHtml;
                elements.toast.style.display = "block";
                elements.toast.classList.add("extended");
                
                // Add click to dismiss
                elements.toast.addEventListener("click", dismissWelcome);
                
                // Add key to dismiss
                document.addEventListener("keydown", dismissWelcomeOnEsc);
                
                // Mark as welcomed
                localStorage.setItem("dataBankWelcomed", "true");
                
                function dismissWelcome() {
                    elements.toast.style.display = "none";
                    elements.toast.classList.remove("extended");
                    elements.toast.removeEventListener("click", dismissWelcome);
                    document.removeEventListener("keydown", dismissWelcomeOnEsc);
                }
                
                function dismissWelcomeOnEsc(e) {
                    if (e.key === "Escape") {
                        dismissWelcome();
                    }
                }
            }
        }

        // Setup keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener("keydown", (e) => {
                // Only handle shortcut if not in an input field
                if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.tagName === "SELECT") {
                    return;
                }
                
                // Check for modifier key (Ctrl or Command)
                const modifierKey = e.ctrlKey || e.metaKey;
                
                // Ctrl+S or Command+S to save current bank
                if (modifierKey && e.key === "s" && app.currentBankId && app.editMode[app.currentBankId]) {
                    e.preventDefault();
                    saveBankEdits(app.currentBankId);
                }
                
                // Ctrl+Z or Command+Z to undo in edit mode
                if (modifierKey && e.key === "z" && app.currentBankId && app.editMode[app.currentBankId]) {
                    e.preventDefault();
                    undoEdit(app.currentBankId);
                }
                
                // Ctrl+N or Command+N to create new bank
                if (modifierKey && e.key === "n") {
                    e.preventDefault();
                    showNewBankModal();
                }
                
                // Ctrl+D or Command+D to download current bank
                if (modifierKey && e.key === "d" && app.currentBankId) {
                    e.preventDefault();
                    downloadBank(app.currentBankId);
                }
                
                // F1 for help
                if (e.key === "F1") {
                    e.preventDefault();
                    showHelpOverlay();
                }
            });
        }

        // Show help overlay
        function showHelpOverlay() {
            // Create help overlay element if it doesn't exist
            let helpOverlay = document.getElementById("helpOverlay");
            if (!helpOverlay) {
                helpOverlay = document.createElement("div");
                helpOverlay.id = "helpOverlay";
                helpOverlay.className = "modal-overlay";
                helpOverlay.setAttribute("role", "dialog");
                helpOverlay.setAttribute("aria-labelledby", "helpTitle");
                
                const helpContent = document.createElement("div");
                helpContent.className = "modal help-modal";
                
                helpContent.innerHTML = `
                    <div class="modal-title" id="helpTitle">Keyboard Shortcuts</div>
                    <div class="help-content">
                        <div class="shortcut-row"><span class="key">Ctrl+S</span> <span>Save current bank</span></div>
                        <div class="shortcut-row"><span class="key">Ctrl+Z</span> <span>Undo edit</span></div>
                        <div class="shortcut-row"><span class="key">Ctrl+N</span> <span>Create new bank</span></div>
                        <div class="shortcut-row"><span class="key">Ctrl+D</span> <span>Download current bank</span></div>
                        <div class="shortcut-row"><span class="key">F1</span> <span>Show this help</span></div>
                        <div class="shortcut-row"><span class="key">Esc</span> <span>Close dialogs</span></div>
                        <div class="shortcut-row"><span class="key">Tab</span> <span>In editor: insert tab character</span></div>
                    </div>
                    <div class="modal-buttons">
                        <button id="closeHelp">Close</button>
                    </div>
                `;
                
                document.body.appendChild(helpOverlay);
                
                // Add event listener
                document.getElementById("closeHelp").addEventListener("click", () => {
                    helpOverlay.style.display = "none";
                });
                
                // Close on escape key
                helpOverlay.addEventListener("keydown", (e) => {
                    if (e.key === "Escape") {
                        helpOverlay.style.display = "none";
                    }
                });
                
                // Close when clicking outside modal
                helpOverlay.addEventListener("click", (e) => {
                    if (e.target === helpOverlay) {
                        helpOverlay.style.display = "none";
                    }
                });
            }
            
            // Show help overlay
            helpOverlay.style.display = "flex";
            document.getElementById("closeHelp").focus();
        }

        // Undo edit
        function undoEdit(bankId) {
            if (app.undoHistory[bankId] && app.undoHistory[bankId].length > 0) {
                // Get the previous state
                const previousState = app.undoHistory[bankId].pop();
                
                // Save current state to temp in case we need to restore it
                const currentState = JSON.stringify(app.banks[bankId]);
                
                // Apply the previous state
                app.banks[bankId] = JSON.parse(previousState);
                
                // Refresh the editor
                const textEditor = document.getElementById(`textEditor_${bankId}`);
                if (textEditor) {
                    textEditor.value = generateBankText(app.banks[bankId]);
                }
                
                showToast("Undo successful");
            } else {
                showToast("Nothing to undo");
            }
        }

        // Theme management
        function changeTheme() {
            const selectedTheme = elements.themeSelect.value;
            
            // Remove existing theme classes
            document.body.classList.remove('theme-cpp', 'theme-dark', 'theme-light');
            
            // Add new theme class if not default
            if (selectedTheme !== 'default') {
                document.body.classList.add(`theme-${selectedTheme}`);
            }
            
            // Save theme preference
            app.currentTheme = selectedTheme;
            saveThemeToStorage();
            
            showToast(`Theme changed to ${selectedTheme}`);
        }
        
        function saveThemeToStorage() {
            try {
                localStorage.setItem("dataBankTheme", app.currentTheme);
            } catch (e) {
                console.error("Error saving theme:", e);
            }
        }
        
        function loadThemeFromStorage() {
            try {
                const savedTheme = localStorage.getItem("dataBankTheme");
                if (savedTheme) {
                    app.currentTheme = savedTheme;
                    elements.themeSelect.value = savedTheme;
                    
                    // Apply the theme
                    if (savedTheme !== 'default') {
                        document.body.classList.add(`theme-${savedTheme}`);
                    }
                }
            } catch (e) {
                console.error("Error loading theme:", e);
            }
        }

        // Configuration methods
        function loadConfigFromStorage() {
            try {
                const storedConfig = localStorage.getItem("dataBankConfig");
                if (storedConfig) {
                    const config = JSON.parse(storedConfig);
                    app.maxRegisters = config.maxRegisters || 10;
                    app.maxAddresses = config.maxAddresses || 20;
                    app.readingMode = config.readingMode || "raw";

                    // Update UI controls
                    elements.maxRegisters.value = app.maxRegisters;
                    elements.maxAddresses.value = app.maxAddresses;
                    elements.readingMode.value = app.readingMode;
                }
            } catch (e) {
                console.error("Error loading config:", e);
            }
        }

        function saveConfigToStorage() {
            try {
                localStorage.setItem("dataBankConfig", JSON.stringify({
                    maxRegisters: app.maxRegisters,
                    maxAddresses: app.maxAddresses,
                    readingMode: app.readingMode
                }));
            } catch (e) {
                console.error("Error saving config:", e);
            }
        }

        function updateConfig() {
            try {
                app.maxRegisters = parseInt(elements.maxRegisters.value);
                app.maxAddresses = parseInt(elements.maxAddresses.value);
                saveConfigToStorage();
                showToast("Configuration updated");
            } catch (e) {
                showToast(`Error updating config: ${e}`);
            }
        }

        function updateReadingMode() {
            const previousMode = app.readingMode;
            app.readingMode = elements.readingMode.value;

            if (previousMode !== app.readingMode) {
                saveConfigToStorage();
                refreshAllBanks();
                showToast(`Reading mode changed to: ${app.readingMode}`);
            }
        }

		function handleFileUpload(event) {
			const files = event.target.files;
			if (!files || files.length === 0) return;

			setStatusMessage("Processing files...");

			let processedCount = 0;
			let errorCount = 0;
			
			// Generate a unique ID for this progress toast
			const toastId = 'progress-toast-' + Date.now();

			// Create progress notification with ID
			const progressToast = document.createElement("div");
			progressToast.className = "progress-toast";
			progressToast.id = toastId;
			progressToast.innerHTML = `
				<div>Processing files...</div>
				<div class="progress-bar">
					<div class="progress-fill" style="width: 0%"></div>
				</div>
				<div class="progress-text">0/${files.length}</div>
			`;
			document.body.appendChild(progressToast);

			// Process each file
			const promises = Array.from(files).map((file, index) => {
				return new Promise((resolve) => {
					// Check filename format (should be number.txt)
					const match = file.name.match(/^(\d+)\.txt$/);

					if (!match) {
						showToast(`Skipped ${file.name} - Invalid filename format. Should be 'number.txt'`);
						errorCount++;
						updateProgress(index + 1);
						resolve();
						return;
					}

					const bankId = parseInt(match[1]);

					// Read file content
					const reader = new FileReader();
					reader.onload = function(e) {
						try {
							const content = e.target.result;
							processFileContent(bankId, content);
							processedCount++;
						} catch (e) {
							errorCount++;
							showToast(`Failed to read file: ${file.name} - ${e.message}`);
						}
						updateProgress(index + 1);
						resolve();
					};
					
					reader.onerror = function() {
						errorCount++;
						showToast(`Error reading file: ${file.name}`);
						updateProgress(index + 1);
						resolve();
					};

					reader.readAsText(file);
				});
			});

			// When all files are processed, ensure toast is removed
			Promise.all(promises).then(() => {
				// Final update
				setStatusMessage("File processing complete");
				showToast(`Processed ${processedCount} bank files, ${errorCount} errors`);
				
				// Force remove the progress toast
				setTimeout(() => {
					const toast = document.getElementById(toastId);
					if (toast) {
						toast.remove();
					}
				}, 1000);
			});

			// Update progress
			function updateProgress(completed) {
				const percent = Math.round((completed / files.length) * 100);
				const toast = document.getElementById(toastId);
				
				if (toast) {
					const progressFill = toast.querySelector(".progress-fill");
					const progressText = toast.querySelector(".progress-text");
					
					if (progressFill) progressFill.style.width = `${percent}%`;
					if (progressText) progressText.textContent = `${completed}/${files.length}`;
				}
			}

			// Reset file input
			event.target.value = "";
		}

        function processFileContent(bankId, content) {
            try {
                const bank = parseBankData(bankId, content);
                app.banks[bankId] = bank;

                // Create or update the bank tab
                createBankTab(bankId);

                // If this is the first bank, select it
                if (app.currentBankId === null) {
                    selectBank(bankId);
                }

                showToast(`Bank ${bankId} loaded successfully`);
            } catch (e) {
                showToast(`Error processing Bank ${bankId}: ${e.message}`);
                console.error(`Error processing Bank ${bankId}:`, e);
            }
        }

        // Modified parseBankData function to support multi-line values
        function parseBankData(bankId, content) {
            const lines = content.split('\n');
            const bank = {
                id: bankId,
                registers: {}
            };

            let currentRegister = null;
            let inMultiLineValue = false;
            let currentAddressId = null;
            let multiLineBuffer = [];

            // Process each line
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // If we're collecting a multi-line value
                if (inMultiLineValue) {
                    // Check if this line ends the multi-line value
                    if (line.trim() === '"""') {
                        // Save the multi-line value
                        bank.registers[currentRegister].addresses[currentAddressId] = multiLineBuffer.join('\n');
                        multiLineBuffer = [];
                        inMultiLineValue = false;
                    } else {
                        // Add to multi-line buffer
                        multiLineBuffer.push(line);
                    }
                    continue;
                }

                // Skip empty lines when not in multi-line mode
                if (!line.trim() && !inMultiLineValue) {
                    continue;
                }

                // Check if it's a register line (no tab at the beginning)
                if (!line.startsWith('\t')) {
                    // It's a register number
                    try {
                        currentRegister = parseInt(line.trim());
                    } catch (e) {
                        throw new Error(`Invalid register number at line ${i + 1}`);
                    }

                    // Initialize register if not exists
                    if (!bank.registers[currentRegister]) {
                        bank.registers[currentRegister] = {
                            addresses: {}
                        };
                    }
                } else {
                    // It's an address line (starts with tab)
                    if (currentRegister === null) {
                        throw new Error(`Address found before any register at line ${i + 1}`);
                    }

                    // Extract the content after the tab
                    const addressLine = line.replace(/^\t+/, '');

                    // Split into address ID and value using the first tab as delimiter
                    const parts = addressLine.split('\t', 2);

                    try {
                        const addressId = parseInt(parts[0].trim());
                        currentAddressId = addressId;
                        
                        if (parts.length === 1) {
                            // Empty value
                            bank.registers[currentRegister].addresses[addressId] = "";
                        } else {
                            // Check if this is a multi-line value start
                            if (parts[1].trim() === '"""') {
                                inMultiLineValue = true;
                                multiLineBuffer = [];
                            } else {
                                // Single-line value
                                bank.registers[currentRegister].addresses[addressId] = parts[1];
                            }
                        }
                    } catch (e) {
                        throw new Error(`Invalid address format at line ${i + 1}`);
                    }
                }
            }

            // Check if we ended with an unclosed multi-line value
            if (inMultiLineValue) {
                throw new Error('Unclosed multi-line value at end of file');
            }

            return bank;
        }

        // Tab management methods
        function createBankTab(bankId) {
            // Check if tab already exists
            const existingTab = document.getElementById(`bankTab_${bankId}`);
            if (existingTab) {
                return; // Tab already exists
            }

            // Create new tab with more interactive features
            const tab = document.createElement("div");
            tab.className = "tab";
            tab.id = `bankTab_${bankId}`;
            tab.setAttribute("role", "tab");
            tab.setAttribute("tabindex", "0");
            tab.setAttribute("aria-selected", "false");
            
            // Add bank ID and close button to tab
            tab.innerHTML = `
                <span class="tab-title">Bank ${bankId}</span>
                <button class="tab-close" aria-label="Close Bank ${bankId}" tabindex="0">&times;</button>
            `;
            
            // Add event listeners
            tab.addEventListener("click", (e) => {
                // Don't select if clicking the close button
                if (!e.target.classList.contains("tab-close")) {
                    selectBank(bankId);
                }
            });
            tab.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    selectBank(bankId);
                }
            });
            
            // Add event listener for close button
            tab.querySelector(".tab-close").addEventListener("click", (e) => {
                e.stopPropagation();
                closeBank(bankId);
            });
            tab.querySelector(".tab-close").addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    e.stopPropagation();
                    closeBank(bankId);
                }
            });

            // Insert before the Add tab
            elements.bankTabs.insertBefore(tab, elements.addBankTab);

            // Create content container for this bank
            const content = document.createElement("div");
            content.className = "tab-content";
            content.id = `bankContent_${bankId}`;
            content.setAttribute("role", "tabpanel");
            content.setAttribute("aria-labelledby", `bankTab_${bankId}`);
            elements.bankContents.appendChild(content);
        }

        // Close a bank
        function closeBank(bankId) {
            if (confirm(`Are you sure you want to close Bank ${bankId}? Any unsaved changes will be lost.`)) {
                // Remove the tab
                const tab = document.getElementById(`bankTab_${bankId}`);
                if (tab) tab.remove();
                
                // Remove the content
                const content = document.getElementById(`bankContent_${bankId}`);
                if (content) content.remove();
                
                // Remove from app state
                delete app.banks[bankId];
                delete app.editMode[bankId];
                delete app.undoHistory[bankId];
                
                // If this was the current bank, select another one
                if (app.currentBankId === bankId) {
                    app.currentBankId = null;
                    
                    // Find another bank to select
                    const bankIds = Object.keys(app.banks);
                    if (bankIds.length > 0) {
                        selectBank(parseInt(bankIds[0]));
                    }
                }
                
                showToast(`Bank ${bankId} closed`);
            }
        }

        function selectBank(bankId) {
            // Update current bank ID
            app.currentBankId = bankId;

            // Update tab styles and ARIA attributes
            const tabs = elements.bankTabs.querySelectorAll(".tab");
            tabs.forEach(tab => {
                tab.classList.remove("active");
                tab.setAttribute("aria-selected", "false");
            });
            
            const selectedTab = document.getElementById(`bankTab_${bankId}`);
            if (selectedTab) {
                selectedTab.classList.add("active");
                selectedTab.setAttribute("aria-selected", "true");
            }

            // Update content visibility
            const contents = elements.bankContents.querySelectorAll(".tab-content");
            contents.forEach(content => content.classList.remove("active"));
            const selectedContent = document.getElementById(`bankContent_${bankId}`);
            if (selectedContent) {
                selectedContent.classList.add("active");
                displayBankData(bankId);
            }
        }

        // Bank data display methods
        function displayBankData(bankId) {
            // Get the bank data
            const bank = app.banks[bankId];
            if (!bank) return;

            // Get the content container
            const contentContainer = document.getElementById(`bankContent_${bankId}`);
            if (!contentContainer) return;

            // Clear the container
            contentContainer.innerHTML = "";

            // Check if in edit mode
            if (app.editMode[bankId]) {
                displayEditMode(bankId, contentContainer);
            } else {
                displayViewMode(bankId, contentContainer);
            }
        }

        function displayEditMode(bankId, container) {
            const bank = app.banks[bankId];

            // Create edit control toolbar with improved layout
            const toolbar = document.createElement("div");
            toolbar.className = "bank-toolbar";
            toolbar.innerHTML = `
                <div class="toolbar-title">
                    <span>Editing Bank ${bankId}</span>
                    <span class="edit-hint">(Ctrl+S to save, Ctrl+Z to undo)</span>
                </div>
                <div class="toolbar-actions">
                    <button id="cancelEditBank_${bankId}" tabindex="0">Cancel</button>
                    <button id="saveEditBank_${bankId}" tabindex="0" class="primary-button">Save</button>
                </div>
            `;
            container.appendChild(toolbar);

            // Add event listeners to buttons
            document.getElementById(`cancelEditBank_${bankId}`).addEventListener("click", () => cancelBankEdits(bankId));
            document.getElementById(`saveEditBank_${bankId}`).addEventListener("click", () => saveBankEdits(bankId));

            // Create editor container to control flex sizing
            const editorContainer = document.createElement("div");
            editorContainer.className = "editor-container";
            container.appendChild(editorContainer);

            // Create helpful syntax hints
            const syntaxHints = document.createElement("div");
            syntaxHints.className = "syntax-hints";
            syntaxHints.innerHTML = `
                <div>Format: <code>register</code> followed by <code>â­¾addressâ­¾value</code> lines</div>
                <div>For multi-line values: <code>â­¾addressâ­¾"""</code> followed by content and ending with <code>"""</code></div>
            `;
            editorContainer.appendChild(syntaxHints);

            // Create text editor with line numbers
            const editorWrapper = document.createElement("div");
            editorWrapper.className = "editor-wrapper";
            editorContainer.appendChild(editorWrapper);

            // Line numbers container
            const lineNumbers = document.createElement("div");
            lineNumbers.className = "line-numbers";
            editorWrapper.appendChild(lineNumbers);

            // Text editor
            const textEditor = document.createElement("textarea");
            textEditor.className = "text-editor";
            textEditor.id = `textEditor_${bankId}`;
            textEditor.spellcheck = false;
            textEditor.wrap = "off"; // Disable word wrapping for better code editing
            
            // Enable tab character insertion
            textEditor.addEventListener("keydown", function(e) {
                if (e.key === "Tab") {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Insert tab at cursor position
                    this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
                    
                    // Move cursor after the inserted tab
                    this.selectionStart = this.selectionEnd = start + 1;
                }
            });
            
            // Track changes for undo history
            textEditor.addEventListener("input", () => {
                // Create undo history array if it doesn't exist
                if (!app.undoHistory[bankId]) {
                    app.undoHistory[bankId] = [];
                }
                
                // Store current state for undo (limit history to 50 steps)
                if (app.undoHistory[bankId].length >= 50) {
                    app.undoHistory[bankId].shift();
                }
                app.undoHistory[bankId].push(JSON.stringify(app.banks[bankId]));
            });
            
            // Update line numbers when scrolling or changing content
            textEditor.addEventListener("scroll", updateLineNumbers);
            textEditor.addEventListener("input", updateLineNumbers);
            
            editorWrapper.appendChild(textEditor);

            // Generate bank text content
            const bankText = generateBankText(bank);
            textEditor.value = bankText;
            
            // Initialize line numbers
            updateLineNumbers();
            
            // Focus the editor
            setTimeout(() => textEditor.focus(), 0);
            
            // Function to update line numbers
            function updateLineNumbers() {
                const lines = textEditor.value.split('\n');
                const lineCount = lines.length;
                let lineNumbersHTML = '';
                
                for (let i = 1; i <= lineCount; i++) {
                    lineNumbersHTML += `<div>${i}</div>`;
                }
                
                lineNumbers.innerHTML = lineNumbersHTML;
                
                // Sync scroll position
                lineNumbers.scrollTop = textEditor.scrollTop;
            }
        }

        function displayViewMode(bankId, container) {
            const bank = app.banks[bankId];

            // Create toolbar with search functionality
            const toolbar = document.createElement("div");
            toolbar.className = "bank-toolbar";
            toolbar.innerHTML = `
                <div class="toolbar-info">
                    <h3 class="bank-title">Bank ${bankId}</h3>
                    <div class="bank-stats">${countRegisters(bank)} registers, ${countAddresses(bank)} addresses</div>
                </div>
                <div class="toolbar-controls">
                    <div class="search-container">
                        <input type="text" id="searchBank_${bankId}" placeholder="Search..." aria-label="Search in this bank">
                        <button id="clearSearch_${bankId}" class="clear-search" aria-label="Clear search">&times;</button>
                    </div>
                    <div class="button-container">
                        <button id="editBank_${bankId}" tabindex="0" aria-label="Edit Bank ${bankId}">Edit</button>
                        <button id="downloadBank_${bankId}" tabindex="0" aria-label="Download Bank ${bankId}">Download</button>
                    </div>
                </div>
            `;
            container.appendChild(toolbar);

            // Add event listeners to buttons
            document.getElementById(`editBank_${bankId}`).addEventListener("click", () => startEditMode(bankId));
            document.getElementById(`downloadBank_${bankId}`).addEventListener("click", () => downloadBank(bankId));
            
            // Add search functionality
            const searchInput = document.getElementById(`searchBank_${bankId}`);
            const clearSearch = document.getElementById(`clearSearch_${bankId}`);
            
            searchInput.addEventListener("input", () => {
                const searchTerm = searchInput.value.toLowerCase();
                app.searchTerm = searchTerm;
                highlightSearchResults(bankId, searchTerm);
            });
            
            clearSearch.addEventListener("click", () => {
                searchInput.value = "";
                app.searchTerm = "";
                highlightSearchResults(bankId, "");
            });

            // Create a scrollable container for registers
            const registersContainer = document.createElement("div");
            registersContainer.className = "registers-container";
            container.appendChild(registersContainer);

            // Sort registers by ID
            const registerIds = Object.keys(bank.registers).map(id => parseInt(id)).sort((a, b) => a - b);

            // Create UI for each register with improved layout
            registerIds.forEach(registerId => {
                const register = bank.registers[registerId];

                // Register container
                const registerContainer = document.createElement("div");
                registerContainer.className = "register-container";
                registerContainer.id = `bank_${bankId}_register_${registerId}`;
                registersContainer.appendChild(registerContainer);

                // Register header with collapsible functionality
                const registerHeader = document.createElement("div");
                registerHeader.className = "register-header";
                registerHeader.innerHTML = `
                    <div class="register-title">
                        <span class="collapse-icon">â–¼</span>
                        Register ${registerId}
                    </div>
                    <div class="register-count">${Object.keys(register.addresses).length} addresses</div>
                `;
                registerContainer.appendChild(registerHeader);
                
                // Make register collapsible
                registerHeader.addEventListener("click", () => {
                    registerContainer.classList.toggle("collapsed");
                    const icon = registerHeader.querySelector(".collapse-icon");
                    icon.textContent = registerContainer.classList.contains("collapsed") ? "â–¶" : "â–¼";
                });

                // Addresses table with improved sorting and filtering
                const tableContainer = document.createElement("div");
                tableContainer.className = "table-container";
                registerContainer.appendChild(tableContainer);
                
                const table = document.createElement("table");
                table.className = "addresses-table";
                tableContainer.appendChild(table);

                // Table header with sorting functionality
                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr>
                        <th class="sortable" data-sort="address">Address <span class="sort-icon">â‡…</span></th>
                        <th class="sortable" data-sort="value">Value <span class="sort-icon">â‡…</span></th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Add sorting functionality
                thead.querySelectorAll(".sortable").forEach(th => {
                    th.addEventListener("click", () => {
                        const sortField = th.getAttribute("data-sort");
                        sortTableByColumn(table, sortField, th);
                    });
                });

                // Table body
                const tbody = document.createElement("tbody");
                table.appendChild(tbody);

                // Sort addresses by ID
                const addressIds = Object.keys(register.addresses).map(id => parseInt(id)).sort((a, b) => a - b);

                // Create rows for each address with improved formatting
                addressIds.forEach(addressId => {
                    const value = register.addresses[addressId];
                    const row = document.createElement("tr");
                    row.dataset.addressId = addressId;
                    row.dataset.value = value || "";
                    
                    // Address ID cell
                    const addressCell = document.createElement("td");
                    addressCell.textContent = addressId;
                    addressCell.className = "address-cell";
                    addressCell.setAttribute("data-label", "Address:");
                    row.appendChild(addressCell);
                    
                    // Value cell with copy capability
                    const valueCell = document.createElement("td");
                    valueCell.className = "value-cell";
                    valueCell.setAttribute("data-label", "Value:");
                    
                    // Add a copy button for easier value copying
                    const copyButton = document.createElement("button");
                    copyButton.className = "copy-value";
                    copyButton.innerHTML = "Copy";
                    copyButton.setAttribute("aria-label", "Copy value to clipboard");
                    copyButton.addEventListener("click", (e) => {
                        e.stopPropagation();
                        // Copy the raw or resolved value to clipboard
                        const textToCopy = app.readingMode === "resolve" && containsReferences(value) 
                            ? resolveValue(value)
                            : value || "";
                        navigator.clipboard.writeText(textToCopy)
                            .then(() => showToast("Value copied to clipboard"))
                            .catch(() => showToast("Failed to copy value"));
                    });
                    
                    if (app.readingMode === "resolve" && containsReferences(value)) {
                        // Raw value with reference highlighting
                        const rawValueDiv = document.createElement("div");
                        rawValueDiv.className = "raw-value";
                        rawValueDiv.appendChild(formatValueWithReferences(value, bankId, registerId, addressId));
                        valueCell.appendChild(rawValueDiv);
                        
                        // Resolved value
                        const resolvedValue = resolveValue(value);
                        const resolvedDiv = document.createElement("div");
                        resolvedDiv.className = "resolved-value";
                        
                        if (resolvedValue.includes('\n')) {
                            // Multi-line resolved value
                            resolvedDiv.appendChild(document.createTextNode("â†’ "));
                            const pre = document.createElement("pre");
                            pre.style.margin = "0";
                            pre.style.whiteSpace = "pre-wrap";
                            pre.style.fontFamily = "inherit";
                            pre.textContent = resolvedValue;
                            resolvedDiv.appendChild(pre);
                        } else {
                            // Single-line resolved value
                            resolvedDiv.textContent = `â†’ ${resolvedValue}`;
                        }
                        
                        valueCell.appendChild(resolvedDiv);
                    } else {
                        // Display raw value with proper formatting
                        valueCell.appendChild(displayValueWithFormatting(value));
                    }
                    
                    // Add copy button
                    valueCell.appendChild(copyButton);
                    
                    row.appendChild(valueCell);
                    tbody.appendChild(row);
                });
            });
            
            // Apply any active search
            if (app.searchTerm) {
                highlightSearchResults(bankId, app.searchTerm);
            }
        }
        
        // Count registers in a bank
        function countRegisters(bank) {
            return Object.keys(bank.registers).length;
        }
        
        // Count total addresses in a bank
        function countAddresses(bank) {
            let count = 0;
            for (const registerId in bank.registers) {
                count += Object.keys(bank.registers[registerId].addresses).length;
            }
            return count;
        }
        
        // Sort table by column
        function sortTableByColumn(table, column, header) {
            const tbody = table.querySelector("tbody");
            const rows = Array.from(tbody.querySelectorAll("tr"));
            
            // Toggle sort direction
            const currentDir = header.getAttribute("data-sort-dir") || "asc";
            const newDir = currentDir === "asc" ? "desc" : "asc";
            
            // Update all headers
            table.querySelectorAll("th").forEach(th => {
                th.removeAttribute("data-sort-dir");
                th.querySelector(".sort-icon").textContent = "â‡…";
            });
            
            // Update this header
            header.setAttribute("data-sort-dir", newDir);
            header.querySelector(".sort-icon").textContent = newDir === "asc" ? "â†‘" : "â†“";
            
            // Sort rows
            rows.sort((rowA, rowB) => {
                let valueA, valueB;
                
                if (column === "address") {
                    valueA = parseInt(rowA.dataset.addressId);
                    valueB = parseInt(rowB.dataset.addressId);
                } else { // value
                    valueA = rowA.dataset.value || "";
                    valueB = rowB.dataset.value || "";
                }
                
                if (valueA < valueB) {
                    return newDir === "asc" ? -1 : 1;
                } else if (valueA > valueB) {
                    return newDir === "asc" ? 1 : -1;
                }
                return 0;
            });
            
            // Reorder rows
            rows.forEach(row => tbody.appendChild(row));
        }
        
        // Search and highlight results
        function highlightSearchResults(bankId, searchTerm) {
            const container = document.getElementById(`bankContent_${bankId}`);
            if (!container) return;
            
            // Get all rows
            const rows = container.querySelectorAll("tbody tr");
            
            // Reset all highlights
            rows.forEach(row => {
                row.classList.remove("search-match");
                
                // Reset text highlighting in values
                row.querySelectorAll(".highlighted").forEach(span => {
                    // Replace the highlighted span with its text content
                    const text = span.textContent;
                    span.parentNode.replaceChild(document.createTextNode(text), span);
                });
            });
            
            // If no search term, we're done
            if (!searchTerm) return;
            
            let matchCount = 0;
            
            // Highlight matching rows
            rows.forEach(row => {
                const addressId = row.querySelector("td:first-child").textContent;
                const valueCell = row.querySelector("td:nth-child(2)");
                let valueText = "";
                
                // Get all text from the value cell
                valueCell.querySelectorAll("*").forEach(el => {
                    if (el.textContent) valueText += el.textContent + " ";
                });
                
                // Check for matches
                if (addressId.includes(searchTerm) || valueText.toLowerCase().includes(searchTerm)) {
                    row.classList.add("search-match");
                    matchCount++;
                    
                    // Highlight the matching text in address
                    if (addressId.includes(searchTerm)) {
                        highlightText(row.querySelector("td:first-child"), searchTerm);
                    }
                    
                    // Highlight the matching text in value
                    if (valueText.toLowerCase().includes(searchTerm)) {
                        // For each text node in the value cell
                        highlightTextInNode(valueCell, searchTerm);
                    }
                }
            });
            
            // Show search result count
            if (matchCount > 0) {
                showToast(`Found ${matchCount} matches for "${searchTerm}"`);
            } else {
                showToast(`No matches found for "${searchTerm}"`);
            }
        }
        
        // Highlight text in a node and its children
        function highlightTextInNode(node, searchTerm) {
            // Skip if this is a "highlighted" span we've already processed
            if (node.classList && node.classList.contains("highlighted")) {
                return;
            }
            
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent;
                const lowerText = text.toLowerCase();
                const lowerSearchTerm = searchTerm.toLowerCase();
                
                // If this text node contains the search term
                if (lowerText.includes(lowerSearchTerm)) {
                    // Create a temporary container
                    const temp = document.createElement("span");
                    
                    // Split by the search term and add highlighting
                    let pos = 0;
                    let i = lowerText.indexOf(lowerSearchTerm);
                    
                    while (i >= 0) {
                        // Add text before match
                        if (i > pos) {
                            temp.appendChild(document.createTextNode(text.substring(pos, i)));
                        }
                        
                        // Add highlighted match
                        const match = document.createElement("span");
                        match.className = "highlighted";
                        match.textContent = text.substring(i, i + searchTerm.length);
                        temp.appendChild(match);
                        
                        // Update position
                        pos = i + searchTerm.length;
                        i = lowerText.indexOf(lowerSearchTerm, pos);
                    }
                    
                    // Add remaining text
                    if (pos < text.length) {
                        temp.appendChild(document.createTextNode(text.substring(pos)));
                    }
                    
                    // Replace the original node with the highlighted content
                    const fragment = document.createDocumentFragment();
                    while (temp.firstChild) {
                        fragment.appendChild(temp.firstChild);
                    }
                    node.parentNode.replaceChild(fragment, node);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Skip certain elements like buttons
                if (node.tagName === "BUTTON") return;
                
                // Process child nodes
                Array.from(node.childNodes).forEach(child => {
                    highlightTextInNode(child, searchTerm);
                });
            }
        }
        
        // Simple text highlighting for a text node
        function highlightText(element, searchTerm) {
            const text = element.textContent;
            const lowerText = text.toLowerCase();
            const lowerSearchTerm = searchTerm.toLowerCase();
            
            if (lowerText.includes(lowerSearchTerm)) {
                // Clear the element
                element.innerHTML = "";
                
                // Split by the search term and add highlighting
                let pos = 0;
                let i = lowerText.indexOf(lowerSearchTerm);
                
                while (i >= 0) {
                    // Add text before match
                    if (i > pos) {
                        element.appendChild(document.createTextNode(text.substring(pos, i)));
                    }
                    
                    // Add highlighted match
                    const match = document.createElement("span");
                    match.className = "highlighted";
                    match.textContent = text.substring(i, i + searchTerm.length);
                    element.appendChild(match);
                    
                    // Update position
                    pos = i + searchTerm.length;
                    i = lowerText.indexOf(lowerSearchTerm, pos);
                }
                
                // Add remaining text
                if (pos < text.length) {
                    element.appendChild(document.createTextNode(text.substring(pos)));
                }
            }
        }

        // Helper function to display value with proper formatting
        function displayValueWithFormatting(value) {
            const container = document.createElement("div");
            
            // Add special class for multi-line values
            if (value && value.includes('\n')) {
                container.classList.add("multi-line-value");
            }
            
            // Create a text node that preserves whitespace
            const pre = document.createElement("pre");
            pre.style.margin = "0";
            pre.style.whiteSpace = "pre-wrap";
            pre.style.wordBreak = "break-word";
            pre.style.fontFamily = "inherit";
            pre.textContent = value || "";
            
            container.appendChild(pre);
            return container;
        }

        function containsReferences(value) {
            if (!value) return false;
            
            // Regular expression to find references (e.g., 1.2.3)
            const refRegex = /\d+\.\d+\.\d+/;
            return refRegex.test(value);
        }

        function formatValueWithReferences(value, bankId, registerId, addressId) {
            if (!value) return document.createTextNode("");
            
            // Create a container for the formatted text
            const container = document.createElement("div");
            
            // For multi-line content, we need to process each line separately
            // while maintaining the line breaks
            if (value.includes('\n')) {
                container.classList.add("multi-line-value");
                
                const lines = value.split('\n');
                
                lines.forEach((line, lineIndex) => {
                    // Process references in this line
                    const lineElement = processLineWithReferences(line, bankId, registerId, addressId);
                    container.appendChild(lineElement);
                    
                    // Add line break for all but the last line
                    if (lineIndex < lines.length - 1) {
                        container.appendChild(document.createElement("br"));
                    }
                });
            } else {
                // Single line processing
                const processedLine = processLineWithReferences(value, bankId, registerId, addressId);
                container.appendChild(processedLine);
            }
            
            return container;
        }

        function processLineWithReferences(line, bankId, registerId, addressId) {
            const container = document.createElement("span");
            
            // Regular expression to find references
            const refRegex = /(\d+\.\d+\.\d+)/g;
            
            // Split the text by references
            const parts = line.split(refRegex);
            
            // Add each part to the container
            parts.forEach((part, i) => {
                if (i % 2 === 0) {
                    // Regular text - preserve whitespace
                    if (part) {
                        const textSpan = document.createElement("span");
                        textSpan.style.whiteSpace = "pre";
                        textSpan.textContent = part;
                        container.appendChild(textSpan);
                    }
                } else {
                    // Reference - make it a button
                    const refLink = document.createElement("span");
                    refLink.className = "reference";
                    refLink.textContent = part;
                    refLink.setAttribute("tabindex", "0"); // Make focusable
                    refLink.setAttribute("role", "button");
                    refLink.setAttribute("aria-label", `Navigate to reference ${part}`);
                    refLink.title = `Navigate to reference ${part}`;
                    
                    // Add click and keyboard handlers
                    refLink.addEventListener("click", () => handleReferenceClick(part));
                    refLink.addEventListener("keydown", (e) => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            handleReferenceClick(part);
                        }
                    });
                    
                    container.appendChild(refLink);
                }
            });
            
            return container;
        }

        function handleReferenceClick(refPath) {
            // Parse the reference path (e.g., "1.2.3")
            try {
                const [bankId, registerId, addressId] = refPath.split('.').map(part => parseInt(part));
                
                // Check if the bank exists
                if (!app.banks[bankId]) {
                    showToast(`Bank ${bankId} not found`);
                    return;
                }
                
                // Use the improved highlighting function
                highlightReference(bankId, registerId, addressId);
                
            } catch (e) {
                showToast(`Invalid reference format: ${refPath}`);
            }
        }

        function highlightReference(bankId, registerId, addressId) {
            // First check if we need to switch to a different bank
            if (app.currentBankId !== bankId) {
                // If we need to switch banks, select the bank and then try highlighting again
                selectBank(bankId);
                
                // Allow time for the UI to update before trying to highlight
                setTimeout(() => {
                    highlightReferenceInCurrentBank(registerId, addressId);
                }, 100);
            } else {
                // We're already on the correct bank, so just highlight
                highlightReferenceInCurrentBank(registerId, addressId);
            }
        }

        function highlightReferenceInCurrentBank(registerId, addressId) {
            // Get the current bank's content container
            const bankContent = document.querySelector('.tab-content.active');
            if (!bankContent) {
                showToast("Error: Cannot find active bank content");
                return;
            }
            
            // Find the register container within this bank content
            const registerContainer = document.getElementById(`bank_${app.currentBankId}_register_${registerId}`);
            
            if (registerContainer) {
                // Make sure the register is expanded
                if (registerContainer.classList.contains("collapsed")) {
                    // Click the header to expand
                    registerContainer.querySelector('.register-header').click();
                }
                
                // Find the row for this address
                const rows = registerContainer.querySelectorAll('tbody tr');
                let found = false;
                
                for (const row of rows) {
                    if (row.dataset.addressId === addressId.toString()) {
                        // Highlight the row
                        row.style.backgroundColor = 'var(--bg-highlight)';
                        
                        // Add a pulsing effect
                        row.classList.add("highlight-pulse");
                        
                        // Scroll to the row
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Remove highlight after a delay
                        setTimeout(() => {
                            row.style.backgroundColor = '';
                            row.classList.remove("highlight-pulse");
                        }, 2000);
                        
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    showToast(`Address ${addressId} not found in Register ${registerId}`);
                }
            } else {
                showToast(`Register ${registerId} not found`);
            }
        }

        function resolveValue(value, visited = null) {
            if (visited === null) visited = new Set();
            if (!value) return "";
            
            // Regular expression to find references
            const refRegex = /(\d+)\.(\d+)\.(\d+)/g;
            
            return value.replace(refRegex, (match, bankIdStr, registerIdStr, addressIdStr) => {
                const bankId = parseInt(bankIdStr);
                const registerId = parseInt(registerIdStr);
                const addressId = parseInt(addressIdStr);
                
                // Check for circular references
                const refKey = `${bankId}.${registerId}.${addressId}`;
                if (visited.has(refKey)) {
                    return `[Circular Ref: ${match}]`;
                }
                
                // Get referenced value
                const referencedValue = getReferencedValue(bankId, registerId, addressId);
                
                // Handle errors
                if (!referencedValue.success) {
                    return `[${referencedValue.error}]`;
                }
                
                // Check for nested references
                if (containsReferences(referencedValue.value)) {
                    const newVisited = new Set(visited);
                    newVisited.add(refKey);
                    return resolveValue(referencedValue.value, newVisited);
                }
                
                return referencedValue.value;
            });
        }

        function getReferencedValue(bankId, registerId, addressId) {
            // Check if bank exists
            if (!app.banks[bankId]) {
                return { success: false, error: `Bank ${bankId} not found` };
            }
            
            // Check if register exists
            if (!app.banks[bankId].registers[registerId]) {
                return { success: false, error: `Register ${registerId} not found in Bank ${bankId}` };
            }
            
            // Check if address exists
            if (!app.banks[bankId].registers[registerId].addresses[addressId] === undefined) {
                return { success: false, error: `Address ${addressId} not found in Bank ${bankId}, Register ${registerId}` };
            }
            
            // Return the value
            return {
                success: true,
                value: app.banks[bankId].registers[registerId].addresses[addressId] || ""
            };
        }

        // Bank editing methods
        function startEditMode(bankId) {
            // Store current state for undo
            app.undoHistory[bankId] = [JSON.stringify(app.banks[bankId])];
            app.editMode[bankId] = true;
            displayBankData(bankId);
        }

        function saveBankEdits(bankId) {
            const textEditor = document.getElementById(`textEditor_${bankId}`);
            if (!textEditor) return;
            
            const bankText = textEditor.value;
            
            try {
                // Parse the edited text
                const updatedBank = parseBankData(bankId, bankText);
                
                // Update the bank
                app.banks[bankId] = updatedBank;
                
                // Exit edit mode
                app.editMode[bankId] = false;
                
                // Clear undo history
                app.undoHistory[bankId] = [];
                
                // Refresh display
                displayBankData(bankId);
                
                showToast(`Bank ${bankId} saved successfully`);
            } catch (e) {
                showToast(`Error saving bank: ${e.message}`);
                console.error(`Error saving bank:`, e);
            }
        }

        function cancelBankEdits(bankId) {
            if (hasUnsavedChanges(bankId)) {
                if (confirm("You have unsaved changes. Are you sure you want to cancel?")) {
                    app.editMode[bankId] = false;
                    app.undoHistory[bankId] = [];
                    displayBankData(bankId);
                }
            } else {
                app.editMode[bankId] = false;
                app.undoHistory[bankId] = [];
                displayBankData(bankId);
            }
        }
        
        // Check if there are unsaved changes
        function hasUnsavedChanges(bankId) {
            return app.undoHistory[bankId] && app.undoHistory[bankId].length > 0;
        }

        // Updated generateBankText function to support multi-line values
        function generateBankText(bank) {
            let text = "";
            
            // Sort registers by ID
            const registerIds = Object.keys(bank.registers).map(id => parseInt(id)).sort((a, b) => a - b);
            
            for (const registerId of registerIds) {
                const register = bank.registers[registerId];
                
                // Add register header
                text += `${registerId}\n`;
                
                // Sort addresses by ID
                const addressIds = Object.keys(register.addresses).map(id => parseInt(id)).sort((a, b) => a - b);
                
                // Add each address
                for (const addressId of addressIds) {
                    const value = register.addresses[addressId] || "";
                    
                    // Determine if this value should be multi-line
                    if (value.includes('\n')) {
                        text += `\t${addressId}\t"""\n`;
                        text += `${value}\n`;
                        text += `"""\n`;
                    } else {
                        text += `\t${addressId}\t${value}\n`;
                    }
                }
                
                // Add a blank line between registers
                text += "\n";
            }
            
            return text;
        }

        // New bank modal methods
        function showNewBankModal() {
            // Find next available bank ID
            const bankIds = Object.keys(app.banks).map(id => parseInt(id));
            const nextId = bankIds.length > 0 ? Math.max(...bankIds) + 1 : 1;
            
            // Set default values
            elements.bankId.value = nextId;
            elements.numRegisters.value = 3;
            elements.numAddresses.value = 5;
            
            // Show modal
            elements.newBankModal.style.display = "flex";
            
            // Focus first input
            setTimeout(() => elements.bankId.focus(), 0);
        }

        function hideNewBankModal() {
            elements.newBankModal.style.display = "none";
        }

        function createNewBank() {
            // Get values from form
            const bankId = parseInt(elements.bankId.value);
            const numRegisters = parseInt(elements.numRegisters.value);
            const numAddresses = parseInt(elements.numAddresses.value);
            
            // Validate inputs
            if (bankId < 1) {
                showToast("Bank ID must be a positive number");
                return;
            }
            
            if (numRegisters < 1 || numRegisters > app.maxRegisters) {
                showToast(`Number of registers must be between 1 and ${app.maxRegisters}`);
                return;
            }
            
            if (numAddresses < 1 || numAddresses > app.maxAddresses) {
                showToast(`Number of addresses must be between 1 and ${app.maxAddresses}`);
                return;
            }
            
            // Check if bank already exists
            if (app.banks[bankId]) {
                if (!confirm(`Bank ${bankId} already exists. Overwrite?`)) {
                    return;
                }
            }
            
            // Create empty bank
            const bank = {
                id: bankId,
                registers: {}
            };
            
            // Create registers and addresses
            for (let r = 1; r <= numRegisters; r++) {
                bank.registers[r] = {
                    addresses: {}
                };
                
                for (let a = 1; a <= numAddresses; a++) {
                    bank.registers[r].addresses[a] = `Value ${r}.${a}`;
                }
            }
            
            // Add a multi-line example in the first register
            if (numRegisters > 0 && numAddresses > 0) {
                bank.registers[1].addresses[1] = `This is a\nmulti-line\nvalue example\n  with preserved indentation`;
                
                // Add reference example
                if (numRegisters > 1 && numAddresses > 1) {
                    bank.registers[1].addresses[2] = `Reference example: ${bankId}.2.1`;
                }
            }
            
            // Add to app state
            app.banks[bankId] = bank;
            
            // Create tab and select it
            createBankTab(bankId);
            selectBank(bankId);
            
            // Enter edit mode
            app.editMode[bankId] = true;
            displayBankData(bankId);
            
            // Close modal
            hideNewBankModal();
            
            showToast(`Bank ${bankId} created successfully`);
        }

        // File download method for a single bank
        function downloadBank(bankId) {
            const bank = app.banks[bankId];
            if (!bank) {
                showToast(`Bank ${bankId} not found`);
                return;
            }
            
            try {
                // Generate bank content
                const content = generateBankText(bank);
                
                // Create blob
                const blob = new Blob([content], { type: 'text/plain' });
                
                // Create download link
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${bankId}.txt`;
                link.click();
                
                showToast(`Bank ${bankId} downloaded successfully`);
            } catch (e) {
                showToast(`Error downloading bank: ${e.message}`);
                console.error(`Error downloading bank:`, e);
            }
        }

        // File download method for all banks
        function downloadAllBanks() {
            const bankIds = Object.keys(app.banks);
            if (bankIds.length === 0) {
                showToast("No banks to download");
                return;
            }
            
            setStatusMessage("Creating ZIP file...");
            
            try {
                // Create a JSZip instance
                const zip = new JSZip();
                
                // Add each bank to the zip
                for (const bankId of bankIds) {
                    const bank = app.banks[bankId];
                    const content = generateBankText(bank);
                    zip.file(`${bankId}.txt`, content);
                }
                
                // Generate zip and trigger download
                zip.generateAsync({ type: "blob" }).then(function(content) {
                    // Create download link
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = "databanks.zip";
                    link.click();
                    
                    setStatusMessage("ZIP file downloaded");
                    showToast(`${bankIds.length} banks downloaded as ZIP`);
                });
            } catch (e) {
                setStatusMessage("Error creating ZIP file");
                showToast(`Failed to create ZIP file: ${e.message}`);
                console.error("Error creating ZIP:", e);
            }
        }

        function refreshAllBanks() {
            // Refresh the current bank display if any
            if (app.currentBankId !== null) {
                displayBankData(app.currentBankId);
            }
        }

        // Utility methods
        function setStatusMessage(message) {
            elements.statusBar.textContent = message;
        }

        function showToast(message) {
            // Clear any existing timeout
            if (window.toastTimeout) {
                clearTimeout(window.toastTimeout);
            }
            
            // Update toast content
            elements.toast.textContent = message;
            elements.toast.style.display = "block";
            elements.toast.classList.remove("extended");
            
            // Add animation class
            elements.toast.classList.remove("toast-fade-in");
            void elements.toast.offsetWidth; // Force reflow
            elements.toast.classList.add("toast-fade-in");
            
            // Hide toast after 3 seconds
            window.toastTimeout = setTimeout(() => {
                elements.toast.style.display = "none";
            }, 3000);
        }

        // Helper function to escape HTML
        function escapeHtml(text) {
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Auto-save feature for bank edits
        function setupAutoSave() {
            setInterval(() => {
                // Check if we're in edit mode
                if (app.currentBankId && app.editMode[app.currentBankId]) {
                    // Try to save the current state to localStorage
                    try {
                        const textEditor = document.getElementById(`textEditor_${app.currentBankId}`);
                        if (textEditor) {
                            localStorage.setItem(`bankAutoSave_${app.currentBankId}`, textEditor.value);
                        }
                    } catch (e) {
                        console.warn("Failed to auto-save:", e);
                        // Silently fail - auto-save is a convenience feature
                    }
                }
            }, 10000); // Auto-save every 10 seconds
        }

        // Add JSZip for ZIP file creation
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = function() {
            // Initialize application after JSZip is loaded
            initApp();
            setupAutoSave();
        };
        document.head.appendChild(script);
    </script>
</body>
</html>


"""
	10	"""

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Data Bank Manager - Granular Control</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --bg-color: #f9f9f9;
            --panel-bg: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --dark-border: #bbbbbb;
            --code-bg: #f0f0f0;
            --drag-color: rgba(52, 152, 219, 0.3);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1, h2, h3, h4 {
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background-color: var(--panel-bg);
            border-radius: 6px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #eaeaea;
            border-radius: 6px 6px 0 0;
            border: 1px solid var(--border-color);
            border-bottom: none;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background-color: #f5f5f5;
        }
        
        .tab.active {
            background-color: var(--panel-bg);
            position: relative;
            top: 1px;
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .flex-row {
            display: flex;
            gap: 20px;
        }
        
        .flex-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .flex-grow {
            flex: 1;
        }
        
        .scroll-container {
            overflow-y: auto;
            max-height: 600px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
        }
        
        #input-area {
            width: 100%;
            height: 300px;
            padding: 10px;
            font-size: 16px;
            font-family: monospace;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
        }
        
        .config-panels {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }
        
        .config-panel {
            background-color: #f5f7fa;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
        }
        
        .config-panel h3 {
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .config-group {
            margin-bottom: 20px;
        }
        
        .config-item {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .config-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .config-row label {
            flex: 1;
        }
        
        .config-row input[type="text"],
        .config-row input[type="number"],
        .config-row select {
            width: 180px;
        }
        
        .config-item label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .config-item input[type="text"],
        .config-item input[type="number"],
        .config-item select,
        .config-item textarea {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .config-item input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .action-row {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .btn-primary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        
        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-accent {
            background-color: var(--accent-color);
            color: white;
        }
        
        .btn-small {
            padding: 5px 10px;
            font-size: 0.8rem;
        }
        
        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            padding: 0;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 34px;
            transition: .4s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--secondary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .output-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 968px) {
            .output-container {
                grid-template-columns: 1fr;
            }
            
            .config-panels {
                grid-template-columns: 1fr;
            }
            
            .flex-row {
                flex-direction: column;
            }
        }
        
        .output-panel {
            height: 400px;
            overflow: auto;
            white-space: pre-wrap;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            background-color: #f8f9fa;
        }
        
        .collapsible {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .collapsible::after {
            content: '\25BC';
            margin-left: 10px;
            font-size: 0.8em;
        }
        
        .collapsed::after {
            content: '\25B6';
        }
        
        .collapsible-content {
            display: block;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsed + .collapsible-content {
            display: none;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, opacity 0.3s;
            transform: translateY(-100px);
            opacity: 0;
            z-index: 1000;
        }
        
        .toast.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        .toast.success {
            background-color: var(--success-color);
        }
        
        .toast.error {
            background-color: var(--accent-color);
        }
        
        .toast.warning {
            background-color: var(--warning-color);
        }
        
        code {
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .code-editor {
            width: 100%;
            height: 150px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            resize: vertical;
        }
        
        .preview-container {
            margin-top: 20px;
            position: relative;
        }
        
        .preview-toolbar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .pagination {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .pagination button {
            padding: 5px 10px;
        }
        
        .visualization {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 4px;
            background-color: white;
            min-height: 200px;
        }
        
        .bank-preview {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 10px;
            padding: 10px;
        }
        
        .register-preview {
            margin-left: 20px;
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid var(--secondary-color);
        }
        
        .address-preview {
            margin-left: 40px;
            font-family: monospace;
            padding: 2px 5px;
        }
        
        /* Progress bar styles */
        .progress-container {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary-color);
            width: 0;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            line-height: 20px;
            text-align: center;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        /* Token editor styles */
        .token-editor {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            background-color: white;
        }
        
        .token-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .token-item:last-child {
            border-bottom: none;
        }
        
        .token-item:hover {
            background-color: #f5f5f5;
        }
        
        .token-controls {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }
        
        .token-text {
            flex: 1;
            padding: 5px;
            font-family: monospace;
        }
        
        .token-text.editable {
            border: 1px dashed var(--secondary-color);
            border-radius: 3px;
        }
        
        /* Bank structure editor */
        .bank-structure-editor {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
        }
        
        .bank-container {
            border: 1px solid var(--dark-border);
            border-radius: 4px;
            padding: 10px;
        }
        
        .bank-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 3px;
            margin-bottom: 10px;
        }
        
        .registers-container {
            padding-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .register-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
        }
        
        .register-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #f8f8f8;
            padding: 5px;
            border-radius: 3px;
            margin-bottom: 8px;
        }
        
        .addresses-container {
            padding-left: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .address-item {
            display: flex;
            align-items: center;
            padding: 3px;
            border-radius: 3px;
        }
        
        .address-item:hover {
            background-color: #f0f0f0;
        }
        
        .address-id {
            width: 40px;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .address-value {
            flex: 1;
            font-family: monospace;
            padding: 3px;
        }
        
        .address-controls {
            display: flex;
            gap: 5px;
        }
        
        /* Draggable items */
        .draggable {
            cursor: grab;
        }
        
        .draggable:active {
            cursor: grabbing;
        }
        
        .dragging {
            opacity: 0.5;
        }
        
        .drag-over {
            background-color: var(--drag-color);
        }
        
        /* Table styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        .data-table th, 
        .data-table td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }
        
        .data-table th {
            background-color: #f0f0f0;
            font-weight: bold;
        }
        
        /* Reference map visualization */
        .reference-map {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            max-height: 500px;
            overflow: auto;
        }
        
        .reference-item {
            display: flex;
            padding: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .reference-token {
            flex: 1;
            font-family: monospace;
        }
        
        .reference-path {
            color: var(--secondary-color);
            font-weight: bold;
            margin-left: 10px;
        }
        
        /* Token distribution visualization */
        .token-distribution {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .token-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .token-bar-label {
            width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .token-bar-container {
            flex: 1;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .token-bar-value {
            height: 100%;
            background-color: var(--secondary-color);
        }
        
        .token-bar-count {
            width: 50px;
            text-align: right;
        }
        
        /* Advanced mode toggle */
        .advanced-toggle {
            margin: 15px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* File drop zone */
        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            transition: border-color 0.3s;
        }
        
        .drop-zone.drag-over {
            border-color: var(--secondary-color);
            background-color: rgba(52, 152, 219, 0.1);
        }
        
        /* Tabs for panel views */
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }
        
        .panel-tab {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        
        .panel-tab.active {
            border: 1px solid var(--border-color);
            border-bottom-color: white;
            border-radius: 4px 4px 0 0;
            margin-bottom: -1px;
            font-weight: bold;
        }
        
        .panel-content {
            display: none;
        }
        
        .panel-content.active {
            display: block;
        }
        
        /* Custom slider */
        .range-slider {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .range-slider input[type="range"] {
            flex: 1;
        }
        
        .range-value {
            width: 50px;
            text-align: center;
            font-weight: bold;
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }
        
        .tooltip .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Processing pipeline visualization */
        .pipeline-flow {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .pipeline-stage {
            border: 1px solid var(--dark-border);
            border-radius: 4px;
            padding: 10px;
        }
        
        .pipeline-stage-header {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .pipeline-stage-content {
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .pipeline-arrow {
            text-align: center;
            font-size: 1.5rem;
            color: var(--secondary-color);
        }
        
        /* Split view */
        .split-view {
            display: flex;
            gap: 20px;
        }
        
        .split-view-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .split-view-header {
            font-weight: bold;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        
        .split-view-content {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            flex: 1;
            overflow: auto;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="panel">
            <h1>Advanced Data Bank Manager - Granular Control</h1>
            <p>The ultimate toolkit for precise data organization and referential mapping with complete control over every aspect of processing.</p>
            
            <div class="advanced-toggle">
                <span>Advanced Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="advanced-mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <div class="panel">
            <div class="tabs">
                <div class="tab active" data-tab="input">Input</div>
                <div class="tab" data-tab="token-extraction">Token Extraction</div>
                <div class="tab" data-tab="bank-structure">Bank Structure</div>
                <div class="tab" data-tab="reference-generation">Reference Generation</div>
                <div class="tab" data-tab="advanced-processing">Advanced Processing</div>
                <div class="tab" data-tab="output">Output</div>
                <div class="tab" data-tab="visualization">Visualization</div>
            </div>
            
            <!-- Input Tab -->
            <div id="input-tab" class="tab-content active">
                <h2>Text Input</h2>
                <p>Paste your text content here to process into structured Data Banks with granular control.</p>
                
                <div class="flex-row">
                    <div class="flex-column flex-grow">
                        <textarea id="input-area" placeholder="Enter text content to process..."></textarea>
                        
                        <div class="drop-zone" id="file-drop-zone">
                            <p>Drag and drop text files here or</p>
                            <button id="upload-txt-btn" class="btn-secondary">Browse Files</button>
                            <input type="file" id="file-upload" accept=".txt,.md,.csv,.json,.xml,.html" multiple style="display: none;">
                        </div>
                        
                        <div class="action-row">
                            <button id="load-sample-btn" class="btn-secondary">Load Sample</button>
                            <button id="parse-btn" class="btn-primary">Parse Text</button>
                            <button id="clear-btn" class="btn-secondary">Clear</button>
                        </div>
                    </div>
                    
                    <div class="flex-column" style="width: 40%;">
                        <div class="config-panel">
                            <h3>Input Options</h3>
                            
                            <div class="config-item">
                                <label for="input-encoding">Text Encoding:</label>
                                <select id="input-encoding">
                                    <option value="UTF-8">UTF-8</option>
                                    <option value="ASCII">ASCII</option>
                                    <option value="ISO-8859-1">ISO-8859-1</option>
                                    <option value="Windows-1252">Windows-1252</option>
                                </select>
                            </div>
                            
                            <div class="config-item">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="normalize-newlines" checked>
                                    Normalize Line Endings
                                </label>
                                <div class="tooltip">
                                    <span class="tooltip-icon">?</span>
                                    <span class="tooltip-text">Convert all line endings (CR, LF, CRLF) to standard format</span>
                                </div>
                            </div>
                            
                            <div class="config-item">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="trim-whitespace" checked>
                                    Trim Leading/Trailing Whitespace
                                </label>
                            </div>
                            
                            <div class="config-item">
                                <label for="input-preprocessor">Pre-processing Function:</label>
                                <div class="tooltip">
                                    <span class="tooltip-icon">?</span>
                                    <span class="tooltip-text">Custom JavaScript function to pre-process text before tokenization. Input parameter is 'text', must return processed text.</span>
                                </div>
                                <textarea id="input-preprocessor" class="code-editor">// Optional pre-processing function
function(text) {
  // Example: Replace multiple spaces with single space
  return text.replace(/\s+/g, ' ');
}</textarea>
                            </div>
                        </div>
                        
                        <div id="input-stats" class="config-panel" style="display: none;">
                            <h3>Input Statistics</h3>
                            <div id="stats-content"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Token Extraction Tab -->
            <div id="token-extraction-tab" class="tab-content">
                <h2>Token Extraction</h2>
                <p>Define exactly how your text should be broken down into tokens with granular control over extraction methods.</p>
                
                <div class="flex-row">
                    <div class="flex-column flex-grow">
                        <div class="config-panel">
                            <h3 class="collapsible">Tokenization Configuration</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label for="token-type">Token Type:</label>
                                        <select id="token-type">
                                            <option value="word">Words (space-separated)</option>
                                            <option value="sentence">Sentences</option>
                                            <option value="paragraph">Paragraphs</option>
                                            <option value="character">Characters</option>
                                            <option value="line">Lines</option>
                                            <option value="ngram">N-Grams</option>
                                            <option value="regex">Regular Expression</option>
                                            <option value="custom">Custom Function</option>
                                        </select>
                                    </div>
                                    
                                    <div id="ngram-options" class="config-item" style="display: none;">
                                        <label for="ngram-size">N-Gram Size:</label>
                                        <input type="number" id="ngram-size" min="1" max="10" value="2">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Number of consecutive words to include in each token</span>
                                        </div>
                                    </div>
                                    
                                    <div id="regex-container" class="config-item" style="display: none;">
                                        <label for="custom-regex">Regular Expression Pattern:</label>
                                        <input type="text" id="custom-regex" placeholder="\b\w+\b">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Regular expression to match tokens. Include capturing groups if needed.</span>
                                        </div>
                                    </div>
                                    
                                    <div id="custom-tokenizer-container" class="config-item" style="display: none;">
                                        <label for="custom-tokenizer">Custom Tokenizer Function:</label>
                                        <textarea id="custom-tokenizer" class="code-editor">// Custom tokenization function
function(text) {
  // Split text however you want
  const tokens = text.split(/\s+/);
  
  // Return array of token objects with positions
  return tokens.map((token, index) => ({
    token: token,
    index: text.indexOf(token, index > 0 ? tokens[index-1].index + tokens[index-1].length : 0),
    length: token.length
  }));
}</textarea>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="ignore-case">Case Sensitivity:</label>
                                        <select id="ignore-case">
                                            <option value="true">Case Insensitive</option>
                                            <option value="false">Case Sensitive</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Token Filtering & Transformation</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="remove-punctuation" checked>
                                            Remove Punctuation
                                        </label>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="normalize-whitespace" checked>
                                            Normalize Whitespace
                                        </label>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="lowercase-tokens">
                                            Convert to Lowercase
                                        </label>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="min-token-length">Minimum Token Length:</label>
                                        <input type="number" id="min-token-length" min="1" value="1">
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="max-token-length">Maximum Token Length:</label>
                                        <input type="number" id="max-token-length" min="1" value="100">
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="token-exclude-pattern">Exclude Pattern (regex):</label>
                                        <input type="text" id="token-exclude-pattern" placeholder="^(a|the|of)$">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Regular expression pattern for tokens to exclude</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="stop-words">Stop Words (comma-separated):</label>
                                        <textarea id="stop-words" rows="3" placeholder="a, an, the, in, on, at, to"></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Advanced Token Processing</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label for="stemming-algorithm">Word Stemming:</label>
                                        <select id="stemming-algorithm">
                                            <option value="none">None</option>
                                            <option value="porter">Porter Stemmer</option>
                                            <option value="lancaster">Lancaster Stemmer</option>
                                            <option value="snowball">Snowball Stemmer</option>
                                        </select>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Reduce words to their root form (e.g., "running" â†’ "run")</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="remove-numbers">
                                            Remove Numeric Tokens
                                        </label>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="token-transformer">Custom Token Transformer:</label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Custom JavaScript function to transform tokens. Parameter is 'token', return the transformed token.</span>
                                        </div>
                                        <textarea id="token-transformer" class="code-editor">// Optional token transformation
function(token) {
  // Example: Replace special characters
  return token.replace(/[^\w\s]/g, '');
}</textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex-column" style="width: 40%;">
                        <div class="panel">
                            <h3>Token Preview</h3>
                            <p>Extracted tokens based on current settings:</p>
                            
                            <div class="action-row">
                                <button id="extract-tokens-btn" class="btn-primary">Extract Tokens</button>
                                <button id="edit-tokens-btn" class="btn-secondary">Edit Tokens</button>
                                <button id="save-tokens-btn" class="btn-success" disabled>Save Changes</button>
                            </div>
                            
                            <div class="token-stats" id="token-stats"></div>
                            
                            <div class="scroll-container">
                                <div class="token-editor" id="token-editor"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-row">
                    <button id="continue-to-bank-structure" class="btn-primary">Continue to Bank Structure</button>
                </div>
            </div>
            
            <!-- Bank Structure Tab -->
            <div id="bank-structure-tab" class="tab-content">
                <h2>Bank Structure Configuration</h2>
                <p>Define how tokens will be organized into banks, registers, and addresses with precise control.</p>
                
                <div class="flex-row">
                    <div class="flex-column flex-grow">
                        <div class="config-panel">
                            <h3 class="collapsible">Structure Parameters</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-row">
                                        <label for="max-banks">Maximum Number of Banks:</label>
                                        <input type="number" id="max-banks" min="1" value="10">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Maximum number of banks to create</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="max-registers">Maximum Registers per Bank:</label>
                                        <input type="number" id="max-registers" min="1" value="10">
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="max-addresses">Maximum Addresses per Register:</label>
                                        <input type="number" id="max-addresses" min="1" value="20">
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="bank-numbering">Bank Numbering:</label>
                                        <select id="bank-numbering">
                                            <option value="sequential">Sequential (1, 2, 3...)</option>
                                            <option value="powers-of-ten">Powers of Ten (10, 100, 1000...)</option>
                                            <option value="prime">Prime Numbers (2, 3, 5, 7...)</option>
                                            <option value="custom">Custom Numbering</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-bank-numbering" class="config-item" style="display: none;">
                                        <label for="custom-bank-numbers">Custom Bank Numbers (comma-separated):</label>
                                        <input type="text" id="custom-bank-numbers" placeholder="1, 5, 10, 20, 50">
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="register-numbering">Register Numbering:</label>
                                        <select id="register-numbering">
                                            <option value="sequential">Sequential (1, 2, 3...)</option>
                                            <option value="category">By Category (distinct numeric groups)</option>
                                            <option value="custom">Custom Numbering</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Organization Strategy</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-row">
                                        <label for="organization-strategy">Primary Organization Strategy:</label>
                                        <select id="organization-strategy">
                                            <option value="sequential">Sequential (Fill in order)</option>
                                            <option value="frequency">By Frequency (Common tokens first)</option>
                                            <option value="alphabetical">Alphabetical</option>
                                            <option value="length">By Length</option>
                                            <option value="semantic">Semantic Grouping</option>
                                            <option value="random">Random Distribution</option>
                                            <option value="custom">Custom Organization</option>
                                        </select>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="bank-allocation-strategy">Bank Allocation Strategy:</label>
                                        <select id="bank-allocation-strategy">
                                            <option value="fill">Fill Each Bank Completely</option>
                                            <option value="distribute">Distribute Evenly Across Banks</option>
                                            <option value="category">Group by Categories</option>
                                            <option value="similarity">Group by Similarity</option>
                                            <option value="custom">Custom Allocation</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-allocation-function" class="config-item" style="display: none;">
                                        <label for="allocation-function">Custom Allocation Function:</label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Custom JavaScript function to determine bank and register for each token. Parameters are 'token' and 'index', return {bank, register, address}.</span>
                                        </div>
                                        <textarea id="allocation-function" class="code-editor">// Custom allocation function
function(token, index) {
  // Example: Allocate based on first letter
  const firstChar = token.token.charAt(0).toLowerCase();
  const bankId = Math.min(Math.floor((firstChar.charCodeAt(0) - 97) / 3) + 1, 10);
  const registerId = (index % 10) + 1;
  
  return {
    bank: bankId,
    register: registerId,
    address: null  // Let the system assign addresses sequentially
  };
}</textarea>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="fill-strategy">Register Fill Strategy:</label>
                                        <select id="fill-strategy">
                                            <option value="sequential">Fill Sequentially</option>
                                            <option value="round-robin">Round-Robin</option>
                                            <option value="balanced">Balance Token Distribution</option>
                                        </select>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="address-assignment">Address Assignment:</label>
                                        <select id="address-assignment">
                                            <option value="sequential">Sequential Assignment</option>
                                            <option value="semantic">Semantic Position</option>
                                            <option value="frequency">By Frequency</option>
                                            <option value="hash">Hash-Based</option>
                                            <option value="custom">Custom Assignment</option>
                                        </select>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="deduplicate-tokens" checked>
                                            Deduplicate Tokens
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Store each unique token only once in the bank structure</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="optimize-space" checked>
                                            Optimize Space Utilization
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Minimize empty addresses and registers by compacting the structure</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="reserve-special-addresses">
                                            Reserve Special Addresses
                                        </label>
                                    </div>
                                    
                                    <div id="special-addresses-container" class="config-item" style="display: none;">
                                        <label for="special-addresses">Special Address Reservations (JSON):</label>
                                        <textarea id="special-addresses" rows="5" placeholder='[{"bank": 1, "register": 1, "address": 1, "value": "HEADER"}, {"bank": 1, "register": 1, "address": 2, "value": "VERSION"}]'></textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Token Classification</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="enable-classification">
                                            Enable Token Classification
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Group tokens by classes/categories for better organization</span>
                                        </div>
                                    </div>
                                    
                                    <div id="classification-options" style="display: none;">
                                        <div class="config-item">
                                            <label for="classification-method">Classification Method:</label>
                                            <select id="classification-method">
                                                <option value="length">By Length</option>
                                                <option value="pos">Part of Speech</option>
                                                <option value="regex">Regular Expression Patterns</option>
                                                <option value="semantic">Semantic Analysis</option>
                                                <option value="custom">Custom Classification</option>
                                            </select>
                                        </div>
                                        
                                        <div id="custom-classifier-container" class="config-item" style="display: none;">
                                            <label for="custom-classifier">Custom Classification Function:</label>
                                            <textarea id="custom-classifier" class="code-editor">// Custom classification function
function(token) {
  // Return a category string for the token
  if (token.token.length <= 3) return 'short';
  if (token.token.length >= 8) return 'long';
  if (/^[A-Z]/.test(token.token)) return 'capitalized';
  if (/^\d+$/.test(token.token)) return 'numeric';
  return 'medium';
}</textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex-column" style="width: 40%;">
                        <div class="panel">
                            <h3>Bank Structure Designer</h3>
                            
                            <div class="panel-tabs">
                                <div class="panel-tab active" data-panel="automatic">Automatic</div>
                                <div class="panel-tab" data-panel="manual">Manual</div>
                                <div class="panel-tab" data-panel="hybrid">Hybrid</div>
                            </div>
                            
                            <div id="automatic-panel" class="panel-content active">
                                <p>Preview the generated bank structure based on current settings:</p>
                                <button id="generate-structure-btn" class="btn-primary">Generate Structure</button>
                                
                                <div class="structure-preview" id="structure-preview">
                                    <p>Bank structure will be displayed here after generation.</p>
                                </div>
                            </div>
                            
                            <div id="manual-panel" class="panel-content">
                                <p>Manually define your bank structure:</p>
                                
                                <div class="action-row">
                                    <button id="add-bank-btn" class="btn-secondary">Add Bank</button>
                                    <button id="clear-structure-btn" class="btn-secondary">Clear All</button>
                                    <button id="save-structure-btn" class="btn-success">Save Structure</button>
                                </div>
                                
                                <div class="scroll-container">
                                    <div class="bank-structure-editor" id="bank-structure-editor">
                                        <p>Use the controls above to build your bank structure.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="hybrid-panel" class="panel-content">
                                <p>Start with an automatic structure, then modify it manually:</p>
                                
                                <div class="action-row">
                                    <button id="generate-hybrid-btn" class="btn-primary">Generate Base Structure</button>
                                    <button id="save-hybrid-btn" class="btn-success">Save Modified Structure</button>
                                </div>
                                
                                <div class="scroll-container">
                                    <div class="bank-structure-editor" id="hybrid-structure-editor">
                                        <p>Generate a base structure first, then modify it.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="panel">
                            <h3>Token Distribution Analysis</h3>
                            <div class="token-distribution" id="token-distribution">
                                <p>Generate a structure to see token distribution analysis.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-row">
                    <button id="continue-to-references" class="btn-primary">Continue to Reference Generation</button>
                </div>
            </div>
            
            <!-- Reference Generation Tab -->
            <div id="reference-generation-tab" class="tab-content">
                <h2>Reference Generation Configuration</h2>
                <p>Configure how references will be generated, formatted, and used throughout your data structure.</p>
                
                <div class="flex-row">
                    <div class="flex-column flex-grow">
                        <div class="config-panel">
                            <h3 class="collapsible">Reference Format</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-row">
                                        <label for="reference-format">Primary Reference Format:</label>
                                        <select id="reference-format">
                                            <option value="standard">Standard (Bank.Register.Address)</option>
                                            <option value="compact">Compact (B:R:A)</option>
                                            <option value="coded">Coded (Hexadecimal)</option>
                                            <option value="base64">Base64 Encoded</option>
                                            <option value="custom">Custom Format</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-format-container" class="config-item" style="display: none;">
                                        <label for="custom-format">Custom Format Template:</label>
                                        <input type="text" id="custom-format" placeholder="{b}-{r}-{a}">
                                        <p class="helper-text">Use {b} for bank, {r} for register, {a} for address</p>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="formatting-style">Formatting Style:</label>
                                        <select id="formatting-style">
                                            <option value="plain">Plain Text</option>
                                            <option value="html">HTML Links</option>
                                            <option value="markdown">Markdown Links</option>
                                            <option value="bracketed">Bracketed ([1.2.3])</option>
                                            <option value="custom">Custom Formatter</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-formatter-container" class="config-item" style="display: none;">
                                        <label for="custom-formatter">Custom Format Function:</label>
                                        <textarea id="custom-formatter" class="code-editor">// Custom reference formatter
function(ref) {
  // ref has properties: bank, register, address
  return `REF(${ref.bank},${ref.register},${ref.address})`;
}</textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Reference Strategy</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-row">
                                        <label for="reference-strategy">Reference Strategy:</label>
                                        <select id="reference-strategy">
                                            <option value="direct">Direct (Replace with references)</option>
                                            <option value="hybrid">Hybrid (Keep first occurrence, reference others)</option>
                                            <option value="dictionary">Dictionary (Keep all tokens, add reference map)</option>
                                            <option value="contextual">Contextual (Reference based on context)</option>
                                            <option value="selective">Selective (Reference specific tokens)</option>
                                            <option value="custom">Custom Strategy</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-strategy-container" class="config-item" style="display: none;">
                                        <label for="custom-strategy">Custom Strategy Function:</label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Custom JavaScript function to determine if a token should be referenced. Parameters are 'token', 'occurrence', and 'context'. Return true to reference the token.</span>
                                        </div>
                                        <textarea id="custom-strategy" class="code-editor">// Custom reference strategy
function(token, occurrence, context) {
  // Example: Reference only after first occurrence and 
  // if token length > 5 characters
  return occurrence > 0 && token.token.length > 5;
}</textarea>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="ref-min-length">Minimum Token Length for References:</label>
                                        <input type="number" id="ref-min-length" min="1" value="3">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Only tokens longer than this will be referenced</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="ref-min-occurrences">Minimum Occurrences for Reference:</label>
                                        <input type="number" id="ref-min-occurrences" min="2" value="2">
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Only tokens that appear this many times will be referenced</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="enable-selective-reference">
                                            Enable Selective Reference Patterns
                                        </label>
                                    </div>
                                    
                                    <div id="selective-patterns-container" class="config-item" style="display: none;">
                                        <label for="selective-patterns">Selective Reference Patterns (one per line):</label>
                                        <textarea id="selective-patterns" rows="5" placeholder="important\s+\w+\ndata\s+bank\nreference"></textarea>
                                        <p class="helper-text">Regular expressions for phrases that should always be referenced</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Advanced Reference Options</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="enable-nested-references">
                                            Enable Nested References
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Allow references to contain other references</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="enable-circular-detection" checked>
                                            Detect and Prevent Circular References
                                        </label>
                                    </div>
                                    
                                    <div class="config-row">
                                        <label for="nested-depth-limit">Maximum Nesting Depth:</label>
                                        <input type="number" id="nested-depth-limit" min="1" value="3">
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="cache-resolved-references" checked>
                                            Cache Resolved References
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Store resolved reference values for better performance</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="ref-conflict-strategy">Reference Conflict Strategy:</label>
                                        <select id="ref-conflict-strategy">
                                            <option value="first">Use First Occurrence</option>
                                            <option value="last">Use Last Occurrence</option>
                                            <option value="shortest">Use Shortest Path</option>
                                            <option value="custom">Custom Resolution</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-conflict-resolver" class="config-item" style="display: none;">
                                        <label for="conflict-resolver">Custom Conflict Resolution:</label>
                                        <textarea id="conflict-resolver" class="code-editor">// Custom conflict resolver
function(references) {
  // references is an array of potential references
  // Choose which one to use (return the chosen reference)
  
  // Example: Choose the reference with the lowest bank number
  return references.reduce((best, ref) => 
    ref.bank < best.bank ? ref : best
  , references[0]);
}</textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex-column" style="width: 40%;">
                        <div class="panel">
                            <h3>Reference Preview</h3>
                            
                            <div class="panel-tabs">
                                <div class="panel-tab active" data-panel="reference-map">Reference Map</div>
                                <div class="panel-tab" data-panel="reference-text">Referenced Text</div>
                                <div class="panel-tab" data-panel="reference-graph">Reference Graph</div>
                            </div>
                            
                            <div id="reference-map-panel" class="panel-content active">
                                <div class="action-row">
                                    <button id="generate-references-btn" class="btn-primary">Generate References</button>
                                </div>
                                
                                <div class="reference-map" id="reference-map">
                                    <p>Generate references to see the mapping.</p>
                                </div>
                            </div>
                            
                            <div id="reference-text-panel" class="panel-content">
                                <p>Preview of text with references applied:</p>
                                <div class="scroll-container" id="reference-text-preview">
                                    <p>Generate references to see the referenced text.</p>
                                </div>
                            </div>
                            
                            <div id="reference-graph-panel" class="panel-content">
                                <p>Visual graph of reference relationships:</p>
                                <div class="visualization" id="reference-graph">
                                    <p>Generate references to see the reference graph.</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="panel">
                            <h3>Reference Statistics</h3>
                            <div id="reference-stats">
                                <p>Generate references to see statistics.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-row">
                    <button id="continue-to-advanced" class="btn-primary">Continue to Advanced Processing</button>
                </div>
            </div>
            
            <!-- Advanced Processing Tab -->
            <div id="advanced-processing-tab" class="tab-content">
                <h2>Advanced Processing Configuration</h2>
                <p>Fine-tune advanced processing options for optimizing your data bank structure and references.</p>
                
                <div class="flex-row">
                    <div class="flex-column flex-grow">
                        <div class="config-panel">
                            <h3 class="collapsible">Optimization Settings</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-row">
                                        <label for="compression-level">Compression Level:</label>
                                        <select id="compression-level">
                                            <option value="none">None</option>
                                            <option value="low">Low - Basic Optimization</option>
                                            <option value="medium" selected>Medium - Better Compression</option>
                                            <option value="high">High - Maximum Compression</option>
                                            <option value="custom">Custom Optimization</option>
                                        </select>
                                    </div>
                                    
                                    <div id="custom-compression-container" class="config-item" style="display: none;">
                                        <label for="compression-settings">Custom Compression Settings:</label>
                                        <textarea id="compression-settings" rows="5" placeholder='{"deduplication": true, "compactStructure": true, "minReferenceLength": 5, "useShorterPaths": true}'></textarea>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="optimize-reference-paths" checked>
                                            Optimize Reference Paths
                                        </label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Find the shortest paths for references to minimize path length</span>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="balance-bank-usage">
                                            Balance Bank Usage
                                        </label>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="minimize-fragmentation" checked>
                                            Minimize Fragmentation
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Metadata & Documentation</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="add-metadata" checked>
                                            Include Metadata
                                        </label>
                                    </div>
                                    
                                    <div id="metadata-options" class="config-item">
                                        <label for="metadata-fields">Metadata Fields to Include:</label>
                                        <div class="checkbox-group">
                                            <label class="checkbox-label">
                                                <input type="checkbox" name="metadata-field" value="timestamp" checked>
                                                Timestamp
                                            </label>
                                            <label class="checkbox-label">
                                                <input type="checkbox" name="metadata-field" value="config" checked>
                                                Configuration
                                            </label>
                                            <label class="checkbox-label">
                                                <input type="checkbox" name="metadata-field" value="stats" checked>
                                                Statistics
                                            </label>
                                            <label class="checkbox-label">
                                                <input type="checkbox" name="metadata-field" value="version" checked>
                                                Version
                                            </label>
                                            <label class="checkbox-label">
                                                <input type="checkbox" name="metadata-field" value="source">
                                                Source File Info
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label for="custom-metadata">Custom Metadata (JSON):</label>
                                        <textarea id="custom-metadata" rows="5" placeholder='{"author": "Your Name", "project": "Data Bank Demo", "purpose": "Example text analysis"}'></textarea>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="include-documentation" checked>
                                            Generate Documentation
                                        </label>
                                    </div>
                                    
                                    <div id="documentation-options" class="config-item">
                                        <label for="doc-format">Documentation Format:</label>
                                        <select id="doc-format">
                                            <option value="markdown">Markdown</option>
                                            <option value="html">HTML</option>
                                            <option value="text">Plain Text</option>
                                            <option value="json">JSON</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Multi-line Value Configuration</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="preserve-multiline">
                                            Preserve Multi-line Values
                                        </label>
                                    </div>
                                    
                                    <div id="multiline-options" class="config-item" style="display: none;">
                                        <label for="multiline-delimiter">Multi-line Delimiter:</label>
                                        <input type="text" id="multiline-delimiter" value='"""'>
                                        <p class="helper-text">Characters that mark the beginning and end of a multi-line value</p>
                                        
                                        <div class="config-item">
                                            <label class="checkbox-label">
                                                <input type="checkbox" id="normalize-indentation" checked>
                                                Normalize Indentation
                                            </label>
                                        </div>
                                        
                                        <div class="config-item">
                                            <label class="checkbox-label">
                                                <input type="checkbox" id="preserve-empty-lines" checked>
                                                Preserve Empty Lines
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="config-panel">
                            <h3 class="collapsible">Custom Processing Pipeline</h3>
                            <div class="collapsible-content">
                                <div class="config-group">
                                    <div class="config-item">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="enable-custom-pipeline">
                                            Enable Custom Processing Pipeline
                                        </label>
                                    </div>
                                    
                                    <div id="pipeline-config" class="config-item" style="display: none;">
                                        <label for="custom-pipeline">Custom Processing Steps:</label>
                                        <div class="tooltip">
                                            <span class="tooltip-icon">?</span>
                                            <span class="tooltip-text">Define custom processing steps that run in sequence. Each function receives and should return the processed data.</span>
                                        </div>
                                        <textarea id="custom-pipeline" class="code-editor" rows="10">// Custom processing pipeline functions
[
  {
    name: "Remove Specific Tokens",
    process: function(data) {
      // Filter out unwanted tokens
      data.tokens = data.tokens.filter(t => 
        !['a', 'the', 'of'].includes(t.token.toLowerCase())
      );
      return data;
    }
  },
  {
    name: "Add Special References",
    process: function(data) {
      // Add special reference to first token
      if (data.tokens.length > 0) {
        data.tokens[0].specialRef = true;
      }
      return data;
    }
  }
]</textarea>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex-column" style="width: 40%;">
                        <div class="panel">
                            <h3>Processing Pipeline Visualization</h3>
                            
                            <div class="action-row">
                                <button id="test-pipeline-btn" class="btn-primary">Test Processing Pipeline</button>
                                <button id="apply-pipeline-btn" class="btn-success">Apply Pipeline</button>
                            </div>
                            
                            <div class="pipeline-flow" id="pipeline-visualization">
                                <p>Test the pipeline to see a visualization of the processing steps.</p>
                            </div>
                        </div>
                        
                        <div class="panel">
                            <h3>Optimization Preview</h3>
                            
                            <div class="panel-tabs">
                                <div class="panel-tab active" data-panel="size-comparison">Size Comparison</div>
                                <div class="panel-tab" data-panel="efficiency-metrics">Efficiency Metrics</div>
                            </div>
                            
                            <div id="size-comparison-panel" class="panel-content active">
                                <p>Size comparison between original and optimized data:</p>
                                
                                <div class="progress-container">
                                    <div class="progress-bar" id="original-size-bar" style="width: 100%"></div>
                                    <div class="progress-text">Original: <span id="original-size">0</span> bytes</div>
                                </div>
                                
                                <div class="progress-container">
                                    <div class="progress-bar" id="optimized-size-bar" style="width: 70%"></div>
                                    <div class="progress-text">Optimized: <span id="optimized-size">0</span> bytes</div>
                                </div>
                                
                                <p>Compression Ratio: <span id="compression-ratio">0</span>%</p>
                            </div>
                            
                            <div id="efficiency-metrics-panel" class="panel-content">
                                <p>Efficiency metrics based on current configuration:</p>
                                <div id="efficiency-metrics">
                                    <p>Apply the pipeline to see efficiency metrics.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-row">
                    <button id="continue-to-output" class="btn-primary">Continue to Output</button>
                </div>
            </div>
            
            <!-- Output Tab -->
            <div id="output-tab" class="tab-content">
                <h2>Generated Output</h2>
                <p>Review, download and export your processed data in various formats.</p>
                
                <div class="action-row">
                    <button id="process-final-btn" class="btn-primary">Process with All Settings</button>
                    <select id="output-format">
                        <option value="structured">Structured Bank Format</option>
                        <option value="referenced">Referenced Text Format</option>
                        <option value="all">Complete Package</option>
                    </select>
                </div>
                
                <div class="output-container">
                    <div class="output-panel-container">
                        <h3>Structured Data (JSON)</h3>
                        <div id="json-output" class="output-panel"></div>
                        
                        <div class="action-row">
                            <button id="download-json-btn" class="btn-secondary" disabled>Download JSON</button>
                            <button id="copy-json-btn" class="btn-secondary" disabled>Copy JSON</button>
                        </div>
                    </div>
                    
                    <div class="output-panel-container">
                        <h3>Bank Format</h3>
                        <div id="bank-output" class="output-panel"></div>
                        
                        <div class="action-row">
                            <button id="download-txt-btn" class="btn-secondary" disabled>Download TXT</button>
                            <button id="copy-txt-btn" class="btn-secondary" disabled>Copy TXT</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>Output Package</h3>
                    <p>Download all generated files and documentation as a complete package:</p>
                    
                    <div class="config-item">
                        <label for="package-name">Package Name:</label>
                        <input type="text" id="package-name" value="data_bank_package">
                    </div>
                    
                    <div class="config-item">
                        <label for="included-files">Include in Package:</label>
                        <div class="checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="banks" checked>
                                Bank Files
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="json" checked>
                                JSON Structure
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="referenced" checked>
                                Referenced Text
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="docs" checked>
                                Documentation
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="config" checked>
                                Configuration
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="package-item" value="stats" checked>
                                Statistics Report
                            </label>
                        </div>
                    </div>
                    
                    <div class="action-row">
                        <button id="download-zip-btn" class="btn-primary" disabled>Download Complete Package</button>
                    </div>
                </div>
                
                <div id="compression-stats" class="panel" style="display: none;">
                    <h3>Final Statistics</h3>
                    <div id="compression-content"></div>
                </div>
            </div>
            
            <!-- Visualization Tab -->
            <div id="visualization-tab" class="tab-content">
                <h2>Data Visualization</h2>
                <p>Interactive visualizations to help you understand your data structure and references.</p>
                
                <div class="panel-tabs">
                    <div class="panel-tab active" data-panel="bank-viz">Bank Structure</div>
                    <div class="panel-tab" data-panel="reference-viz">Reference Graph</div>
                    <div class="panel-tab" data-panel="token-viz">Token Distribution</div>
                    <div class="panel-tab" data-panel="process-viz">Processing Pipeline</div>
                </div>
                
                <div id="bank-viz-panel" class="panel-content active">
                    <div class="preview-toolbar">
                        <div class="view-controls">
                            <select id="preview-level">
                                <option value="overview">Overview</option>
                                <option value="detailed">Detailed View</option>
                                <option value="references">References View</option>
                                <option value="heatmap">Usage Heatmap</option>
                            </select>
                        </div>
                        
                        <div class="pagination">
                            <button id="prev-bank" class="btn-secondary" disabled>&lt;</button>
                            <span id="bank-indicator">Bank: 1 / 1</span>
                            <button id="next-bank" class="btn-secondary" disabled>&gt;</button>
                        </div>
                    </div>
                    
                    <div class="visualization" id="bank-visualization">
                        <p>Process your data first to see the visualization.</p>
                    </div>
                </div>
                
                <div id="reference-viz-panel" class="panel-content">
                    <div class="split-view">
                        <div class="split-view-panel">
                            <div class="split-view-header">Reference Network</div>
                            <div class="split-view-content" id="reference-network">
                                <p>Network visualization of references will appear here.</p>
                            </div>
                        </div>
                        
                        <div class="split-view-panel">
                            <div class="split-view-header">Reference Details</div>
                            <div class="split-view-content" id="reference-details">
                                <p>Select a reference in the network to see details.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="token-viz-panel" class="panel-content">
                    <div class="panel">
                        <h3>Token Distribution</h3>
                        <div id="token-distribution-viz">
                            <p>Token distribution visualization will appear here.</p>
                        </div>
                    </div>
                </div>
                
                <div id="process-viz-panel" class="panel-content">
                    <div class="panel">
                        <h3>Processing Pipeline Flow</h3>
                        <div id="pipeline-flow-viz">
                            <p>Processing pipeline visualization will appear here.</p>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>Statistics Report</h3>
                    <div id="viz-stats">
                        <p>Process your data to see detailed statistics.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Application state
        const appState = {
            inputText: '',
            tokens: [],
            processedData: null,
            bankData: {},
            reconstructedData: '',
            currentBank: 1,
            totalBanks: 1,
            advancedMode: false,
            config: {
                // Input options
                input: {
                    encoding: "UTF-8",
                    normalizeNewlines: true,
                    trimWhitespace: true,
                    preprocessor: "function(text) {\n  return text.replace(/\\s+/g, ' ');\n}"
                },
                // Token extraction options
                tokenExtraction: {
                    tokenType: 'word',
                    nGramSize: 2,
                    customRegex: '\\b\\w+\\b',
                    customTokenizer: "function(text) {\n  const tokens = text.split(/\\s+/);\n  return tokens.map((token, index) => ({\n    token: token,\n    index: text.indexOf(token, index > 0 ? tokens[index-1].index + tokens[index-1].length : 0),\n    length: token.length\n  }));\n}",
                    ignoreCase: true,
                    removePunctuation: true,
                    normalizeWhitespace: true,
                    lowercaseTokens: false,
                    minTokenLength: 1,
                    maxTokenLength: 100,
                    excludePattern: "",
                    stopWords: "",
                    stemmingAlgorithm: "none",
                    removeNumbers: false,
                    tokenTransformer: "function(token) {\n  return token.replace(/[^\\w\\s]/g, '');\n}"
                },
                // Bank structure options
                bankStructure: {
                    maxBanks: 10,
                    maxRegisters: 10,
                    maxAddresses: 20,
                    bankNumbering: "sequential",
                    customBankNumbers: "",
                    registerNumbering: "sequential",
                    organizationStrategy: "sequential",
                    bankAllocationStrategy: "fill",
                    customAllocationFunction: "function(token, index) {\n  const firstChar = token.token.charAt(0).toLowerCase();\n  const bankId = Math.min(Math.floor((firstChar.charCodeAt(0) - 97) / 3) + 1, 10);\n  const registerId = (index % 10) + 1;\n  \n  return {\n    bank: bankId,\n    register: registerId,\n    address: null\n  };\n}",
                    fillStrategy: "sequential",
                    addressAssignment: "sequential",
                    deduplicateTokens: true,
                    optimizeSpace: true,
                    reserveSpecialAddresses: false,
                    specialAddresses: "",
                    enableClassification: false,
                    classificationMethod: "length",
                    customClassifier: "function(token) {\n  if (token.token.length <= 3) return 'short';\n  if (token.token.length >= 8) return 'long';\n  if (/^[A-Z]/.test(token.token)) return 'capitalized';\n  if (/^\\d+$/.test(token.token)) return 'numeric';\n  return 'medium';\n}"
                },
                // Reference generation options
                referenceGeneration: {
                    referenceFormat: "standard",
                    customFormat: "{b}.{r}.{a}",
                    formattingStyle: "plain",
                    customFormatter: "function(ref) {\n  return `REF(${ref.bank},${ref.register},${ref.address})`;\n}",
                    referenceStrategy: "direct",
                    customStrategy: "function(token, occurrence, context) {\n  return occurrence > 0 && token.token.length > 5;\n}",
                    minTokenLength: 3,
                    minOccurrences: 2,
                    enableSelectiveReference: false,
                    selectivePatterns: "",
                    enableNestedReferences: false,
                    enableCircularDetection: true,
                    nestedDepthLimit: 3,
                    cacheResolvedReferences: true,
                    conflictStrategy: "first",
                    conflictResolver: "function(references) {\n  return references.reduce((best, ref) => \n    ref.bank < best.bank ? ref : best\n  , references[0]);\n}"
                },
                // Advanced processing options
                advancedProcessing: {
                    compressionLevel: "medium",
                    customCompression: "",
                    optimizeReferencePaths: true,
                    balanceBankUsage: false,
                    minimizeFragmentation: true,
                    addMetadata: true,
                    metadataFields: ["timestamp", "config", "stats", "version"],
                    customMetadata: "",
                    includeDocumentation: true,
                    documentationFormat: "markdown",
                    preserveMultiline: false,
                    multilineDelimiter: '"""',
                    normalizeIndentation: true,
                    preserveEmptyLines: true,
                    enableCustomPipeline: false,
                    customPipeline: "[\n  {\n    name: \"Remove Specific Tokens\",\n    process: function(data) {\n      data.tokens = data.tokens.filter(t => \n        !['a', 'the', 'of'].includes(t.token.toLowerCase())\n      );\n      return data;\n    }\n  },\n  {\n    name: \"Add Special References\",\n    process: function(data) {\n      if (data.tokens.length > 0) {\n        data.tokens[0].specialRef = true;\n      }\n      return data;\n    }\n  }\n]"
                },
                // Output options
                output: {
                    format: "structured",
                    packageName: "data_bank_package",
                    includeInPackage: ["banks", "json", "referenced", "docs", "config", "stats"]
                }
            }
        };

        // DOM Elements
        const elements = {};

        // Initialize the application
        document.addEventListener('DOMContentLoaded', initApp);

        function initApp() {
            // Initialize element references
            initializeElementReferences();
            
            // Set up event listeners
            setupEventListeners();
            
            // Load saved configuration if exists
            try {
                loadConfigFromStorage();
            } catch (e) {
                console.error("Error loading config from storage:", e);
                resetConfigToDefaults();
            }
            
            // Set initial UI state
            updateUIFromConfig();
            toggleAdvancedMode();
            
            // Show welcome toast
            showToast('Advanced Data Bank Manager initialized. Set granular configuration options for complete control.', 'success');
        }

        function initializeElementReferences() {
            // Core tabs
            elements.tabs = document.querySelectorAll('.tab');
            elements.tabContents = document.querySelectorAll('.tab-content');
            
            // Panel tabs
            elements.panelTabs = document.querySelectorAll('.panel-tab');
            elements.panelContents = document.querySelectorAll('.panel-content');
            
            // Collapsible elements
            elements.collapsibles = document.querySelectorAll('.collapsible');
            
            // Main UI elements
            elements.advancedModeToggle = document.getElementById('advanced-mode-toggle');
            
            // Input tab elements
            elements.inputArea = document.getElementById('input-area');
            elements.loadSampleBtn = document.getElementById('load-sample-btn');
            elements.parseBtn = document.getElementById('parse-btn');
            elements.clearBtn = document.getElementById('clear-btn');
            elements.uploadTxtBtn = document.getElementById('upload-txt-btn');
            elements.fileUpload = document.getElementById('file-upload');
            elements.fileDropZone = document.getElementById('file-drop-zone');
            elements.inputEncoding = document.getElementById('input-encoding');
            elements.normalizeNewlines = document.getElementById('normalize-newlines');
            elements.trimWhitespace = document.getElementById('trim-whitespace');
            elements.inputPreprocessor = document.getElementById('input-preprocessor');
            elements.inputStats = document.getElementById('input-stats');
            elements.statsContent = document.getElementById('stats-content');
            
            // Token extraction tab elements
            elements.tokenType = document.getElementById('token-type');
            elements.ngramOptions = document.getElementById('ngram-options');
            elements.ngramSize = document.getElementById('ngram-size');
            elements.regexContainer = document.getElementById('regex-container');
            elements.customRegex = document.getElementById('custom-regex');
            elements.customTokenizerContainer = document.getElementById('custom-tokenizer-container');
            elements.customTokenizer = document.getElementById('custom-tokenizer');
            elements.ignoreCase = document.getElementById('ignore-case');
            elements.removePunctuation = document.getElementById('remove-punctuation');
            elements.normalizeWhitespace = document.getElementById('normalize-whitespace');
            elements.lowercaseTokens = document.getElementById('lowercase-tokens');
            elements.minTokenLength = document.getElementById('min-token-length');
            elements.maxTokenLength = document.getElementById('max-token-length');
            elements.tokenExcludePattern = document.getElementById('token-exclude-pattern');
            elements.stopWords = document.getElementById('stop-words');
            elements.stemmingAlgorithm = document.getElementById('stemming-algorithm');
            elements.removeNumbers = document.getElementById('remove-numbers');
            elements.tokenTransformer = document.getElementById('token-transformer');
            elements.extractTokensBtn = document.getElementById('extract-tokens-btn');
            elements.editTokensBtn = document.getElementById('edit-tokens-btn');
            elements.saveTokensBtn = document.getElementById('save-tokens-btn');
            elements.tokenStats = document.getElementById('token-stats');
            elements.tokenEditor = document.getElementById('token-editor');
            elements.continueToBank = document.getElementById('continue-to-bank-structure');
            
            // Bank Structure elements
            elements.maxBanks = document.getElementById('max-banks');
            elements.maxRegisters = document.getElementById('max-registers');
            elements.maxAddresses = document.getElementById('max-addresses');
            elements.bankNumbering = document.getElementById('bank-numbering');
            elements.customBankNumbering = document.getElementById('custom-bank-numbering');
            elements.customBankNumbers = document.getElementById('custom-bank-numbers');
            elements.registerNumbering = document.getElementById('register-numbering');
            elements.organizationStrategy = document.getElementById('organization-strategy');
            elements.bankAllocationStrategy = document.getElementById('bank-allocation-strategy');
            elements.customAllocationFunction = document.getElementById('custom-allocation-function');
            elements.allocationFunction = document.getElementById('allocation-function');
            elements.fillStrategy = document.getElementById('fill-strategy');
            elements.addressAssignment = document.getElementById('address-assignment');
            elements.deduplicateTokens = document.getElementById('deduplicate-tokens');
            elements.optimizeSpace = document.getElementById('optimize-space');
            elements.reserveSpecialAddresses = document.getElementById('reserve-special-addresses');
            elements.specialAddressesContainer = document.getElementById('special-addresses-container');
            elements.specialAddresses = document.getElementById('special-addresses');
            elements.enableClassification = document.getElementById('enable-classification');
            elements.classificationOptions = document.getElementById('classification-options');
            elements.classificationMethod = document.getElementById('classification-method');
            elements.customClassifierContainer = document.getElementById('custom-classifier-container');
            elements.customClassifier = document.getElementById('custom-classifier');
            elements.generateStructureBtn = document.getElementById('generate-structure-btn');
            elements.structurePreview = document.getElementById('structure-preview');
            elements.addBankBtn = document.getElementById('add-bank-btn');
            elements.clearStructureBtn = document.getElementById('clear-structure-btn');
            elements.saveStructureBtn = document.getElementById('save-structure-btn');
            elements.bankStructureEditor = document.getElementById('bank-structure-editor');
            elements.generateHybridBtn = document.getElementById('generate-hybrid-btn');
            elements.saveHybridBtn = document.getElementById('save-hybrid-btn');
            elements.hybridStructureEditor = document.getElementById('hybrid-structure-editor');
            elements.tokenDistribution = document.getElementById('token-distribution');
            elements.continueToReferences = document.getElementById('continue-to-references');
            
            // Reference Generation elements
            elements.referenceFormat = document.getElementById('reference-format');
            elements.customFormatContainer = document.getElementById('custom-format-container');
            elements.customFormat = document.getElementById('custom-format');
            elements.formattingStyle = document.getElementById('formatting-style');
            elements.customFormatterContainer = document.getElementById('custom-formatter-container');
            elements.customFormatter = document.getElementById('custom-formatter');
            elements.referenceStrategy = document.getElementById('reference-strategy');
            elements.customStrategyContainer = document.getElementById('custom-strategy-container');
            elements.customStrategy = document.getElementById('custom-strategy');
            elements.refMinLength = document.getElementById('ref-min-length');
            elements.refMinOccurrences = document.getElementById('ref-min-occurrences');
            elements.enableSelectiveReference = document.getElementById('enable-selective-reference');
            elements.selectivePatternsContainer = document.getElementById('selective-patterns-container');
            elements.selectivePatterns = document.getElementById('selective-patterns');
            elements.enableNestedReferences = document.getElementById('enable-nested-references');
            elements.enableCircularDetection = document.getElementById('enable-circular-detection');
            elements.nestedDepthLimit = document.getElementById('nested-depth-limit');
            elements.cacheResolvedReferences = document.getElementById('cache-resolved-references');
            elements.refConflictStrategy = document.getElementById('ref-conflict-strategy');
            elements.customConflictResolver = document.getElementById('custom-conflict-resolver');
            elements.conflictResolver = document.getElementById('conflict-resolver');
            elements.generateReferencesBtn = document.getElementById('generate-references-btn');
            elements.referenceMap = document.getElementById('reference-map');
            elements.referenceTextPreview = document.getElementById('reference-text-preview');
            elements.referenceGraph = document.getElementById('reference-graph');
            elements.referenceStats = document.getElementById('reference-stats');
            elements.continueToAdvanced = document.getElementById('continue-to-advanced');
            
            // Advanced Processing elements
            elements.compressionLevel = document.getElementById('compression-level');
            elements.customCompressionContainer = document.getElementById('custom-compression-container');
            elements.compressionSettings = document.getElementById('compression-settings');
            elements.optimizeReferencePaths = document.getElementById('optimize-reference-paths');
            elements.balanceBankUsage = document.getElementById('balance-bank-usage');
            elements.minimizeFragmentation = document.getElementById('minimize-fragmentation');
            elements.addMetadata = document.getElementById('add-metadata');
            elements.metadataOptions = document.getElementById('metadata-options');
            elements.metadataFields = document.getElementsByName('metadata-field');
            elements.customMetadata = document.getElementById('custom-metadata');
            elements.includeDocumentation = document.getElementById('include-documentation');
            elements.documentationOptions = document.getElementById('documentation-options');
            elements.docFormat = document.getElementById('doc-format');
            elements.preserveMultiline = document.getElementById('preserve-multiline');
            elements.multilineOptions = document.getElementById('multiline-options');
            elements.multilineDelimiter = document.getElementById('multiline-delimiter');
            elements.normalizeIndentation = document.getElementById('normalize-indentation');
            elements.preserveEmptyLines = document.getElementById('preserve-empty-lines');
            elements.enableCustomPipeline = document.getElementById('enable-custom-pipeline');
            elements.pipelineConfig = document.getElementById('pipeline-config');
            elements.customPipeline = document.getElementById('custom-pipeline');
            elements.testPipelineBtn = document.getElementById('test-pipeline-btn');
            elements.applyPipelineBtn = document.getElementById('apply-pipeline-btn');
            elements.pipelineVisualization = document.getElementById('pipeline-visualization');
            elements.originalSizeBar = document.getElementById('original-size-bar');
            elements.originalSize = document.getElementById('original-size');
            elements.optimizedSizeBar = document.getElementById('optimized-size-bar');
            elements.optimizedSize = document.getElementById('optimized-size');
            elements.compressionRatio = document.getElementById('compression-ratio');
            elements.efficiencyMetrics = document.getElementById('efficiency-metrics');
            elements.continueToOutput = document.getElementById('continue-to-output');
            
            // Output elements
            elements.processFinalBtn = document.getElementById('process-final-btn');
            elements.outputFormat = document.getElementById('output-format');
            elements.jsonOutput = document.getElementById('json-output');
            elements.bankOutput = document.getElementById('bank-output');
            elements.downloadJsonBtn = document.getElementById('download-json-btn');
            elements.copyJsonBtn = document.getElementById('copy-json-btn');
            elements.downloadTxtBtn = document.getElementById('download-txt-btn');
            elements.copyTxtBtn = document.getElementById('copy-txt-btn');
            elements.packageName = document.getElementById('package-name');
            elements.packageItems = document.getElementsByName('package-item');
            elements.downloadZipBtn = document.getElementById('download-zip-btn');
            elements.compressionStats = document.getElementById('compression-stats');
            elements.compressionContent = document.getElementById('compression-content');
            
            // Visualization elements
            elements.previewLevel = document.getElementById('preview-level');
            elements.prevBank = document.getElementById('prev-bank');
            elements.nextBank = document.getElementById('next-bank');
            elements.bankIndicator = document.getElementById('bank-indicator');
            elements.bankVisualization = document.getElementById('bank-visualization');
            elements.referenceNetwork = document.getElementById('reference-network');
            elements.referenceDetails = document.getElementById('reference-details');
            elements.tokenDistributionViz = document.getElementById('token-distribution-viz');
            elements.pipelineFlowViz = document.getElementById('pipeline-flow-viz');
            elements.vizStats = document.getElementById('viz-stats');
            
            // Toast notification
            elements.toast = document.getElementById('toast');
        }

        function setupEventListeners() {
            // Set up tab switching
            elements.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Set up panel tab switching
            elements.panelTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const panel = tab.getAttribute('data-panel');
                    const tabGroup = tab.closest('.panel-tabs');
                    switchPanelTab(tabGroup, tab, panel);
                });
            });
            
            // Set up collapsible sections
            elements.collapsibles.forEach(collapsible => {
                collapsible.addEventListener('click', function() {
                    this.classList.toggle('collapsed');
                });
            });
            
            // Advanced mode toggle
            elements.advancedModeToggle.addEventListener('change', toggleAdvancedMode);
            
            // Input tab event listeners
            elements.loadSampleBtn.addEventListener('click', loadSampleText);
            elements.parseBtn.addEventListener('click', parseInputText);
            elements.clearBtn.addEventListener('click', () => {
                elements.inputArea.value = '';
                appState.inputText = '';
            });
            elements.uploadTxtBtn.addEventListener('click', () => elements.fileUpload.click());
            elements.fileUpload.addEventListener('change', handleFileUpload);
            
            // File drop zone
            elements.fileDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.fileDropZone.classList.add('drag-over');
            });
            
            elements.fileDropZone.addEventListener('dragleave', () => {
                elements.fileDropZone.classList.remove('drag-over');
            });
            
            elements.fileDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.fileDropZone.classList.remove('drag-over');
                handleFileDrop(e);
            });
            
            // Token extraction tab event listeners
            elements.tokenType.addEventListener('change', toggleTokenOptions);
            elements.extractTokensBtn.addEventListener('click', extractAndDisplayTokens);
            elements.editTokensBtn.addEventListener('click', enableTokenEditing);
            elements.saveTokensBtn.addEventListener('click', saveTokenEdits);
            elements.continueToBank.addEventListener('click', () => switchTab('bank-structure'));
            
            // Bank Structure event listeners
            elements.bankNumbering.addEventListener('change', toggleBankNumbering);
            elements.bankAllocationStrategy.addEventListener('change', toggleAllocationStrategy);
            elements.enableClassification.addEventListener('change', toggleClassification);
            elements.classificationMethod.addEventListener('change', toggleClassificationMethod);
            elements.reserveSpecialAddresses.addEventListener('change', toggleSpecialAddresses);
            elements.generateStructureBtn.addEventListener('click', generateBankStructure);
            elements.addBankBtn.addEventListener('click', addBank);
            elements.clearStructureBtn.addEventListener('click', clearBankStructure);
            elements.saveStructureBtn.addEventListener('click', saveManualStructure);
            elements.generateHybridBtn.addEventListener('click', generateHybridStructure);
            elements.saveHybridBtn.addEventListener('click', saveHybridStructure);
            elements.continueToReferences.addEventListener('click', () => switchTab('reference-generation'));
            
            // Reference Generation event listeners
            elements.referenceFormat.addEventListener('change', toggleReferenceFormat);
            elements.formattingStyle.addEventListener('change', toggleFormattingStyle);
            elements.referenceStrategy.addEventListener('change', toggleReferenceStrategy);
            elements.refConflictStrategy.addEventListener('change', toggleConflictStrategy);
            elements.enableSelectiveReference.addEventListener('change', toggleSelectiveReference);
            elements.generateReferencesBtn.addEventListener('click', generateReferences);
            elements.continueToAdvanced.addEventListener('click', () => switchTab('advanced-processing'));
            
            // Advanced Processing event listeners
            elements.compressionLevel.addEventListener('change', toggleCompressionLevel);
            elements.preserveMultiline.addEventListener('change', toggleMultilineOptions);
            elements.enableCustomPipeline.addEventListener('change', toggleCustomPipeline);
            elements.testPipelineBtn.addEventListener('click', testPipeline);
            elements.applyPipelineBtn.addEventListener('click', applyPipeline);
            elements.continueToOutput.addEventListener('click', () => switchTab('output'));
            
            // Output tab event listeners
            elements.processFinalBtn.addEventListener('click', processWithAllSettings);
            elements.downloadJsonBtn.addEventListener('click', downloadJson);
            elements.downloadTxtBtn.addEventListener('click', downloadTxt);
            elements.downloadZipBtn.addEventListener('click', downloadZip);
            elements.copyJsonBtn.addEventListener('click', () => copyToClipboard(elements.jsonOutput.textContent));
            elements.copyTxtBtn.addEventListener('click', () => copyToClipboard(elements.bankOutput.textContent));
            
            // Visualization event listeners
            elements.previewLevel.addEventListener('change', updateVisualization);
            elements.prevBank.addEventListener('click', () => navigateBank(-1));
            elements.nextBank.addEventListener('click', () => navigateBank(1));
        }

        // Basic utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message, type = 'info') {
            const toast = elements.toast;
            toast.textContent = message;
            toast.className = 'toast';
            if (type) toast.classList.add(type);
            
            toast.classList.add('visible');
            
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 3000);
        }

        function switchTab(tabName) {
				elements.tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            elements.tabContents.forEach(content => {
                if (content.id === `${tabName}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
        }

        function switchPanelTab(tabGroup, tab, panelName) {
            // Get all tabs in this group
            const tabs = tabGroup.querySelectorAll('.panel-tab');
            
            // Get parent container
            const container = tabGroup.parentElement;
            
            // Get all panel contents in this container
            const panels = container.querySelectorAll('.panel-content');
            
            // Deactivate all tabs and panels
            tabs.forEach(t => t.classList.remove('active'));
            panels.forEach(p => p.classList.remove('active'));
            
            // Activate current tab and panel
            tab.classList.add('active');
            const panel = container.querySelector(`#${panelName}-panel`);
            if (panel) panel.classList.add('active');
        }

        // Configuration management
        function saveConfigToStorage() {
            try {
                localStorage.setItem('dataBankConfig', JSON.stringify(appState.config));
            } catch (e) {
                console.error('Error saving config to storage:', e);
            }
        }

        function loadConfigFromStorage() {
            try {
                const savedConfig = localStorage.getItem('dataBankConfig');
                if (savedConfig) {
                    const config = JSON.parse(savedConfig);
                    
                    // Validate config structure
                    if (!config.input || !config.tokenExtraction || 
                        !config.bankStructure || !config.referenceGeneration || 
                        !config.advancedProcessing || !config.output) {
                        console.warn('Incomplete configuration found in storage, using defaults');
                        resetConfigToDefaults();
                        return;
                    }
                    
                    appState.config = config;
                    
                    // Load advanced mode
                    appState.advancedMode = localStorage.getItem('dataBankAdvancedMode') === 'true';
                    elements.advancedModeToggle.checked = appState.advancedMode;
                }
            } catch (e) {
                console.error('Error loading config from storage:', e);
                resetConfigToDefaults();
            }
        }

        function resetConfigToDefaults() {
            // Reset to default configuration
            appState.config = {
                input: {
                    encoding: "UTF-8",
                    normalizeNewlines: true,
                    trimWhitespace: true,
                    preprocessor: "function(text) {\n  return text.replace(/\\s+/g, ' ');\n}"
                },
                tokenExtraction: {
                    tokenType: 'word',
                    nGramSize: 2,
                    customRegex: '\\b\\w+\\b',
                    customTokenizer: "function(text) {\n  const tokens = text.split(/\\s+/);\n  return tokens.map((token, index) => ({\n    token: token,\n    index: text.indexOf(token, index > 0 ? tokens[index-1].index + tokens[index-1].length : 0),\n    length: token.length\n  }));\n}",
                    ignoreCase: true,
                    removePunctuation: true,
                    normalizeWhitespace: true,
                    lowercaseTokens: false,
                    minTokenLength: 1,
                    maxTokenLength: 100,
                    excludePattern: "",
                    stopWords: "",
                    stemmingAlgorithm: "none",
                    removeNumbers: false,
                    tokenTransformer: "function(token) {\n  return token.replace(/[^\\w\\s]/g, '');\n}"
                },
                bankStructure: {
                    maxBanks: 10,
                    maxRegisters: 10,
                    maxAddresses: 20,
                    bankNumbering: "sequential",
                    customBankNumbers: "",
                    registerNumbering: "sequential",
                    organizationStrategy: "sequential",
                    bankAllocationStrategy: "fill",
                    customAllocationFunction: "function(token, index) {\n  const firstChar = token.token.charAt(0).toLowerCase();\n  const bankId = Math.min(Math.floor((firstChar.charCodeAt(0) - 97) / 3) + 1, 10);\n  const registerId = (index % 10) + 1;\n  \n  return {\n    bank: bankId,\n    register: registerId,\n    address: null\n  };\n}",
                    fillStrategy: "sequential",
                    addressAssignment: "sequential",
                    deduplicateTokens: true,
                    optimizeSpace: true,
                    reserveSpecialAddresses: false,
                    specialAddresses: "",
                    enableClassification: false,
                    classificationMethod: "length",
                    customClassifier: "function(token) {\n  if (token.token.length <= 3) return 'short';\n  if (token.token.length >= 8) return 'long';\n  if (/^[A-Z]/.test(token.token)) return 'capitalized';\n  if (/^\\d+$/.test(token.token)) return 'numeric';\n  return 'medium';\n}"
                },
                referenceGeneration: {
                    referenceFormat: "standard",
                    customFormat: "{b}.{r}.{a}",
                    formattingStyle: "plain",
                    customFormatter: "function(ref) {\n  return `REF(${ref.bank},${ref.register},${ref.address})`;\n}",
                    referenceStrategy: "direct",
                    customStrategy: "function(token, occurrence, context) {\n  return occurrence > 0 && token.token.length > 5;\n}",
                    minTokenLength: 3,
                    minOccurrences: 2,
                    enableSelectiveReference: false,
                    selectivePatterns: "",
                    enableNestedReferences: false,
                    enableCircularDetection: true,
                    nestedDepthLimit: 3,
                    cacheResolvedReferences: true,
                    conflictStrategy: "first",
                    conflictResolver: "function(references) {\n  return references.reduce((best, ref) => \n    ref.bank < best.bank ? ref : best\n  , references[0]);\n}"
                },
                advancedProcessing: {
                    compressionLevel: "medium",
                    customCompression: "",
                    optimizeReferencePaths: true,
                    balanceBankUsage: false,
                    minimizeFragmentation: true,
                    addMetadata: true,
                    metadataFields: ["timestamp", "config", "stats", "version"],
                    customMetadata: "",
                    includeDocumentation: true,
                    documentationFormat: "markdown",
                    preserveMultiline: false,
                    multilineDelimiter: '"""',
                    normalizeIndentation: true,
                    preserveEmptyLines: true,
                    enableCustomPipeline: false,
                    customPipeline: "[\n  {\n    name: \"Remove Specific Tokens\",\n    process: function(data) {\n      data.tokens = data.tokens.filter(t => \n        !['a', 'the', 'of'].includes(t.token.toLowerCase())\n      );\n      return data;\n    }\n  },\n  {\n    name: \"Add Special References\",\n    process: function(data) {\n      if (data.tokens.length > 0) {\n        data.tokens[0].specialRef = true;\n      }\n      return data;\n    }\n  }\n]"
                },
                output: {
                    format: "structured",
                    packageName: "data_bank_package",
                    includeInPackage: ["banks", "json", "referenced", "docs", "config", "stats"]
                }
            };
            updateUIFromConfig();
            saveConfigToStorage();
        }

        function updateUIFromConfig() {
            const config = appState.config;
            
            // Input section
            if (config.input) {
                elements.inputEncoding.value = config.input.encoding || "UTF-8";
                elements.normalizeNewlines.checked = config.input.normalizeNewlines !== false;
                elements.trimWhitespace.checked = config.input.trimWhitespace !== false;
                elements.inputPreprocessor.value = config.input.preprocessor || "";
            }
            
            // Token extraction section
            if (config.tokenExtraction) {
                elements.tokenType.value = config.tokenExtraction.tokenType || 'word';
                elements.ngramSize.value = config.tokenExtraction.nGramSize || 2;
                elements.customRegex.value = config.tokenExtraction.customRegex || '\\b\\w+\\b';
                elements.customTokenizer.value = config.tokenExtraction.customTokenizer || "";
                elements.ignoreCase.value = config.tokenExtraction.ignoreCase ? 'true' : 'false';
                elements.removePunctuation.checked = config.tokenExtraction.removePunctuation !== false;
                elements.normalizeWhitespace.checked = config.tokenExtraction.normalizeWhitespace !== false;
                if (elements.lowercaseTokens) {
                    elements.lowercaseTokens.checked = config.tokenExtraction.lowercaseTokens === true;
                }
                elements.minTokenLength.value = config.tokenExtraction.minTokenLength || 1;
                elements.maxTokenLength.value = config.tokenExtraction.maxTokenLength || 100;
                elements.tokenExcludePattern.value = config.tokenExtraction.excludePattern || "";
                elements.stopWords.value = config.tokenExtraction.stopWords || "";
                elements.stemmingAlgorithm.value = config.tokenExtraction.stemmingAlgorithm || "none";
                elements.removeNumbers.checked = config.tokenExtraction.removeNumbers === true;
                elements.tokenTransformer.value = config.tokenExtraction.tokenTransformer || "";
                
                // Update visibility of conditional fields
                toggleTokenOptions();
            }
            
            // Update more UI elements as needed for other sections
            // This is a simplified version - a full implementation would update all UI elements
        }

        // Toggle advanced mode
        function toggleAdvancedMode() {
            appState.advancedMode = elements.advancedModeToggle.checked;
            
            // Store preference
            localStorage.setItem('dataBankAdvancedMode', appState.advancedMode);
            
            // Toggle visibility of advanced options
            document.querySelectorAll('.advanced-option').forEach(element => {
                element.style.display = appState.advancedMode ? 'block' : 'none';
            });
            
            showToast(appState.advancedMode ? 'Advanced mode enabled' : 'Advanced mode disabled', 'info');
        }

        // Input functions
        function loadSampleText() {
            const sampleText = `The Data Bank Manager is a sophisticated system for organizing and referencing structured information. It provides a hierarchical approach to data storage using Banks, Registers, and Addresses.

Each Bank contains multiple Registers, and each Register contains multiple Addresses. This three-level structure allows for efficient data retrieval and cross-referencing.

The reference format typically follows the pattern of Bank.Register.Address (e.g., 1.2.3), which uniquely identifies any piece of information within the system.

One of the most powerful features is the ability to resolve nested references, where an Address might contain a reference to another Address, creating a flexible and interconnected network of information.`;
            
            elements.inputArea.value = sampleText;
            appState.inputText = sampleText;
            parseInputText();
            showToast('Sample text loaded', 'success');
        }

        function parseInputText() {
            appState.inputText = elements.inputArea.value;
            if (!appState.inputText) {
                showToast('Please enter some text first', 'error');
                return;
            }
            
            // Pre-process text based on input options
            if (elements.normalizeNewlines.checked) {
                appState.inputText = appState.inputText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            }
            
            if (elements.trimWhitespace.checked) {
                appState.inputText = appState.inputText.trim();
            }
            
            // Apply custom preprocessor if provided
            try {
                const preprocessorCode = elements.inputPreprocessor.value;
                if (preprocessorCode && preprocessorCode.trim() !== '') {
                    const preprocessor = new Function(`return ${preprocessorCode}`)();
                    appState.inputText = preprocessor(appState.inputText);
                }
            } catch (e) {
                showToast(`Error in preprocessor function: ${e.message}`, 'error');
            }
            
            // Show basic statistics about the input
            const stats = analyzeText(appState.inputText);
            displayInputStats(stats);
            
            showToast('Text parsed successfully', 'success');
            
            // Switch to token extraction tab
            switchTab('token-extraction');
        }

        function handleFileUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            processFiles(files);
        }

        function handleFileDrop(e) {
            const files = e.dataTransfer.files;
            if (!files || files.length === 0) return;
            
            processFiles(files);
        }

        function processFiles(files) {
            if (files.length === 1) {
                // Single file - load into text area
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    elements.inputArea.value = event.target.result;
                    appState.inputText = event.target.result;
                    parseInputText();
                    showToast(`File loaded: ${file.name}`, 'success');
                };
                
                reader.onerror = function() {
                    showToast(`Error reading file: ${file.name}`, 'error');
                };
                
                reader.readAsText(file);
            } else {
                // Multiple files - could implement batch processing logic here
                showToast(`${files.length} files selected. Processing first file.`, 'warning');
                
                const file = files[0];
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    elements.inputArea.value = event.target.result;
                    appState.inputText = event.target.result;
                    parseInputText();
                };
                
                reader.readAsText(file);
            }
        }

        function analyzeText(text) {
            const words = text.match(/\b\w+\b/g) || [];
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
            const paragraphs = text.split(/\n\s*\n/) || [];
            const characters = text.length;
            const lines = text.split('\n').length;
            const uniqueWords = new Set(words.map(w => w.toLowerCase())).size;
            
            return {
                characters,
                words: words.length,
                uniqueWords,
                sentences: sentences.length,
                paragraphs: paragraphs.length,
                lines
            };
        }

        function displayInputStats(stats) {
            elements.statsContent.innerHTML = `
                <p><strong>Characters:</strong> ${stats.characters}</p>
                <p><strong>Words:</strong> ${stats.words} (${stats.uniqueWords} unique)</p>
                <p><strong>Sentences:</strong> ${stats.sentences}</p>
                <p><strong>Paragraphs:</strong> ${stats.paragraphs}</p>
                <p><strong>Lines:</strong> ${stats.lines}</p>
            `;
            elements.inputStats.style.display = 'block';
        }

        // Token extraction functions
        function toggleTokenOptions() {
            const tokenType = elements.tokenType.value;
            
            // Show/hide appropriate containers
            elements.ngramOptions.style.display = tokenType === 'ngram' ? 'block' : 'none';
            elements.regexContainer.style.display = tokenType === 'regex' ? 'block' : 'none';
            elements.customTokenizerContainer.style.display = tokenType === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.tokenExtraction.tokenType = tokenType;
        }

        function extractAndDisplayTokens() {
            if (!appState.inputText) {
                showToast('Please parse some text first', 'error');
                switchTab('input');
                return;
            }
            
            // Update config from UI
            updateTokenExtractionConfigFromUI();
            
            // Extract tokens
            const tokens = extractTokens();
            appState.tokens = tokens;
            
            // Display tokens in the editor
            displayTokens(tokens);
            
            showToast(`Extracted ${tokens.length} tokens`, 'success');
        }

        function updateTokenExtractionConfigFromUI() {
            const config = appState.config.tokenExtraction;
            
            config.tokenType = elements.tokenType.value;
            
            if (config.tokenType === 'ngram') {
                config.nGramSize = parseInt(elements.ngramSize.value);
            } else if (config.tokenType === 'regex') {
                config.customRegex = elements.customRegex.value;
            } else if (config.tokenType === 'custom') {
                config.customTokenizer = elements.customTokenizer.value;
            }
            
            config.ignoreCase = elements.ignoreCase.value === 'true';
            config.removePunctuation = elements.removePunctuation.checked;
            config.normalizeWhitespace = elements.normalizeWhitespace.checked;
            if (elements.lowercaseTokens) {
                config.lowercaseTokens = elements.lowercaseTokens.checked;
            }
            config.minTokenLength = parseInt(elements.minTokenLength.value);
            config.maxTokenLength = parseInt(elements.maxTokenLength.value);
            config.excludePattern = elements.tokenExcludePattern.value;
            config.stopWords = elements.stopWords.value;
            config.stemmingAlgorithm = elements.stemmingAlgorithm.value;
            config.removeNumbers = elements.removeNumbers.checked;
            config.tokenTransformer = elements.tokenTransformer.value;
            
            saveConfigToStorage();
        }

        function extractTokens() {
            try {
                // Implementation based on token type
                const text = appState.inputText;
                const config = appState.config.tokenExtraction;
                let tokens = [];
                
                switch (config.tokenType) {
                    case 'word':
                        tokens = extractWordTokens(text, config);
                        break;
                    case 'sentence':
                        tokens = extractSentenceTokens(text, config);
                        break;
                    case 'paragraph':
                        tokens = extractParagraphTokens(text, config);
                        break;
                    case 'character':
                        tokens = extractCharacterTokens(text, config);
                        break;
                    case 'line':
                        tokens = extractLineTokens(text, config);
                        break;
                    case 'ngram':
                        tokens = extractNGramTokens(text, config);
                        break;
                    case 'regex':
                        tokens = extractRegexTokens(text, config);
                        break;
                    case 'custom':
                        tokens = extractCustomTokens(text, config);
                        break;
                    default:
                        tokens = extractWordTokens(text, config);
                }
                
                // Apply filtering and transformation
                tokens = filterAndTransformTokens(tokens, config);
                
                return tokens;
            } catch (e) {
                showToast(`Error extracting tokens: ${e.message}`, 'error');
                console.error("Token extraction error:", e);
                return [];
            }
        }

		// Implementation of token extraction methods
        function extractWordTokens(text, config) {
            const pattern = config.ignoreCase ? /\b\w+\b/gi : /\b\w+\b/g;
            return extractWithRegex(text, pattern);
        }

        function extractSentenceTokens(text, config) {
            const pattern = /[^.!?]+[.!?]+/g;
            return extractWithRegex(text, pattern);
        }

        function extractParagraphTokens(text, config) {
            const paragraphs = text.split(/\n\s*\n/);
            return paragraphs.map((p, i) => {
                const startIndex = i === 0 ? 0 : text.indexOf(p, getEndIndexOfParagraph(paragraphs, i - 1, text));
                return {
                    token: p.trim(),
                    index: startIndex,
                    length: p.length
                };
            }).filter(t => t.token.length > 0);
        }

        function getEndIndexOfParagraph(paragraphs, index, text) {
            if (index < 0) return 0;
            const paragraph = paragraphs[index];
            const startIndex = text.indexOf(paragraph);
            return startIndex + paragraph.length;
        }

        function extractCharacterTokens(text, config) {
            return text.split('').map((char, index) => ({
                token: char,
                index,
                length: 1
            }));
        }

        function extractLineTokens(text, config) {
            const lines = text.split('\n');
            return lines.map((line, i) => {
                const startIndex = i === 0 ? 0 : text.indexOf(line, getEndIndexOfLine(lines, i - 1, text));
                return {
                    token: line.trim(),
                    index: startIndex,
                    length: line.length
                };
            }).filter(t => t.token.length > 0);
        }

        function getEndIndexOfLine(lines, index, text) {
            if (index < 0) return 0;
            const line = lines[index];
            const startIndex = text.indexOf(line);
            return startIndex + line.length + 1; // +1 for newline
        }

        function extractNGramTokens(text, config) {
            const words = text.match(/\b\w+\b/g) || [];
            const n = config.nGramSize;
            const ngrams = [];
            
            for (let i = 0; i <= words.length - n; i++) {
                const ngramWords = words.slice(i, i + n);
                const ngram = ngramWords.join(' ');
                
                // Find position in original text
                const startIndex = text.indexOf(ngram, i > 0 ? ngrams[i-1].index + ngrams[i-1].length : 0);
                
                if (startIndex !== -1) {
                    ngrams.push({
                        token: ngram,
                        index: startIndex,
                        length: ngram.length
                    });
                }
            }
            
            return ngrams;
        }

        function extractRegexTokens(text, config) {
            try {
                const pattern = new RegExp(config.customRegex, config.ignoreCase ? 'gi' : 'g');
                return extractWithRegex(text, pattern);
            } catch (e) {
                showToast(`Invalid regex pattern: ${e.message}`, 'error');
                return [];
            }
        }

        function extractCustomTokens(text, config) {
            try {
                const customTokenizer = new Function(`return ${config.customTokenizer}`)();
                return customTokenizer(text);
            } catch (e) {
                showToast(`Error in custom tokenizer: ${e.message}`, 'error');
                return [];
            }
        }

        function extractWithRegex(text, pattern) {
            const tokens = [];
            let match;
            
            while ((match = pattern.exec(text)) !== null) {
                tokens.push({
                    token: match[0],
                    index: match.index,
                    length: match[0].length
                });
            }
            
            return tokens;
        }

        function filterAndTransformTokens(tokens, config) {
            let result = [...tokens];
            
            // Apply transformations
            if (config.lowercaseTokens) {
                result = result.map(t => ({...t, token: t.token.toLowerCase()}));
            }
            
            if (config.removePunctuation) {
                result = result.map(t => ({...t, token: t.token.replace(/[^\w\s]/g, '')}));
            }
            
            if (config.normalizeWhitespace) {
                result = result.map(t => ({...t, token: t.token.replace(/\s+/g, ' ').trim()}));
            }
            
            // Apply filters
            result = result.filter(t => 
                t.token.length >= config.minTokenLength && 
                t.token.length <= config.maxTokenLength
            );
            
            if (config.excludePattern && config.excludePattern.trim() !== '') {
                try {
                    const pattern = new RegExp(config.excludePattern, config.ignoreCase ? 'i' : '');
                    result = result.filter(t => !pattern.test(t.token));
                } catch (e) {
                    console.error('Invalid exclude pattern:', e);
                }
            }
            
            if (config.stopWords && config.stopWords.trim() !== '') {
                const stopWordList = config.stopWords.split(',').map(word => word.trim().toLowerCase());
                result = result.filter(t => !stopWordList.includes(t.token.toLowerCase()));
            }
            
            if (config.removeNumbers) {
                result = result.filter(t => !/^\d+$/.test(t.token));
            }
            
            // Apply custom transformer if provided
            if (config.tokenTransformer && config.tokenTransformer.trim() !== '') {
                try {
                    const transformer = new Function(`return ${config.tokenTransformer}`)();
                    result = result.map(t => ({...t, token: transformer(t.token)}));
                } catch (e) {
                    console.error('Error in token transformer:', e);
                }
            }
            
            // Remove empty tokens after all transformations
            result = result.filter(t => t.token && t.token.trim() !== '');
            
            return result;
        }

        function displayTokens(tokens) {
            const container = elements.tokenEditor;
            container.innerHTML = '';
            
            if (tokens.length === 0) {
                container.innerHTML = '<p>No tokens extracted. Try adjusting your settings.</p>';
                return;
            }
            
            // Update token statistics
            const uniqueTokens = new Set(tokens.map(t => t.token)).size;
            elements.tokenStats.innerHTML = `
                <p><strong>Total Tokens:</strong> ${tokens.length}</p>
                <p><strong>Unique Tokens:</strong> ${uniqueTokens}</p>
                <p><strong>Longest Token:</strong> ${Math.max(...tokens.map(t => t.token.length))} characters</p>
            `;
            
            // Add tokens to editor
            tokens.forEach((token, index) => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                tokenItem.innerHTML = `
                    <span class="token-text" data-index="${index}">${escapeHtml(token.token)}</span>
                    <div class="token-controls">
                        <button class="btn-small btn-secondary token-edit-btn" data-index="${index}">Edit</button>
                        <button class="btn-small btn-accent token-remove-btn" data-index="${index}">Remove</button>
                    </div>
                `;
                container.appendChild(tokenItem);
            });
            
            // Add event listeners for token actions
            container.querySelectorAll('.token-edit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.getAttribute('data-index'));
                    const tokenElement = container.querySelector(`.token-text[data-index="${index}"]`);
                    
                    // Make the token editable
                    tokenElement.contentEditable = true;
                    tokenElement.classList.add('editable');
                    tokenElement.focus();
                    
                    // Select all text
                    const range = document.createRange();
                    range.selectNodeContents(tokenElement);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Enable save button
                    elements.saveTokensBtn.disabled = false;
                });
            });
            
            container.querySelectorAll('.token-remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.getAttribute('data-index'));
                    const tokenItem = e.target.closest('.token-item');
                    
                    // Remove the token from UI
                    tokenItem.remove();
                    
                    // Flag for update
                    elements.saveTokensBtn.disabled = false;
                });
            });
        }

        function enableTokenEditing() {
            if (!appState.tokens || appState.tokens.length === 0) {
                showToast('No tokens to edit. Extract tokens first.', 'warning');
                return;
            }
            
            // Enable editing for all tokens
            const tokenElements = elements.tokenEditor.querySelectorAll('.token-text');
            tokenElements.forEach(el => {
                el.contentEditable = true;
                el.classList.add('editable');
            });
            
            // Enable save button
            elements.saveTokensBtn.disabled = false;
            
            showToast('Token editing enabled. Click Save Changes when done.', 'info');
        }

        function saveTokenEdits() {
            const tokenElements = elements.tokenEditor.querySelectorAll('.token-text');
            const updatedTokens = [];
            
            // Collect all visible tokens
            tokenElements.forEach(el => {
                const index = parseInt(el.getAttribute('data-index'));
                const originalToken = appState.tokens[index];
                
                if (originalToken) {
                    updatedTokens.push({
                        ...originalToken,
                        token: el.textContent
                    });
                }
            });
            
            // Update the token list
            appState.tokens = updatedTokens;
            
            // Update UI
            displayTokens(updatedTokens);
            
            // Disable editing
            elements.saveTokensBtn.disabled = true;
            
            showToast(`Saved ${updatedTokens.length} tokens`, 'success');
        }

        // Bank Structure Tab Functions
        function toggleBankNumbering() {
            const bankNumbering = elements.bankNumbering.value;
            elements.customBankNumbering.style.display = bankNumbering === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.bankStructure.bankNumbering = bankNumbering;
        }

        function toggleAllocationStrategy() {
            const strategy = elements.bankAllocationStrategy.value;
            elements.customAllocationFunction.style.display = strategy === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.bankStructure.bankAllocationStrategy = strategy;
        }

        function toggleClassification() {
            const enabled = elements.enableClassification.checked;
            elements.classificationOptions.style.display = enabled ? 'block' : 'none';
            
            // Update config
            appState.config.bankStructure.enableClassification = enabled;
        }

        function toggleClassificationMethod() {
            const method = elements.classificationMethod.value;
            elements.customClassifierContainer.style.display = method === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.bankStructure.classificationMethod = method;
        }

        function toggleSpecialAddresses() {
            const enabled = elements.reserveSpecialAddresses.checked;
            elements.specialAddressesContainer.style.display = enabled ? 'block' : 'none';
            
            // Update config
            appState.config.bankStructure.reserveSpecialAddresses = enabled;
        }

        function generateBankStructure() {
            if (!appState.tokens || appState.tokens.length === 0) {
                showToast('No tokens to organize. Extract tokens first.', 'warning');
                switchTab('token-extraction');
                return;
            }

            // Update bank structure config from UI
            updateBankStructureConfigFromUI();
            
            // Create bank structure
            const result = createBankStructure();
            
            // Display the structure
            displayBankStructure(result.bankData);
            
            // Display token distribution
            displayTokenDistribution(result.bankData);
            
            showToast('Bank structure generated successfully', 'success');
        }

        function updateBankStructureConfigFromUI() {
            const config = appState.config.bankStructure;
            
            config.maxBanks = parseInt(elements.maxBanks.value);
            config.maxRegisters = parseInt(elements.maxRegisters.value);
            config.maxAddresses = parseInt(elements.maxAddresses.value);
            config.bankNumbering = elements.bankNumbering.value;
            config.customBankNumbers = elements.customBankNumbers.value;
            config.registerNumbering = elements.registerNumbering.value;
            config.organizationStrategy = elements.organizationStrategy.value;
            config.bankAllocationStrategy = elements.bankAllocationStrategy.value;
            config.fillStrategy = elements.fillStrategy.value;
            config.addressAssignment = elements.addressAssignment.value;
            config.deduplicateTokens = elements.deduplicateTokens.checked;
            config.optimizeSpace = elements.optimizeSpace.checked;
            config.reserveSpecialAddresses = elements.reserveSpecialAddresses.checked;
            config.specialAddresses = elements.specialAddresses.value;
            config.enableClassification = elements.enableClassification.checked;
            config.classificationMethod = elements.classificationMethod.value;
            
            // Update allocation function if custom
            if (config.bankAllocationStrategy === 'custom') {
                config.customAllocationFunction = elements.allocationFunction.value;
            }
            
            // Update classifier if custom
            if (config.enableClassification && config.classificationMethod === 'custom') {
                config.customClassifier = elements.customClassifier.value;
            }
            
            saveConfigToStorage();
        }

        function createBankStructure() {
            // Get tokens to organize
            const tokens = [...appState.tokens];
            
            // Apply organization strategy
            const organizedTokens = organizeTokens(tokens);
            
            // Create bank structure
            const bankData = {};
            
            // Generate bank numbers based on the numbering scheme
            const bankNumbers = generateBankNumbers();
            
            // For simplicity in this demo, we'll create a basic structure
            // In a full implementation, this would follow all the configuration options
            
            let currentBank = bankNumbers[0];
            let currentRegister = 1;
            let currentAddress = 1;
            
            // Initialize first bank and register
            bankData[currentBank] = {};
            bankData[currentBank][currentRegister] = { addresses: {} };
            
            // Add tokens to structure
            organizedTokens.forEach((token) => {
                // Check if we need to move to a new address, register, or bank
                if (currentAddress > appState.config.bankStructure.maxAddresses) {
                    currentAddress = 1;
                    currentRegister++;
                    
                    if (currentRegister > appState.config.bankStructure.maxRegisters) {
                        currentRegister = 1;
                        
                        // Move to next bank
                        const currentBankIndex = bankNumbers.indexOf(currentBank);
                        if (currentBankIndex < bankNumbers.length - 1) {
                            currentBank = bankNumbers[currentBankIndex + 1];
                            bankData[currentBank] = {};
                        } else {
                            // We've used all available banks
                            return;
                        }
                    }
                    
                    // Initialize new register
                    if (!bankData[currentBank][currentRegister]) {
                        bankData[currentBank][currentRegister] = { addresses: {} };
                    }
                }
                
                // Add token to structure
                bankData[currentBank][currentRegister].addresses[currentAddress] = token.token;
                
                // Move to next address
                currentAddress++;
            });
            
            // Store in app state
            appState.bankData = bankData;
            
            // Return information about the structure
            return {
                bankData,
                tokenCount: organizedTokens.length,
                bankCount: Object.keys(bankData).length,
                totalRegisters: Object.keys(bankData).reduce((sum, bankId) => 
                    sum + Object.keys(bankData[bankId]).length, 0),
                totalAddresses: Object.keys(bankData).reduce((sum, bankId) => 
                    Object.keys(bankData[bankId]).reduce((bankSum, registerId) => 
                        bankSum + Object.keys(bankData[bankId][registerId].addresses).length, sum), 0)
            };
        }

        function generateBankNumbers() {
            const maxBanks = appState.config.bankStructure.maxBanks;
            const numbering = appState.config.bankStructure.bankNumbering;
            
            switch (numbering) {
                case 'sequential':
                    return Array.from({ length: maxBanks }, (_, i) => i + 1);
                    
                case 'powers-of-ten':
                    return Array.from({ length: maxBanks }, (_, i) => Math.pow(10, i));
                    
                case 'prime':
                    return generatePrimeNumbers(maxBanks);
                    
                case 'custom':
                    const custom = appState.config.bankStructure.customBankNumbers
                        .split(',')
                        .map(n => parseInt(n.trim()))
                        .filter(n => !isNaN(n));
                    
                    return custom.length > 0 ? custom.slice(0, maxBanks) : [1];
                    
                default:
                    return Array.from({ length: maxBanks }, (_, i) => i + 1);
            }
        }

        function generatePrimeNumbers(count) {
            const primes = [2];
            let num = 3;
            
            while (primes.length < count) {
                let isPrime = true;
                const sqrt = Math.sqrt(num);
                
                for (let i = 0; primes[i] <= sqrt; i++) {
                    if (num % primes[i] === 0) {
                        isPrime = false;
                        break;
                    }
                }
                
                if (isPrime) {
                    primes.push(num);
                }
                
                num += 2; // Check only odd numbers
            }
            
            return primes;
        }

        function organizeTokens(tokens) {
            const strategy = appState.config.bankStructure.organizationStrategy;
            const deduplicateTokens = appState.config.bankStructure.deduplicateTokens;
            
            // Create a copy of tokens
            let result = [...tokens];
            
            // Deduplicate if needed
            if (deduplicateTokens) {
                const uniqueTokens = new Map();
                
                tokens.forEach(token => {
                    if (!uniqueTokens.has(token.token)) {
                        uniqueTokens.set(token.token, token);
                    }
                });
                
                result = Array.from(uniqueTokens.values());
            }
            
            // Apply organization strategy
            switch (strategy) {
                case 'frequency':
                    // Count token frequencies in original list (before deduplication)
                    const frequencies = new Map();
                    tokens.forEach(t => {
                        frequencies.set(t.token, (frequencies.get(t.token) || 0) + 1);
                    });
                    
                    // Sort by frequency (descending)
                    result.sort((a, b) => {
                        return frequencies.get(b.token) - frequencies.get(a.token);
                    });
                    break;
                    
                case 'alphabetical':
                    result.sort((a, b) => a.token.localeCompare(b.token));
                    break;
                    
                case 'length':
                    result.sort((a, b) => b.token.length - a.token.length);
                    break;
                    
                case 'semantic':
                    // This would require a more sophisticated implementation
                    // For demo purposes, we'll just group by first letter
                    result.sort((a, b) => a.token.charAt(0).localeCompare(b.token.charAt(0)));
                    break;
                    
                case 'random':
                    // Use random seed for consistent random sorting
                    const seed = 42; // Could be configurable
                    const rng = seedRandom(seed);
                    
                    result.sort(() => rng() - 0.5);
                    break;
                    
                case 'custom':
                    // Custom organization would be implemented here
                    break;
                    
                // 'sequential' is default - leave original order
                default:
                    break;
            }
            
            return result;
        }

        function seedRandom(seed) {
            return function() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };
        }

        function displayBankStructure(bankData) {
            const container = elements.structurePreview;
            container.innerHTML = '';
            
            if (!bankData || Object.keys(bankData).length === 0) {
                container.innerHTML = '<p>No bank structure generated yet.</p>';
                return;
            }
            
            // Display overview of bank structure
            const bankIds = Object.keys(bankData).sort((a, b) => parseInt(a) - parseInt(b));
            
            bankIds.forEach(bankId => {
                const bank = bankData[bankId];
                const registerIds = Object.keys(bank).sort((a, b) => parseInt(a) - parseInt(b));
                
                const bankPreview = document.createElement('div');
                bankPreview.className = 'bank-preview';
                bankPreview.innerHTML = `<h4>Bank ${bankId}</h4>`;
                
                registerIds.forEach(registerId => {
                    const register = bank[registerId];
                    const addressIds = Object.keys(register.addresses).sort((a, b) => parseInt(a) - parseInt(b));
                    
                    const registerPreview = document.createElement('div');
                    registerPreview.className = 'register-preview';
                    registerPreview.innerHTML = `<strong>Register ${registerId}</strong> (${addressIds.length} addresses)`;
                    
                    // Show first few addresses
                    const showAddresses = Math.min(addressIds.length, 3);
                    for (let i = 0; i < showAddresses; i++) {
                        const addressId = addressIds[i];
                        const value = register.addresses[addressId];
                        
                        const addressPreview = document.createElement('div');
                        addressPreview.className = 'address-preview';
                        addressPreview.textContent = `${addressId}: ${value}`;
                        
                        registerPreview.appendChild(addressPreview);
                    }
                    
                    // Show ellipsis if there are more addresses
                    if (addressIds.length > showAddresses) {
                        const ellipsis = document.createElement('div');
                        ellipsis.className = 'address-preview';
                        ellipsis.textContent = '...';
                        registerPreview.appendChild(ellipsis);
                    }
                    
                    bankPreview.appendChild(registerPreview);
                });
                
                container.appendChild(bankPreview);
            });
        }

        function displayTokenDistribution(bankData) {
            const container = elements.tokenDistribution;
            container.innerHTML = '';
            
            if (!bankData || Object.keys(bankData).length === 0) {
                container.innerHTML = '<p>No data to analyze.</p>';
                return;
            }
            
            // Count tokens per bank
            const bankCounts = new Map();
            
            for (const bankId in bankData) {
                let count = 0;
                
                for (const registerId in bankData[bankId]) {
                    count += Object.keys(bankData[bankId][registerId].addresses).length;
                }
                
                bankCounts.set(parseInt(bankId), count);
            }
            
            // Find max count for scaling
            const maxCount = Math.max(...bankCounts.values());
            
            // Display distribution
            const sortedBanks = Array.from(bankCounts.keys()).sort((a, b) => a - b);
            
            sortedBanks.forEach(bankId => {
                const count = bankCounts.get(bankId);
                const percentage = (count / maxCount) * 100;
                
                const tokenBar = document.createElement('div');
                tokenBar.className = 'token-bar';
                tokenBar.innerHTML = `
                    <div class="token-bar-label">Bank ${bankId}</div>
                    <div class="token-bar-container">
                        <div class="token-bar-value" style="width: ${percentage}%"></div>
                    </div>
                    <div class="token-bar-count">${count}</div>
                `;
                
                container.appendChild(tokenBar);
            });
            
            // Add summary
            const totalTokens = Array.from(bankCounts.values()).reduce((sum, count) => sum + count, 0);
            const summary = document.createElement('div');
            summary.innerHTML = `<p><strong>Total Tokens:</strong> ${totalTokens}</p>`;
            container.appendChild(summary);
        }
        
        // Manual bank structure functions
        function addBank() {
            // This would add a new bank to the manual structure editor
            const bankStructureEditor = elements.bankStructureEditor;
            
            // Get existing banks
            const existingBanks = bankStructureEditor.querySelectorAll('.bank-container');
            const bankId = existingBanks.length + 1;
            
            // Create bank container
            const bankContainer = document.createElement('div');
            bankContainer.className = 'bank-container';
            bankContainer.innerHTML = `
                <div class="bank-header">
                    <h4>Bank ${bankId}</h4>
                    <div>
                        <button class="btn-small btn-secondary add-register-btn">Add Register</button>
                        <button class="btn-small btn-accent remove-bank-btn">Remove</button>
                    </div>
                </div>
                <div class="registers-container"></div>
            `;
            
            // Add event listeners
            bankContainer.querySelector('.add-register-btn').addEventListener('click', () => addRegister(bankContainer));
            bankContainer.querySelector('.remove-bank-btn').addEventListener('click', () => bankContainer.remove());
            
            // Add to editor
            bankStructureEditor.appendChild(bankContainer);
            
            // Add first register
            addRegister(bankContainer);
        }
        
        function addRegister(bankContainer) {
            const registersContainer = bankContainer.querySelector('.registers-container');
            
            // Get existing registers
            const existingRegisters = registersContainer.querySelectorAll('.register-container');
            const registerId = existingRegisters.length + 1;
            
            // Create register container
            const registerContainer = document.createElement('div');
            registerContainer.className = 'register-container';
            registerContainer.innerHTML = `
                <div class="register-header">
                    <h5>Register ${registerId}</h5>
                    <div>
                        <button class="btn-small btn-secondary add-address-btn">Add Address</button>
                        <button class="btn-small btn-accent remove-register-btn">Remove</button>
                    </div>
                </div>
                <div class="addresses-container"></div>
            `;
            
            // Add event listeners
            registerContainer.querySelector('.add-address-btn').addEventListener('click', () => addAddress(registerContainer));
            registerContainer.querySelector('.remove-register-btn').addEventListener('click', () => registerContainer.remove());
            
            // Add to container
            registersContainer.appendChild(registerContainer);
            
            // Add first address
            addAddress(registerContainer);
        }
        
        function addAddress(registerContainer) {
            const addressesContainer = registerContainer.querySelector('.addresses-container');
            
            // Get existing addresses
            const existingAddresses = addressesContainer.querySelectorAll('.address-item');
            const addressId = existingAddresses.length + 1;
            
            // Create address item
            const addressItem = document.createElement('div');
            addressItem.className = 'address-item';
            addressItem.innerHTML = `
                <div class="address-id">${addressId}</div>
                <input type="text" class="address-value" placeholder="Value">
                <div class="address-controls">
                    <button class="btn-small btn-accent remove-address-btn">Remove</button>
                </div>
            `;
            
            // Add event listener
            addressItem.querySelector('.remove-address-btn').addEventListener('click', () => addressItem.remove());
            
            // Add to container
            addressesContainer.appendChild(addressItem);
        }
        
        function clearBankStructure() {
            elements.bankStructureEditor.innerHTML = '<p>Use the controls above to build your bank structure.</p>';
        }
        
        function saveManualStructure() {
            // This would save the manually created structure
            const bankData = {};
            
            // Get all banks
            const banks = elements.bankStructureEditor.querySelectorAll('.bank-container');
            
            if (banks.length === 0) {
                showToast('No banks to save. Add some banks first.', 'warning');
                return;
            }
            
            // Process each bank
            banks.forEach((bank, bankIndex) => {
                const bankId = bankIndex + 1;
                bankData[bankId] = {};
                
                // Get all registers in this bank
                const registers = bank.querySelectorAll('.register-container');
                
                // Process each register
                registers.forEach((register, registerIndex) => {
                    const registerId = registerIndex + 1;
                    bankData[bankId][registerId] = { addresses: {} };
                    
                    // Get all addresses in this register
                    const addresses = register.querySelectorAll('.address-item');
                    
                    // Process each address
                    addresses.forEach((address, addressIndex) => {
                        const addressId = addressIndex + 1;
                        const value = address.querySelector('.address-value').value;
                        
                        bankData[bankId][registerId].addresses[addressId] = value;
                    });
                });
            });
            
            // Update app state
            appState.bankData = bankData;
            
            // Update preview
            displayBankStructure(bankData);
            displayTokenDistribution(bankData);
            
            showToast('Manual structure saved successfully', 'success');
        }
        
        // Placeholder for hybrid structure functions
        function generateHybridStructure() {
            if (!appState.tokens || appState.tokens.length === 0) {
                showToast('No tokens to organize. Extract tokens first.', 'warning');
                switchTab('token-extraction');
                return;
            }
            
            // Generate initial structure
            generateBankStructure();
            
            // Clone the bankData for editing
            const hybridBankData = JSON.parse(JSON.stringify(appState.bankData));
            
            // Display in the hybrid editor
            displayHybridStructure(hybridBankData);
            
            showToast('Base structure generated. You can now modify it manually.', 'success');
        }
        
        function displayHybridStructure(bankData) {
            const container = elements.hybridStructureEditor;
            container.innerHTML = '';
            
            if (!bankData || Object.keys(bankData).length === 0) {
                container.innerHTML = '<p>No structure to display. Generate a base structure first.</p>';
                return;
            }
            
            // Create editable structure
            for (const bankId in bankData) {
                // Create bank container
                const bankContainer = document.createElement('div');
                bankContainer.className = 'bank-container';
                bankContainer.innerHTML = `
                    <div class="bank-header">
                        <h4>Bank ${bankId}</h4>
                        <div>
                            <button class="btn-small btn-secondary add-register-btn">Add Register</button>
                            <button class="btn-small btn-accent remove-bank-btn">Remove</button>
                        </div>
                    </div>
                    <div class="registers-container"></div>
                `;
                
                // Add event listeners
                bankContainer.querySelector('.add-register-btn').addEventListener('click', () => addRegister(bankContainer));
                bankContainer.querySelector('.remove-bank-btn').addEventListener('click', () => bankContainer.remove());
                
                // Add to editor
                container.appendChild(bankContainer);
                
                // Add registers
                const registersContainer = bankContainer.querySelector('.registers-container');
                
                for (const registerId in bankData[bankId]) {
                    // Create register container
                    const registerContainer = document.createElement('div');
                    registerContainer.className = 'register-container';
                    registerContainer.innerHTML = `
                        <div class="register-header">
                            <h5>Register ${registerId}</h5>
                            <div>
                                <button class="btn-small btn-secondary add-address-btn">Add Address</button>
                                <button class="btn-small btn-accent remove-register-btn">Remove</button>
                            </div>
                        </div>
                        <div class="addresses-container"></div>
                    `;
                    
                    // Add event listeners
                    registerContainer.querySelector('.add-address-btn').addEventListener('click', () => addAddress(registerContainer));
                    registerContainer.querySelector('.remove-register-btn').addEventListener('click', () => registerContainer.remove());
                    
                    // Add to container
                    registersContainer.appendChild(registerContainer);
                    
                    // Add addresses
                    const addressesContainer = registerContainer.querySelector('.addresses-container');
                    
                    for (const addressId in bankData[bankId][registerId].addresses) {
                        const value = bankData[bankId][registerId].addresses[addressId];
                        
                        // Create address item
                        const addressItem = document.createElement('div');
                        addressItem.className = 'address-item';
                        addressItem.innerHTML = `
                            <div class="address-id">${addressId}</div>
                            <input type="text" class="address-value" value="${escapeHtml(value)}" placeholder="Value">
                            <div class="address-controls">
                                <button class="btn-small btn-accent remove-address-btn">Remove</button>
                            </div>
                        `;
                        
                        // Add event listener
                        addressItem.querySelector('.remove-address-btn').addEventListener('click', () => addressItem.remove());
                        
                        // Add to container
                        addressesContainer.appendChild(addressItem);
                    }
                }
            }
            
            // Add button to add new banks
            const addBankButton = document.createElement('button');
            addBankButton.className = 'btn-secondary';
            addBankButton.textContent = 'Add New Bank';
            addBankButton.addEventListener('click', () => {
                // Create new bank with ID one higher than the highest existing ID
                const bankIds = Array.from(container.querySelectorAll('.bank-container')).map(bank => {
                    const header = bank.querySelector('.bank-header h4');
                    return parseInt(header.textContent.replace('Bank ', ''));
                });
                
                const maxBankId = Math.max(...bankIds);
                const newBankId = maxBankId + 1;
                
                // Create bank container
                const bankContainer = document.createElement('div');
                bankContainer.className = 'bank-container';
                bankContainer.innerHTML = `
                    <div class="bank-header">
                        <h4>Bank ${newBankId}</h4>
                        <div>
                            <button class="btn-small btn-secondary add-register-btn">Add Register</button>
                            <button class="btn-small btn-accent remove-bank-btn">Remove</button>
                        </div>
                    </div>
                    <div class="registers-container"></div>
                `;
                
                // Add event listeners
                bankContainer.querySelector('.add-register-btn').addEventListener('click', () => addRegister(bankContainer));
                bankContainer.querySelector('.remove-bank-btn').addEventListener('click', () => bankContainer.remove());
                
                // Add to editor
                container.appendChild(bankContainer);
                
                // Add first register
                addRegister(bankContainer);
            });
            
            container.appendChild(addBankButton);
        }
        
        function saveHybridStructure() {
            // Similar to saveManualStructure but working with the hybrid editor
            const bankData = {};
            
            // Get all banks
            const banks = elements.hybridStructureEditor.querySelectorAll('.bank-container');
            
            if (banks.length === 0) {
                showToast('No banks to save. Generate a structure first.', 'warning');
                return;
            }
            
            // Process each bank
            banks.forEach((bank) => {
                const bankHeader = bank.querySelector('.bank-header h4');
                const bankId = parseInt(bankHeader.textContent.replace('Bank ', ''));
                
                bankData[bankId] = {};
                
                // Get all registers in this bank
                const registers = bank.querySelectorAll('.register-container');
                
                // Process each register
                registers.forEach((register) => {
                    const registerHeader = register.querySelector('.register-header h5');
                    const registerId = parseInt(registerHeader.textContent.replace('Register ', ''));
                    
                    bankData[bankId][registerId] = { addresses: {} };
                    
                    // Get all addresses in this register
                    const addresses = register.querySelectorAll('.address-item');
                    
                    // Process each address
                    addresses.forEach((address) => {
                        const addressId = parseInt(address.querySelector('.address-id').textContent);
                        const value = address.querySelector('.address-value').value;
                        
                        bankData[bankId][registerId].addresses[addressId] = value;
                    });
                });
            });
            
            // Update app state
            appState.bankData = bankData;
            
            // Update preview
            displayBankStructure(bankData);
            displayTokenDistribution(bankData);
            
            showToast('Hybrid structure saved successfully', 'success');
        }

        // Reference Generation Tab Functions
        function toggleReferenceFormat() {
            const format = elements.referenceFormat.value;
            elements.customFormatContainer.style.display = format === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.referenceGeneration.referenceFormat = format;
        }

        function toggleFormattingStyle() {
            const style = elements.formattingStyle.value;
            elements.customFormatterContainer.style.display = style === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.referenceGeneration.formattingStyle = style;
        }

        function toggleReferenceStrategy() {
            const strategy = elements.referenceStrategy.value;
            elements.customStrategyContainer.style.display = strategy === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.referenceGeneration.referenceStrategy = strategy;
        }

        function toggleConflictStrategy() {
            const strategy = elements.refConflictStrategy.value;
            elements.customConflictResolver.style.display = strategy === 'custom' ? 'block' : 'none';
            
            // Update config
            appState.config.referenceGeneration.conflictStrategy = strategy;
        }

        function toggleSelectiveReference() {
            const enabled = elements.enableSelectiveReference.checked;
            elements.selectivePatternsContainer.style.display = enabled ? 'block' : 'none';
            
            // Update config
            appState.config.referenceGeneration.enableSelectiveReference = enabled;
        }

        // Output functions
        function processWithAllSettings() {
            if (!appState.bankData || Object.keys(appState.bankData).length === 0) {
                showToast('Please generate a bank structure first', 'error');
                return;
            }
            
            // Create structured data
            const structuredData = {
                metadata: {
                    tokenCount: appState.tokens.length,
                    createdAt: new Date().toISOString(),
                    config: appState.config
                },
                tokens: appState.tokens,
                bankData: appState.bankData
            };
            
            appState.processedData = structuredData;
            
            // Generate text output based on settings
            const outputFormat = elements.outputFormat.value;
            const bankData = appState.bankData;
            
            // Generate bank format output
            let bankOutput = '';
            
            for (const bankId in bankData) {
                bankOutput += `Bank ${bankId}\n`;
                
                for (const registerId in bankData[bankId]) {
                    bankOutput += `${registerId}\n`;
                    
                    for (const addressId in bankData[bankId][registerId].addresses) {
                        const value = bankData[bankId][registerId].addresses[addressId];
                        
                        // Check if multi-line
                        if (value && value.includes('\n') && appState.config.advancedProcessing.preserveMultiline) {
                            const delimiter = appState.config.advancedProcessing.multilineDelimiter;
                            bankOutput += `\t${addressId}\t${delimiter}\n${value}\n${delimiter}\n`;
                        } else {
                            bankOutput += `\t${addressId}\t${value}\n`;
                        }
                    }
                    
                    bankOutput += '\n';
                }
                
                bankOutput += '---\n\n';
            }
            
            appState.reconstructedData = bankOutput;
            
            // Display output
            elements.jsonOutput.textContent = JSON.stringify(structuredData, null, 2);
            elements.bankOutput.textContent = bankOutput;
            
            // Enable download buttons
            elements.downloadJsonBtn.disabled = false;
            elements.downloadTxtBtn.disabled = false;
            elements.downloadZipBtn.disabled = false;
            elements.copyJsonBtn.disabled = false;
            elements.copyTxtBtn.disabled = false;
            
            showToast('Processing complete! Output generated successfully.', 'success');
        }

        function downloadJson() {
            if (!appState.processedData) {
                showToast('No data to download', 'error');
                return;
            }
            
            const json = JSON.stringify(appState.processedData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            saveAs(blob, `${elements.packageName.value || 'data_bank_structure'}.json`);
            
            showToast('JSON downloaded successfully', 'success');
        }

        function downloadTxt() {
            if (!appState.reconstructedData) {
                showToast('No data to download', 'error');
                return;
            }
            
            const blob = new Blob([appState.reconstructedData], { type: 'text/plain' });
            saveAs(blob, `${elements.packageName.value || 'bank_structure'}.txt`);
            
            showToast('TXT downloaded successfully', 'success');
        }

        function downloadZip() {
            if (!appState.bankData || Object.keys(appState.bankData).length === 0) {
                showToast('No bank data to download', 'error');
                return;
            }
            
            const zip = new JSZip();
            
            // Add each bank as a separate txt file
            for (const bankId in appState.bankData) {
                let bankText = '';
                
                for (const registerId in appState.bankData[bankId]) {
                    bankText += `${registerId}\n`;
                    
                    for (const addressId in appState.bankData[bankId][registerId].addresses) {
                        const value = appState.bankData[bankId][registerId].addresses[addressId];
                        
                        // Check if multi-line
                        if (value && value.includes('\n') && appState.config.advancedProcessing.preserveMultiline) {
                            const delimiter = appState.config.advancedProcessing.multilineDelimiter;
                            bankText += `\t${addressId}\t${delimiter}\n${value}\n${delimiter}\n`;
                        } else {
                            bankText += `\t${addressId}\t${value}\n`;
                        }
                    }
                    
                    bankText += '\n';
                }
                
                zip.file(`${bankId}.txt`, bankText);
            }
            
            // Add JSON structure
            if (appState.processedData) {
                zip.file('structure.json', JSON.stringify(appState.processedData, null, 2));
            }
            
            // Add configuration
            zip.file('config.json', JSON.stringify(appState.config, null, 2));
            
            // Generate and download zip
            zip.generateAsync({ type: 'blob' }).then(function(content) {
                saveAs(content, `${elements.packageName.value || 'data_bank_package'}.zip`);
                showToast('ZIP package downloaded successfully', 'success');
            });
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success');
            }).catch(err => {
                showToast('Failed to copy: ' + err, 'error');
            });
        }

        // Visualization Tab Functions
        function updateVisualization() {
            if (!appState.bankData || Object.keys(appState.bankData).length === 0) {
                elements.bankVisualization.innerHTML = '<p>Process your data first to see the visualization.</p>';
                return;
            }
            
            const viewLevel = elements.previewLevel.value;
            const bankId = appState.currentBank;
            
            // Update bank navigation
            updateBankNavigation();
            
            // Display bank visualization based on view level
            displayBankVisualization(bankId, viewLevel);
        }
        
        function updateBankNavigation() {
            const bankIds = Object.keys(appState.bankData).map(id => parseInt(id)).sort((a, b) => a - b);
            appState.totalBanks = bankIds.length;
            
            // Update bank indicator
            elements.bankIndicator.textContent = `Bank: ${appState.currentBank} / ${appState.totalBanks}`;
            
            // Update navigation buttons
            elements.prevBank.disabled = appState.currentBank <= bankIds[0];
            elements.nextBank.disabled = appState.currentBank >= bankIds[bankIds.length - 1];
        }
        
        function navigateBank(direction) {
            const bankIds = Object.keys(appState.bankData).map(id => parseInt(id)).sort((a, b) => a - b);
            const currentIndex = bankIds.indexOf(appState.currentBank);
            
            if (currentIndex === -1) {
                appState.currentBank = bankIds[0];
            } else {
                const newIndex = currentIndex + direction;
                if (newIndex >= 0 && newIndex < bankIds.length) {
                    appState.currentBank = bankIds[newIndex];
                }
            }
            
            updateVisualization();
        }
        
        function displayBankVisualization(bankId, viewLevel) {
            const container = elements.bankVisualization;
            container.innerHTML = '';
            
            if (!appState.bankData[bankId]) {
                container.innerHTML = `<p>Bank ${bankId} not found. Select another bank.</p>`;
                return;
            }
            
            // Display bank visualization based on view level
            const bank = appState.bankData[bankId];
            
            switch (viewLevel) {
                case 'overview':
                    displayBankOverview(container, bankId, bank);
                    break;
                case 'detailed':
                    displayBankDetailed(container, bankId, bank);
                    break;
                case 'references':
                    displayBankReferences(container, bankId, bank);
                    break;
                case 'heatmap':
                    displayBankHeatmap(container, bankId, bank);
                    break;
                default:
                    displayBankOverview(container, bankId, bank);
            }
        }
        
        function displayBankOverview(container, bankId, bank) {
            container.innerHTML = `<h3>Bank ${bankId} Overview</h3>`;
            
            const registersCount = Object.keys(bank).length;
            const addressesCount = Object.keys(bank).reduce((sum, registerId) => 
                sum + Object.keys(bank[registerId].addresses).length, 0);
            
            const overviewInfo = document.createElement('div');
            overviewInfo.innerHTML = `
                <p><strong>Total Registers:</strong> ${registersCount}</p>
                <p><strong>Total Addresses:</strong> ${addressesCount}</p>
            `;
            
            container.appendChild(overviewInfo);
            
            // Visual representation
            const visualization = document.createElement('div');
            visualization.className = 'bank-structure-viz';
            
            const registerIds = Object.keys(bank).sort((a, b) => parseInt(a) - parseInt(b));
            
            registerIds.forEach(registerId => {
                const registerDiv = document.createElement('div');
                registerDiv.className = 'register-preview';
                
                const addressCount = Object.keys(bank[registerId].addresses).length;
                
                registerDiv.innerHTML = `
                    <strong>Register ${registerId}</strong>
                    <div class="progress-container">
                        <div class="progress-bar" style="width: ${(addressCount / appState.config.bankStructure.maxAddresses) * 100}%"></div>
                        <div class="progress-text">${addressCount} addresses</div>
                    </div>
                `;
                
                visualization.appendChild(registerDiv);
            });
            
            container.appendChild(visualization);
        }
        
        function displayBankDetailed(container, bankId, bank) {
            container.innerHTML = `<h3>Bank ${bankId} Detailed View</h3>`;
            
            const detailedView = document.createElement('div');
            
            const registerIds = Object.keys(bank).sort((a, b) => parseInt(a) - parseInt(b));
            
            registerIds.forEach(registerId => {
                const registerDiv = document.createElement('div');
                registerDiv.className = 'register-preview';
                registerDiv.innerHTML = `<strong>Register ${registerId}</strong>`;
                
                const addressesTable = document.createElement('table');
                addressesTable.className = 'data-table';
                addressesTable.innerHTML = `
                    <thead>
                        <tr>
                            <th>Address</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;
                
                const tbody = addressesTable.querySelector('tbody');
                
                const addressIds = Object.keys(bank[registerId].addresses).sort((a, b) => parseInt(a) - parseInt(b));
                
                addressIds.forEach(addressId => {
                    const value = bank[registerId].addresses[addressId];
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${addressId}</td>
                        <td>${escapeHtml(value)}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
                registerDiv.appendChild(addressesTable);
                detailedView.appendChild(registerDiv);
            });
            
            container.appendChild(detailedView);
        }
        
        function displayBankReferences(container, bankId, bank) {
            // This would display references to/from values in this bank
            container.innerHTML = `<h3>Bank ${bankId} Reference View</h3>`;
            
            // Placeholder for reference visualization
            const referenceView = document.createElement('div');
            referenceView.innerHTML = '<p>Reference visualization would be displayed here.</p>';
            
            container.appendChild(referenceView);
        }
        
        function displayBankHeatmap(container, bankId, bank) {
            // This would display a heatmap of bank usage
            container.innerHTML = `<h3>Bank ${bankId} Usage Heatmap</h3>`;
            
            // Placeholder for heatmap visualization
            const heatmapView = document.createElement('div');
            heatmapView.innerHTML = '<p>Usage heatmap would be displayed here.</p>';
            
            container.appendChild(heatmapView);
        }

		// Reference Generation implementation
		function generateReferences() {
			if (!appState.bankData || Object.keys(appState.bankData).length === 0) {
				showToast('Please generate a bank structure first', 'error');
				switchTab('bank-structure');
				return;
			}
			
			// Update reference generation config from UI
			updateReferenceGenerationConfigFromUI();
			
			// Generate references
			const referenceMap = createReferenceMap();
			
			// Display reference map
			displayReferenceMap(referenceMap);
			
			// Display reference text preview if applicable
			if (appState.config.referenceGeneration.referenceStrategy !== 'dictionary') {
				const referencedText = generateReferencedText(referenceMap);
				displayReferencedText(referencedText);
			}
			
			// Display reference statistics
			displayReferenceStatistics(referenceMap);
			
			showToast('References generated successfully', 'success');
		}

		function updateReferenceGenerationConfigFromUI() {
			const config = appState.config.referenceGeneration;
			
			config.referenceFormat = elements.referenceFormat.value;
			config.customFormat = elements.customFormat.value;
			config.formattingStyle = elements.formattingStyle.value;
			config.customFormatter = elements.customFormatter.value;
			config.referenceStrategy = elements.referenceStrategy.value;
			config.customStrategy = elements.customStrategy.value;
			config.minTokenLength = parseInt(elements.refMinLength.value);
			config.minOccurrences = parseInt(elements.refMinOccurrences.value);
			config.enableSelectiveReference = elements.enableSelectiveReference.checked;
			config.selectivePatterns = elements.selectivePatterns.value;
			config.enableNestedReferences = elements.enableNestedReferences.checked;
			config.enableCircularDetection = elements.enableCircularDetection.checked;
			config.nestedDepthLimit = parseInt(elements.nestedDepthLimit.value);
			config.cacheResolvedReferences = elements.cacheResolvedReferences.checked;
			config.conflictStrategy = elements.refConflictStrategy.value;
			
			if (config.conflictStrategy === 'custom') {
				config.conflictResolver = elements.conflictResolver.value;
			}
			
			saveConfigToStorage();
		}

		function createReferenceMap() {
			// Get tokens to process
			const tokens = [...appState.tokens];
			
			// Create reference map
			const referenceMap = new Map();
			const tokenCounts = new Map();
			
			// Count token occurrences
			tokens.forEach(token => {
				const count = tokenCounts.get(token.token) || 0;
				tokenCounts.set(token.token, count + 1);
			});
			
			// Create bank -> register -> address references
			for (const bankId in appState.bankData) {
				for (const registerId in appState.bankData[bankId]) {
					for (const addressId in appState.bankData[bankId][registerId].addresses) {
						const value = appState.bankData[bankId][registerId].addresses[addressId];
						
						// Only create references for tokens that meet criteria
						const count = tokenCounts.get(value) || 0;
						const minLength = appState.config.referenceGeneration.minTokenLength;
						const minOccurrences = appState.config.referenceGeneration.minOccurrences;
						
						if (value.length >= minLength && count >= minOccurrences) {
							// Create reference
							const reference = {
								bank: parseInt(bankId),
								register: parseInt(registerId),
								address: parseInt(addressId)
							};
							
							// Store reference
							referenceMap.set(value, reference);
						}
					}
				}
			}
			
			return referenceMap;
		}

		function displayReferenceMap(referenceMap) {
			const container = elements.referenceMap;
			container.innerHTML = '';
			
			if (referenceMap.size === 0) {
				container.innerHTML = '<p>No references generated. Try adjusting your settings.</p>';
				return;
			}
			
			// Display references
			for (const [token, reference] of referenceMap) {
				const referenceItem = document.createElement('div');
				referenceItem.className = 'reference-item';
				
				const refPath = formatReference(reference);
				
				referenceItem.innerHTML = `
					<div class="reference-token">${escapeHtml(token)}</div>
					<div class="reference-path">${refPath}</div>
				`;
				
				container.appendChild(referenceItem);
			}
		}

		function formatReference(reference) {
			const format = appState.config.referenceGeneration.referenceFormat;
			const customFormat = appState.config.referenceGeneration.customFormat;
			
			switch (format) {
				case 'standard':
					return `${reference.bank}.${reference.register}.${reference.address}`;
					
				case 'compact':
					return `${reference.bank}:${reference.register}:${reference.address}`;
					
				case 'coded':
					return `${reference.bank.toString(16)}${reference.register.toString(16)}${reference.address.toString(16)}`;
					
				case 'base64':
					const str = `${reference.bank}.${reference.register}.${reference.address}`;
					return btoa(str);
					
				case 'custom':
					return customFormat
						.replace('{b}', reference.bank)
						.replace('{r}', reference.register)
						.replace('{a}', reference.address);
					
				default:
					return `${reference.bank}.${reference.register}.${reference.address}`;
			}
		}

		function generateReferencedText(referenceMap) {
			// This is a simplified implementation
			// A complete version would follow all the configuration options
			
			const strategy = appState.config.referenceGeneration.referenceStrategy;
			let referencedText = appState.inputText;
			
			if (strategy === 'direct') {
				// Replace all occurrences with references
				for (const [token, reference] of referenceMap) {
					const refStr = formatReference(reference);
					const regex = new RegExp(`\\b${escapeRegExp(token)}\\b`, 'g');
					referencedText = referencedText.replace(regex, refStr);
				}
			} else if (strategy === 'hybrid') {
				// Keep first occurrence, replace others with references
				for (const [token, reference] of referenceMap) {
					const refStr = formatReference(reference);
					
					// Find first occurrence
					const firstIndex = referencedText.indexOf(token);
					if (firstIndex !== -1) {
						// Replace all occurrences after the first
						const beforeFirst = referencedText.substring(0, firstIndex + token.length);
						const afterFirst = referencedText.substring(firstIndex + token.length);
						
						const regex = new RegExp(`\\b${escapeRegExp(token)}\\b`, 'g');
						const replacedAfter = afterFirst.replace(regex, refStr);
						
						referencedText = beforeFirst + replacedAfter;
					}
				}
			}
			// Other strategies would be implemented here
			
			return referencedText;
		}

		function escapeRegExp(string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		}

		function displayReferencedText(text) {
			elements.referenceTextPreview.innerHTML = `
				<pre style="white-space: pre-wrap; word-break: break-word;">${escapeHtml(text)}</pre>
			`;
		}

		function displayReferenceStatistics(referenceMap) {
			elements.referenceStats.innerHTML = `
				<p><strong>Total References:</strong> ${referenceMap.size}</p>
				<p><strong>Reference Format:</strong> ${appState.config.referenceGeneration.referenceFormat}</p>
				<p><strong>Strategy:</strong> ${appState.config.referenceGeneration.referenceStrategy}</p>
			`;
		}
		
		// Advanced Processing Tab Functions
		function toggleCompressionLevel() {
			const level = elements.compressionLevel.value;
			elements.customCompressionContainer.style.display = level === 'custom' ? 'block' : 'none';
			
			// Update config
			appState.config.advancedProcessing.compressionLevel = level;
		}

		function toggleMultilineOptions() {
			const enabled = elements.preserveMultiline.checked;
			elements.multilineOptions.style.display = enabled ? 'block' : 'none';
			
			// Update config
			appState.config.advancedProcessing.preserveMultiline = enabled;
		}

		function toggleCustomPipeline() {
			const enabled = elements.enableCustomPipeline.checked;
			elements.pipelineConfig.style.display = enabled ? 'block' : 'none';
			
			// Update config
			appState.config.advancedProcessing.enableCustomPipeline = enabled;
		}

		function testPipeline() {
			if (!appState.tokens || appState.tokens.length === 0) {
				showToast('Please extract tokens first', 'warning');
				return;
			}
			
			// Get custom pipeline code
			const pipelineCode = elements.customPipeline.value;
			
			try {
				// Parse pipeline steps
				const pipeline = new Function(`return ${pipelineCode}`)();
				
				// Create a copy of data to test pipeline
				const testData = {
					tokens: [...appState.tokens],
					bankData: JSON.parse(JSON.stringify(appState.bankData || {})),
					config: JSON.parse(JSON.stringify(appState.config))
				};
				
				// Visualize pipeline
				visualizePipeline(pipeline, testData);
				
			} catch (e) {
				showToast(`Error in pipeline code: ${e.message}`, 'error');
				console.error('Pipeline error:', e);
			}
		}

		function visualizePipeline(pipeline, testData) {
			const container = elements.pipelineVisualization;
			container.innerHTML = '';
			
			if (!Array.isArray(pipeline) || pipeline.length === 0) {
				container.innerHTML = '<p>No pipeline steps defined.</p>';
				return;
			}
			
			// Create pipeline visualization
			for (let i = 0; i < pipeline.length; i++) {
				const step = pipeline[i];
				
				// Create step container
				const stepContainer = document.createElement('div');
				stepContainer.className = 'pipeline-stage';
				
				// Create step header
				const stepHeader = document.createElement('div');
				stepHeader.className = 'pipeline-stage-header';
				stepHeader.innerHTML = `Step ${i + 1}: ${step.name || 'Unnamed Step'}`;
				
				// Create step content
				const stepContent = document.createElement('div');
				stepContent.className = 'pipeline-stage-content';
				
				// Try to run this step and show sample output
				try {
					const result = step.process(testData);
					
					// Show sample of data after this step
					const tokenCount = result.tokens ? result.tokens.length : 'N/A';
					const sampleTokens = result.tokens ? result.tokens.slice(0, 3).map(t => t.token).join(', ') : 'None';
					
					stepContent.innerHTML = `
						<p><strong>Tokens after step:</strong> ${tokenCount}</p>
						<p><strong>Sample tokens:</strong> ${sampleTokens}${result.tokens && result.tokens.length > 3 ? '...' : ''}</p>
					`;
					
					// Update test data for next step
					testData = result;
					
				} catch (e) {
					stepContent.innerHTML = `<p class="error">Error executing step: ${e.message}</p>`;
				}
				
				// Add to container
				stepContainer.appendChild(stepHeader);
				stepContainer.appendChild(stepContent);
				container.appendChild(stepContainer);
				
				// Add arrow if not last step
				if (i < pipeline.length - 1) {
					const arrow = document.createElement('div');
					arrow.className = 'pipeline-arrow';
					arrow.innerHTML = 'â†“';
					container.appendChild(arrow);
				}
			}
		}

		function applyPipeline() {
			if (!appState.tokens || appState.tokens.length === 0) {
				showToast('Please extract tokens first', 'warning');
				return;
			}
			
			if (!elements.enableCustomPipeline.checked) {
				showToast('Enable custom pipeline first', 'warning');
				return;
			}
			
			// Get custom pipeline code
			const pipelineCode = elements.customPipeline.value;
			
			try {
				// Parse pipeline steps
				const pipeline = new Function(`return ${pipelineCode}`)();
				
				// Apply pipeline to actual data
				let processedData = {
					tokens: [...appState.tokens],
					bankData: appState.bankData || {},
					config: appState.config
				};
				
				// Run each step
				for (const step of pipeline) {
					processedData = step.process(processedData);
				}
				
				// Update app state with processed data
				appState.tokens = processedData.tokens;
				appState.bankData = processedData.bankData;
				
				// Update UI
				displayTokens(appState.tokens);
				displayBankStructure(appState.bankData);
				
				// Update optimization metrics
				updateOptimizationMetrics();
				
				showToast('Pipeline applied successfully', 'success');
				
			} catch (e) {
				showToast(`Error applying pipeline: ${e.message}`, 'error');
				console.error('Pipeline application error:', e);
			}
		}

		function updateOptimizationMetrics() {
			// Calculate original size
			const originalSize = calculateOriginalSize();
			
			// Calculate optimized size
			const optimizedSize = calculateOptimizedSize();
			
			// Calculate compression ratio
			const compressionRatio = originalSize > 0 ? 
				((originalSize - optimizedSize) / originalSize) * 100 : 0;
			
			// Update UI
			elements.originalSize.textContent = originalSize;
			elements.optimizedSize.textContent = optimizedSize;
			elements.compressionRatio.textContent = compressionRatio.toFixed(2);
			
			// Update progress bars
			elements.originalSizeBar.style.width = '100%';
			elements.optimizedSizeBar.style.width = `${100 - compressionRatio}%`;
			
			// Update efficiency metrics
			updateEfficiencyMetrics(originalSize, optimizedSize, compressionRatio);
		}

		function calculateOriginalSize() {
			// Simplified calculation - just the length of the input text
			return appState.inputText.length;
		}

		function calculateOptimizedSize() {
			// Simplified calculation - sum of all bank data sizes
			let size = 0;
			
			if (!appState.bankData) return 0;
			
			for (const bankId in appState.bankData) {
				for (const registerId in appState.bankData[bankId]) {
					for (const addressId in appState.bankData[bankId][registerId].addresses) {
						const value = appState.bankData[bankId][registerId].addresses[addressId];
						size += value.length;
					}
				}
			}
			
			// Add overhead for bank/register/address structure
			const overhead = Object.keys(appState.bankData).length * 10 + // bank IDs
							 Object.keys(appState.bankData).reduce((sum, bankId) => 
								 sum + Object.keys(appState.bankData[bankId]).length * 5, 0); // register IDs
			
			return size + overhead;
		}

		function updateEfficiencyMetrics(originalSize, optimizedSize, compressionRatio) {
			elements.efficiencyMetrics.innerHTML = `
				<p><strong>Original Size:</strong> ${originalSize} bytes</p>
				<p><strong>Optimized Size:</strong> ${optimizedSize} bytes</p>
				<p><strong>Space Saved:</strong> ${(originalSize - optimizedSize)} bytes (${compressionRatio.toFixed(2)}%)</p>
				<p><strong>Compression Level:</strong> ${appState.config.advancedProcessing.compressionLevel}</p>
			`;
		}

    </script>
</body>
</html>


"""

